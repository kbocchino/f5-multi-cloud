# Copyright 2017. F5 Networks, Inc. See End User License Agreement (EULA) for
# license terms. Notwithstanding anything to the contrary in the EULA, Licensee
# may copy and modify this software product for its internal business purposes.
# Further, Licensee may upload, publish and distribute the modified version of
# the software product on devcentral.f5.com.

cli script f5.iapp.1.5.3.cli {
 
#  Initialization proc for all templates.
#  Parameters "start" and "stop" or "end".
proc iapp_template { action } {
    switch $action {
        start {
            set ::clock_clicks [clock clicks]
            puts "\nStarting iApp $tmsh::app_template_name [clock format \
                [clock seconds] -format {%m/%d/%Y %T}]\n"
            tmsh::log info "Starting iApp template $tmsh::app_template_name"
        }
        stop -
        end {
            if { [info exists ::substa_debug] } {
                puts $::substa_debug
            }
            puts "\nEnding iApp $tmsh::app_template_name [clock format \
                [clock seconds] -format {%m/%d/%Y %T}]\nRun time [expr \
                { ([clock clicks] - $::clock_clicks) / 1000 }] msec\n"
            tmsh::log info "Ending iApp template $tmsh::app_template_name"
        }
    }
    set ::HTTP_CONTENT_TYPES { application/(css\|css-stylesheet\|doc\|excel\|javascript\|json\|lotus123\|mdb\|mpp\|msaccess\|msexcel\|ms-excel\|mspowerpoint\|ms-powerpoint\|msproject\|msword\|ms-word\|photoshop\|postscript\|powerpoint\|ps\|psd\|quarkexpress\|rtf\|txt\|visio\|vnd\\.excel\|vnd\\.msaccess\|vnd\\.ms-access\|vnd\\.msexcel\|vnd\\.ms-excel\|vnd\\.mspowerpoint\|vnd\\.ms-powerpoint\|vnd\\.ms-pps\|vnd\\.ms-project\|vnd\\.msword\|vnd\\.ms-word\|vnd\\.ms-works\|vnd\\.ms-works-db\|vnd\\.powerpoint\|vnd\\.visio\|vnd\\.wap\\.cmlscriptc\|vnd\\.wap\\.wmlc\|vnd\\.wap\\.xhtml\\+xml\|vnd\\.word\|vsd\|winword\|wks\|word\|x-excel\|xhtml\\+xml\|x-java-jnlp-file\|x-javascript\|x-json\|x-lotus123\|xls\|x-mdb\|xml\|x-mscardfile\|x-msclip\|x-msexcel\|x-ms-excel\|x-mspowerpoint\|x-msproject\|x-ms-project\|x-msword\|x-msworks-db\|x-msworks-wps\|x-photoshop\|x-postscript\|x-powerpoint\|x-ps\|x-quark-express\|x-rtf\|x-vermeer-rpc\|x-visio\|x-vsd\|x-wks\|x-word\|x-xls\|x-xml) image/(photoshop\|psd\|x-photoshop\|x-vsd) text/(css\|html\|javascript\|json\|plain\|postscript\|richtext\|rtf\|vnd\\.wap\\.wml\|vnd\\.wap\\.wmlscript\|wap\|wml\|x-component\|xml\|x-vcalendar\|x-vcard) }
}

proc iapp_is { args } {
    set up_var [lindex $args 0]
    upvar $up_var var
    if { [info exists var] } {
        foreach val [lrange $args 1 end] {
            if { [subst $var] eq $val } {
                return 1
            }
        }
    }
    return 0
}

proc iapp_substa { args } {
    upvar substa_in  argx \
          substa_out rval
    set   argx $args

    # check the explicit value first.
    # multiple layers of variable substitution requires multiple subst.
    # error occurs here if any of the substituted variables do not exist
    # valid wildcard (*) array entries will fail here first.
    uplevel {
        append ::substa_debug "\n$substa_in"
        if { [info exists [set substa_in]] } {
            set substa_out [subst $$substa_in]
            set substa_out [subst $substa_out]
        } else {
            # since explicit value did not exist, try a wildcard value.
            # substitute "*" as the array key and repeat.
            set substa_tmp [split $substa_in "()"]
            set substa_in "[lindex $substa_tmp 0](*)"
            append ::substa_debug "*"
            if { [info exists [set substa_in]] } {
                set substa_out [subst $$substa_in]
                set substa_out [subst $substa_out]
            } else {
                error "substa \"$substa_in\" array value not found"
            }
        }
    }
    return $rval
}

proc iapp_conf { args } {

    # Return value $object_name is set to the first word in $arg that
    # contains an underscore, since the position of the object name in
    # tmsh syntax is not consistent.
    set args [join $args]
    set object_name [lindex $args [lsearch -glob $args "*_*"]]

    # Global array ::tmsh_history persists between calls to iapp_conf
    # in order to suppress duplicate commands.
    if { ![info exists ::tmsh_history($args)] } {
        set ::tmsh_history($args) 1
        iapp_debug $args
        switch -exact -- [string range $args 0 5] {
            create { tmsh::create [string range $args 7 end] }
            modify { tmsh::modify [string range $args 7 end] }
            delete { tmsh::delete [string range $args 7 end] }
            default { error "iapp_conf illegal parameter" }
        }
    }
    return $object_name
}

proc iapp_make_safe_password { password } {
    return [string map { \' \\\' \" \\\" \{ \\\{ \} \\\} \; \\\; \| \\\| \# \\\# \  \\\  \\ \\\\ } $password]
}

proc iapp_pull { loc items_list } {
    upvar $items_list items
    if { [set item [lindex $items $loc]] != "" } {
        set items [lreplace $items $loc $loc]
    }
    return $item
}

proc iapp_process_flags { flags_array args_list } {
    upvar $flags_array flags
    upvar $args_list args

    if { [set dubdash [lsearch $args "--"]] != -1 } {
        set args [lreplace $args $dubdash $dubdash];
    } else {
        set dubdash end
    }

    foreach flag [array names flags] {
        while { [set ptr [lsearch [lrange $args 0 $dubdash] $flag]] != -1 } {
            set args [lreplace $args $ptr $ptr];

            # we want to run the code in the flags_array at the calling
            # proc's level so that the variables that it sets up are
            # available there.
            set access_var [format "$%s(%s)" $flags_array $flag]
            set command [subst -nocommands { set ptr $ptr ; subst $access_var }]

            uplevel 1 $command
        }
    }
    return $args
}

proc iapp_tmos_version { args } {
    set cversion [tmsh::version]
    if { $cversion eq "" } {
        tmsh::log err "unable to determine TMOS version"
        error "unable to determine TMOS version"
    }

    # if no op+version was specified, just return the version
    if { $args eq "" } { return $cversion }
    if { [llength $args] > 2 } {
        error "Too many arguments"
    }

    set op [lindex $args 0]; # operator
    set NOTFOUND -1
    # constrain to valid operators - adding more is fine as long as
    # they are supported by [expr] (and makes sense)
    if { [lsearch -exact { < > <= >= == != } $op] == $NOTFOUND } {
        tmsh::log err "illegal operator: $op"
        error "illegal operator: $op"
    }

    set tversion [lindex $args 1]; # target version
    # one or two decimal digits, optionally followed by 0-2 complete groups of
    # dots followed by one or two decimal digits with nothing before or after
    set regex {^\d{1,2}(\.\d{1,2}){0,2}$}
    if { ! [regexp -- $regex $tversion] } {
        tmsh::log err "cannot parse version from: $tversion"
        error "cannot parse version from: $tversion"
    }

    # p=>prefix, c=>current, t=>target
    foreach p { c t } {
        # extract major/minor/point components
        scan [set [set p]version] "%d.%d.%d" [set p]mjr [set p]mnr [set p]pnt
        # ensure that these are each set to at least 0
        foreach level { mjr mnr pnt } {
            if { ! [info exists [set p]${level}] } { set [set p]${level} 0 }
        }
        # turn them into one big number that we can compare
        # leave room in-between just to be safe
        set [set p]num [expr {
            [set [set p]mjr]*1000000 +
            [set [set p]mnr]*10000 +
            [set [set p]pnt]*100
        }]
    }
    # a simple numeric comparison is all that is needed at this point
    return [eval expr $cnum $op $tnum ]
}

proc iapp_safe_display { args } {
    # strings sent to APL must be truncated to 65535 bytes, see BZ435592
    if { [string length [set [set args]]] > 65535 } {
        set last_newline [string last "\n" [set [set args]] 65500]
        return "[string range [set [set args]] 0 $last_newline]Error: Too many items for display"
    } else {
        return [set [set args]]
    }
}

proc iapp_get_items { args } {

    # Set default values.
    set error_msg  "iapp_get_items $args:"
    set do_binary  0
    set nocomplain 0
    set items      ""
    set join_char  "\n"
    set recursive  "recursive"
    set com_dir    "/Common"
    set loc_dir    "[tmsh::pwd]"

    # Set up flag-related work.
    array set flags  {
        -exists      { [set do_binary 1] }
        -nocomplain  { [set nocomplain 1] }
        -list        { [set join_char " "] }
        -norecursive { [set recursive ""] }
        -local       { [set com_dir   ""] }
        -dir         { [set loc_dir      [iapp_pull $ptr args]] }
        -filter      { [set filter_field [iapp_pull $ptr args]] \
                       [set filter_op    [iapp_pull $ptr args]] \
                       [set filter_value [iapp_pull $ptr args]] }
    }
    iapp_process_flags flags args

    # Get system object names in all requested directories.
    set save_dir [tmsh::pwd]
    foreach dir [lsort -unique "$com_dir $loc_dir"] {
        tmsh::cd $dir
        set tmsh_rval [catch {
            foreach obj [tmsh::get_config $args $recursive] {

                if { [info exists filter_field] } {
                    if { $filter_field eq "NAME" } {
                        set val [tmsh::get_name $obj]
                    } else {
                        # If get_field_value throws error, assume "none" value
                        if { [catch {
                            set val [tmsh::get_field_value $obj $filter_field]
                            # strip quotes per BZ442531
                            set val [string map {\" ""} $val]
                        }]} { set val none }
                    }
                    # Non-Tcl operators =~ and !~ added for extra flexibility
                    if { $filter_op eq "=~" } {
                        set filter "\[regexp \"$filter_value\" \"$val\"\]"
                    } elseif { $filter_op eq "!~" } {
                        set filter "!\[regexp \"$filter_value\" \"$val\"\]"
                    } else {
                        set filter "\\\"$val\\\" $filter_op \\\"$filter_value\\\""
                    }
                    # If filter fails, skip to next object
                    if { ![eval expr $filter] } {
                        continue
                    }
                }
                # string map catches /Common added by ltm profile ntlm,
                # which is unlike all other ltm profile return values.
                lappend items $dir/[string map {/Common/ ""} [tmsh::get_name $obj]]
            }
        } err ]
    }
    tmsh::cd $save_dir

    # array keys: $do_binary,$tmsh_rval,$nocomplain. Do not insert whitespace.
    array set rval {
        0,0,0 {[join $items $join_char]}
        0,0,1 {[join $items $join_char]}
        0,1,0 {[error "$error_msg $err"]}
        0,1,1 {}
        1,0,0 {[llength $items]}
        1,0,1 {[llength $items]}
        1,1,0 {0}
        1,1,1 {0}
    }

    return [subst $rval($do_binary,$tmsh_rval,$nocomplain)]
}

proc iapp_get_provisioned { args } {

    array set lnum {
        none      0
        minimum   1
        nominal   2
        dedicated 3
    }

    # Set defaults.
    set required minimum
    set do_binary 1

    # Set up flag-related work.
    array set flags  {
        -is          { [set required [iapp_pull $ptr args]] }
        -level       { [set do_binary 0] }
    }
    iapp_process_flags flags args
    if { [llength $args] > 1 } {
        error "Too many arguments"
    }

    # If checking for AM provisioning on TMOS < 11.4,
    # check for WAM provisioning instead.
    if { $args eq "am" && [iapp_tmos_version < 11.4] } {
        set args "wam"
    }

    # Get the provisioning level. If blank, assume none.
    # Proc only checks 1 module at a time, so only 1 object is returned.
    if { [catch {
        set obj [tmsh::get_config sys provision $args]
        set level [tmsh::get_field_value [lindex $obj 0] level]
    }]} { set level none }

    if { $do_binary } {
        return [expr { $lnum($level) >= $lnum($required) }]
    } else {
        return $level
    }
}

proc iapp_get_user { args } {

    # Set defaults.
    set do_role 0
    set do_binary 0

    # Set up flag-related work.
    array set flags  {
        -is_admin    { [set do_binary 1] }
    }
    iapp_process_flags flags args
    if { [llength $args] > 1 } {
        error "Too many arguments"
    }

    # Show user auth was introduced in v11.6
    set user "unknown"
    catch {
        set user [tmsh::show auth user field-fmt]
    } err
    if { $do_binary } {
        return [expr { $user == "unknown"
        || [string first "role " $user] == -1
        || [string first "role admin" $user] != -1
        || [string first "role resource-admin" $user] != -1 }]
    } else {
        return $user
    }
}

proc iapp_destination { args } {
    # Set defaults. Flag actions may overwrite defaults later.
    set route_domain    0
    set do_mask         0
    set port            0

    # Set up flag-based actions.
    array set flags  {
        -route_domain { [set route_domain [iapp_pull $ptr args]] }
        -mask         { [set do_mask 1] }
        -length       { [set cidr_bits [iapp_pull $ptr args]] }
    }

    if { [llength [set non_switches [iapp_process_flags flags args]]] > 2 } {
        error "Too many arguments"
    }
    if { [llength $non_switches] == 2 } { set port [lindex $non_switches 1] }
    set addr [lindex $non_switches 0]


    # Detect a CIDR mask and pull it off the addr string
    if { [set loc [string first "/" $addr end-4]] != -1 } {
        set cidr_bits [string range $addr [expr {$loc + 1}] end]
        set addr [string range $addr 0 [expr {$loc - 1}]]
    }

    # Pull the route-domain off the addr string, but only use it as the
    # route domain if it wasn't overridden by -route_domain flag.
    if { [string first "%" $addr] != -1 } {
        if { $route_domain == 0 } {
            # route-domain is still default, so use value from addr string
            set route_domain [lindex [split $addr "%"] 1]
        }
        set addr [lindex [split $addr "%"] 0]
    }

    if { $do_mask } {

        # Define the delta between ipv4 and ipv6.
        # length: ipv4 mask is 32 bits, ipv6 is 128 bits.
        # group: ipv4 is grouped in octets, ipv6 as 16 bit words.
        # format: ipv4 is decimal notation, ipv6 is hex.
        # format1 also has the delimiter, format2 does not.
        array set v {
            0,length  32
            0,group   8
            0,format1 d.
            0,format2 d
            1,length  128
            1,group   16
            1,format1 .4x:
            1,format2 .4x
        }
        set is_ipv6 [string match "*:*:*" $addr]

        # Soften result of an illegal -length parameter.
        if { ![info exists cidr_bits] || $cidr_bits > $v($is_ipv6,length) } {
            set cidr_bits $v($is_ipv6,length)
        } elseif { $cidr_bits < 0 } {
            set cidr_bits 0
        }

        # Loop on the full length of the mask: 32 bits for ipv4, 128 for ipv6
        for { set octet 0; set i 0 } { $i < $v($is_ipv6,length) } { incr i } {

           # Take a break at intervals to save the grouping and add delimiter.
           # Interval is 8 bits for ipv4 and 16 bits for ipv6.
           if { $i && ![expr {$i % $v($is_ipv6,group)}] } {

               # Add the grouping and delimiter to the mask, then reset.
               append mask [format %$v($is_ipv6,format1) $octet]
               set octet 0
           }
           # Shift the prior bits left by multiplying by 2.
           # Then add the current bit, which is 1 if part of the mask, 0 if not.
           # Current bit is part of the mask if $i < number of bits in the mask.
           set octet [expr { 2 * $octet + ($i < $cidr_bits) }]
        }
        # Add the final grouping, then return the finished mask.
        set ret_val [format $mask%$v($is_ipv6,format2) $octet]

    } else {

        # calculate a destination
        # the route domain might be a name and we need a number.
        if { ![string is integer $route_domain] } {
            set route_domains [tmsh::get_config "/ net route-domain $route_domain"]
            if { [llength $route_domains] != 1 } {
                error "no such route domain: $route_domain"
            }
            # since we have already determined that the list is 1 long,
            # this explicit reference to element 0 is safe
            set route_domain [tmsh::get_field_value [lindex $route_domains 0] "id"]
        }

        set route_domain [expr { $route_domain == 0 ? "" : "%$route_domain" }]

        # 0 and * represent wildcard port assignments in the GUI,
        # but TMSH requires the string 'any' to specify a wildcard.
        if { $port == 0 || $port == "*" } {
            set port any
        }

        # Build the final destination. Use ":" for node names even if ipv6.
        set is_ipv6_literal [string match "*:*:*" $addr]
        set addr_delimiter  [expr { $is_ipv6_literal ? "." : ":" }]
        set ret_val ${addr}${route_domain}${addr_delimiter}${port}
    }
    return $ret_val
}

proc iapp_pool_members { args } {

    # Set defaults.
    array set fields {
        address          addr
        port             port
        port-secure      port_secure
        connection-limit connection_limit
        priority-group   priority
        ratio            ratio
    }
    set route_domain ""
    set port_override -1
    set aaa_domain 0
    set aaa_priority -1
    set app_service ""
    # Set up flag-related work.
    array set flags {
        -fields       { [array set fields  [iapp_pull $ptr args]] }
        -route_domain { [set route_domain  [iapp_pull $ptr args]] }
        -port         { [set port_override [iapp_pull $ptr args]] }
        -aaa_domain   { [set aaa_domain    1] }
        -aaa_pool     { [set aaa_priority  0] }
        -noapp        { [set app_service " app-service none"] }
    }
    iapp_process_flags flags args

    # Identify the non-address/non-port fields. These go inside braces in tmsh.
    set nonport_fields [lsearch -all -not -inline -regexp \
        [array names fields] {address|port|port-secure}]

    set members ""
    foreach row [join $args] {

        # Skip invalid table rows.
        if { [llength [join $row]] %2 == 1 } {
            continue
        }

        # Import APL table into an array for processing.
        array unset columns
        array set columns [join $row]
        set addr $columns($fields(address))

        # Identify the port number, either from table columns or by -port flag.
        if { $port_override != -1 } {
            set port $port_override
        } elseif { [info exists columns($fields(port))] } {
            set port $columns($fields(port))
        } elseif { [info exists columns($fields(port-secure))] } {
            set port $columns($fields(port-secure))
        } else {
            set port 80
        }

        # If specified, strip entered route domain and append the flag value.
        if { $route_domain != "" } {
            set addr [lindex [split $addr "%"] 0]
            set addr "$addr%$route_domain"
        }

        # If -aaa_domain, use domain controller format, otherwise use pool format
        if { $aaa_domain } {
            append members " $columns($fields(host)) \{ ip $addr $app_service \}"
        } else {
            append members " [iapp_destination $addr $port] \{"

            # Transfer non-port fields from the table to the tmsh string.
            foreach name $nonport_fields {
                if { [info exists columns($fields($name))] } {
                    append members " $name $columns($fields($name))"
                }
            }

            # If -aaa_pool, add priority field with incrementing value.
            # This is required by APM.
            if { $aaa_priority >= 0 } {
                append members " priority-group [incr aaa_priority]$app_service"
            }
            append members " \}"
        }
    }

    return "[expr { $aaa_domain ? "" : "members " }][expr { $members eq "" \
        ? "none" : "replace-all-with \{ $members \}" }]"
}

proc iapp_debug { args } {

    # Passwords should be obscured in all logs. Fields shown here are handled
    # in this proc, but the global variable may be overwritten if alternate
    # fields should be obscured.
    if { ![info exists ::SENSITIVES] } {
        set ::SENSITIVES {
            account-password
            admin-encrypted-password
            bind-pw
            PASSWORD
            password
            passwd
            proxy-ca-passphrase
            secret
        }
    }

    # look for any of the sensitive words, and replace the word that follows it
    set regex "(\\m([join $::SENSITIVES |])\\M)\\s+\[^\\s\]*"
    regsub -all $regex [join $args] {\1 -OBSCURED-} args
    regsub -all "(<Password.*>).*(</Password>)" $args {\1-OBSCURED-\2} args

    set lev [tmsh::get_field_value [lindex [tmsh::get_config sys scriptd \
        log-level] 0] log-level]
    if { $lev eq {debug} } {
        puts $args
    }
}

# The apm_config proc provides a tmsh pre-processor for APM
# configuration, which in most cases will drastically reduce
# implementation code. To configure APM with this proc, pass
# it an array of object names and associated meta-tag substitutions.
# Each object must be categorized as a profile, a resource, or
# a policy-item. APM agents and customization-groups are derived
# from these 3 categories as needed.
#
# apm_config's return value is a list of the APM profiles defined
# in the argument and instantiated by the proc. This allows the
# procedure call to be embedded directly into a virtual server
# definition.
#
# These universal meta-tags may be placed anywhere in the array:
# <ITEM> The object name, eg. apm_access
# <PREFIX> The app name, including folder, eg. /Common/my_app.app/my_app
#
# Profile objects require the following meta-tags:
# <PROFILE_TYPE> The tmsh object type, eg. "apm profile access"
# <PROFILE_DEF>  The body of the object, eg.:
#     "access-policy <PREFIX>
#      defaults-from /Common/access
#      eps-group <PREFIX>_eps
#      errormap-group <PREFIX>_errormap
#      general-ui-group <PREFIX>_general_ui"
#
# apm_config will automatically create default customization-groups
# for the "-group" lines specified in access profile definitions.
# In the above example, there is no need to additionally specify a
# customization-group for errormap and general-ui.
#
# <PROFILE_TYPE> is a catch-all for other APM types, eg:
#      apm_sso {
#          <PROFILE_TYPE> {apm sso kerberos}
#          <PROFILE_DEF>  "account-name <USER>
#                          account-password <PASS>
#                          realm <REALM>" }
#
# In the example above, <PROFILE_TYPE> and <PROFILE_DEF> are
# apm_config meta-tags, while <USER>, <PASS>, and <REALM> must
# be substituted before calling apm_config, eg. if these tags are
# defined in $pre_proc_map, they may be substituted with:
# array set apm_map [string map [subst $pre_proc_map] [array get apm_map]]
#
# Resource objects require the following meta-tags:
# <RESOURCE_TYPE> The apm resource object type, eg. "webtop"
# <RESOURCE_DEF>  The body of the object, eg.:
#     "customization-group <ITEM>
#      minimize-to-tray false
#      webtop-type full"
#
# In the above example, a customization-group is specified. Any
# customization-group is assumed to be blank unless further defined by the
# <GROUP_DEF> meta-tag, eg. <GROUP_DEF> {type webtop}
#
# Policy-item objects are defined by the following meta-tags:
# <AGENT_TYPE>   default "resource-assign"
# <AGENT_DEF>    default "customization-group <ITEM>"
# <ITEM_AGENT>   default "agents { <ITEM>_ag { type <AGENT_TYPE> }}"
# <ITEM_CAPTION> default "<ITEM>"
# <ITEM_COLOR>   default "1"
# <ITEM_TYPE>    default "action"
# <ITEM_RULES>   defaults to a set of expressions/next-items where specified
# <RULE_CAPTION_0> default "fallback"
# <RULE_CAPTION_1> default "Successful"
# <RULE_CAPTION_2> default "successful"
#
# apm_config generates the APM agent and customization-group definitions
# as required for each policy-item, but specific objects may be defined
# by using the <AGENT_DEF> and <GROUP_DEF> meta-tags.
# To suppress the formation of an APM agent, specify <ITEM_AGENT> {}.

proc iapp_apm_config { args } {

    set app_service ""
    array set flags  {
        -noapp       { [set app_service "app-service none\n   "] }
    }
    iapp_process_flags flags args

    upvar [lindex $args 0] map_array

    # Pull $prefix from the array
    set prefix $map_array(prefix)
    unset map_array(prefix)

    # Stencils for creating apm objects
    set access_form \
       "<TMSH_CREATE> apm policy access-policy <ITEM> {\n   \
          $app_service    caption general\n   \
          start-item <ACCESS_START_ITEM>\n   \
          default-ending <ACCESS_ENDING>\n   \
          items replace-all-with {\n<ACCESS_ITEMS>    }\n}"

    set profile_form "<TMSH_CREATE> <PROFILE_TYPE> <ITEM> {\n   \
        $app_service    <PROFILE_DEF>\n}"

    set resource_form "<TMSH_CREATE> apm resource <RESOURCE_TYPE> <ITEM> {\n   \
        $app_service    <RESOURCE_DEF>\n}"

    set agent_form "<TMSH_CREATE> apm policy agent <AGENT_TYPE> <ITEM>_ag {\n   \
        $app_service    <AGENT_DEF>\n}"

    set group_form "<TMSH_CREATE> apm policy customization-group <ITEM> {\
        $app_service    <GROUP_DEF>}"

    set agent_group_form "<TMSH_CREATE> apm policy customization-group <ITEM>_ag {\
        $app_service    <GROUP_DEF>}"

    set policy_item_form "<TMSH_CREATE> apm policy policy-item <ITEM> {
    $app_service    <ITEM_AGENT>caption <ITEM_CAPTION>
    color <ITEM_COLOR>
    <ITEM_TYPE>
    <ITEM_RULES>\n}"

    # 1st round apm string map
    set default_map_1 {
        <ACCESS_ITEM> {}
        <AGENT_DEF> "customization-group <ITEM>_ag"
        <ITEM_AGENT> "agents replace-all-with {
        <ITEM>_ag { type <AGENT_TYPE> }}\n    "
        <ITEM_CAPTION> <ITEM>
        <ITEM_COLOR> {1}
        <ITEM_TYPE> "item-type action"
        <ITEM_RULES> "rules
        {[expr {[string first <RULE_NEXT_2> $map_array($item)] != -1 ? "{
            caption <RULE_CAPTION_2>
            expression <RULE_EXPR_2>
            next-item ${prefix}_<RULE_NEXT_2>
        }":""}][expr {[string first <RULE_NEXT_1> $map_array($item)] != -1 ? "{
            caption <RULE_CAPTION_1>
            expression <RULE_EXPR_1>
            next-item ${prefix}_<RULE_NEXT_1>
        }":""}]{
            caption <RULE_CAPTION_0>
            next-item ${prefix}_<RULE_NEXT_0>
        }}"
    }

    # 2nd round apm string map
    set default_map_2 {
        <ITEM> [expr { $item eq {default} ? "$prefix" : "${prefix}_$item" }]
        <PREFIX> $prefix
        <LOCAL_PATH> [string map {/ :} $prefix]
        <GROUP_DEF> ""
        <AGENT_TYPE> "resource-assign"
        <RULE_CAPTION_2> "successful"
        <RULE_CAPTION_1> "Successful"
        <RULE_CAPTION_0> "fallback"
    }

    # Build APM access profile and access-policy from the access_form.
    # Tags <ACCESS_ITEM> and <ACCESS_ENDING> are picked up from
    # $map_array items. <ITEM> and <GROUP_DEF> are picked up from
    # $default_map_2.
    foreach item [lsort [array names map_array]] {

        # Pick up the <ACCESS_ENDING> tag. There should be just 1.
        set access_form [string map $map_array($item) $access_form]

        # Filter out items that do not belong in the access-policy.
        # Anything with an ITEM_xxx tag belongs
        if { [string first <ITEM_ $map_array($item)] == -1 } {
            continue
        }

        # Add to the items list for the access-policy, e.g. priority
        append access_items "        ${prefix}_$item {<ACCESS_ITEM>}\n"
        set access_items [string map $map_array($item) $access_items]
        set access_items [string map [subst $default_map_1] $access_items]
    }

    # Build APM resources, policy-items, agents, and customization-groups from
    # the policy_item_form and resource_form.
    foreach item [lsort [array names map_array]] {

        # Each item starts as a profile, a resource, or a policy-item.
        # Profiles are free-form, so other apm objects can use the profile form.
        # In most cases, a policy-item spawns an agent.
        # Any definition specifying a customization-group will spawn that group.
        if { [string first "<PROFILE_DEF>" $map_array($item)] != -1 } {

            # Collect profile names for attachment to the virtual server
            if { [string first "apm profile " $map_array($item)] != -1 } {
                lappend profiles [expr { $item eq {default}
                                 ? "$prefix" : "${prefix}_$item" }]
                # When an access profile is found, built a policy of the same name
                if { [string first "apm profile access" $map_array($item)] != -1 } {
                    set def [string map "<ACCESS_ITEMS> {$access_items}" $access_form]
                    append cmds "[string map [subst $default_map_2] $def]\n"
                }
            }
            set def $profile_form
        } elseif { [string first "<RESOURCE_DEF>" $map_array($item)] != -1 } {
            set def $resource_form
        } else {
            set def $policy_item_form
            if { [string first "<ITEM_AGENT> {}" $map_array($item)] == -1 } {
                append def $agent_form
            }
        }

        # Apply 1st pass of string maps
        set def [string map $map_array($item) $def]
        set def [string map [subst $default_map_1] $def]

        # If a customization-group is specified, add its definition
        if { [string first "customization-group" $def] != -1 } {
            if { [string first "apm policy agent" $def] != -1 } {
                append def $agent_group_form
            } elseif { [string first "apm profile access" $def] == -1 } {
                append def $group_form
            }
        }

        # Apply 2nd pass of string maps
        set def [string map $map_array($item) $def]
        append cmds [string map [subst $default_map_2] $def]
    }

    # Divide and execute tmsh commands
    set tag "<TMSH_CREATE>"
    set tag_length [string length $tag]
    set last [expr { [string first $tag $cmds] + $tag_length }]
    while { [set pos [string first $tag $cmds $last]] != -1 } {
        incr pos -1
        iapp_conf create [string range $cmds $last $pos]
        set last [expr { $pos + $tag_length + 1 }]
    }
    iapp_conf create [string range $cmds $last end]
    return $profiles
}

proc iapp_upgrade_template { upgrade_var upgrade_trans } {
    upvar $upgrade_var   upgrade_var_arr
    upvar $upgrade_trans upgrade_trans_arr

    # create the new variables from the old
    foreach { var } [array names upgrade_var_arr] {

        # substitute old variable name for abbreviation "##"
        regsub -all {##} $upgrade_var_arr($var) \$$var map_cmd

        # run the mapping command from inside the array
        if { [catch { subst $map_cmd } err] } {
            if { [string first "no such variable" $err] == -1 } {
                puts "ERROR $err"
            }
        }
    }

    # move variables over and apply translations
    set var_mods ""
    set var_adds ""
    foreach var [array names vx] {

        # if the APL variable name is in the translation array,
        # then use the custom translation built for that variable.
        if { [info exists upgrade_trans_arr($var)] } {
            array set sub_arr [subst $upgrade_trans_arr($var)]
            if { [info exists sub_arr($vx($var))] } {
                set vx($var) $sub_arr($vx($var))
            }
            array unset sub_arr
        # else, if the APL variable value is in the translation array,
        # then use the generic translation of that value.
        } elseif { [info exists upgrade_trans_arr($vx($var))] } {
            set vx($var) [subst $upgrade_trans_arr($vx($var))]
        }

        # add to tmsh command string
        if { [info exists ::$var] } {
            append var_mods "\n $var \{ value \"$vx($var)\" \} "
        } else {
            append var_adds "\n $var \{ value \"$vx($var)\" \} "
        }
    }

    # move tables over
    set tbl_mods ""
    set tbl_adds ""
    foreach tbl [array names tx] {

        # convert table from APL format to TMSH format
        if { ![llength $tx($tbl)] } {
            set tbl_def "column-names none"
        } else {
            set rows_def ""
            foreach apl_row $tx($tbl) {
                array set row_arr [join $apl_row]
                append rows_def "\n  \{ row \{ "
                foreach apl_col [array names row_arr] {
                    append rows_def "$row_arr($apl_col) "
                }
                append rows_def "\}\}"
            }
            set tbl_def \
            "\n  column-names \{ [array names row_arr] \} rows \{ $rows_def \}"
            array unset row_arr
        }

        # add to tmsh command string
        if { [info exists ::$tbl] } {
            append tbl_mods "\n $tbl \{ $tbl_def \} "
        } else {
            append tbl_adds "\n $tbl \{ $tbl_def \} "
        }
    }

    # construct the "tmsh modify" command
    set cmd "sys application service $tmsh::app_name "
    if { [llength $var_mods] } {
        append cmd "\nvariables modify { $var_mods }"
    }
    if { [llength $var_adds] } {
        append cmd "\nvariables add { $var_adds }"
    }
    if { [llength $tbl_mods] } {
        append cmd "\ntables modify { $tbl_mods }"
    }
    if { [llength $tbl_adds] } {
        append cmd "\ntables add { $tbl_adds }"
    }

    # Execute with debug output. This conversion takes place within the
    # existing ASO, so tmsh modify is used instead of tmsh create.
    iapp_debug "TEMPLATE UPGRADE"
    iapp_conf modify $cmd
    return
}

proc iapp_downgrade_template { pivot_var upgrade_var downgrade_table } {
    upvar $downgrade_table downgrade_tbl_arr

    # The ASO variable "offload_history" is used to recover the legacy
    # choice a user made about SSL offload. It should be present in all cases.
    # This conditional only handles the case where a user has deliberately
    # deleted it by manipulating the ASO directly from tmsh.
    if { ![info exists ::offload_history] } {
        set ::offload_history "No"
    }

    # BIG-IP erases table contents when the APL optional hides the table.
    # Since the prior data is not available, this downgrade must back-convert
    # existing table data. Unlike tables, variables remain intact from the
    # legacy ASO.
    set tbl_def ""
    foreach tbl [array names downgrade_tbl_arr] {
        # Check for existence of each table in the current context.
        # If not, skip to next.
        if { ![info exists [set tbl]] } {
            continue
        }
        # Check for existence of each table in the legacy context.
        # If not, add an empty table so "tmsh tables modify" does not fail.
        if { ![info exists ::$downgrade_tbl_arr($tbl)] } {
            iapp_conf modify sys app ser $tmsh::app_name tables add \{ $downgrade_tbl_arr($tbl) \}
        }
        append tbl_def "$downgrade_tbl_arr($tbl) \{ "
        if { [llength [subst $$tbl]] } {
            set rows_def ""
            foreach apl_row [subst $$tbl] {
                array set row_arr [join $apl_row]
                append rows_def "\n  \{ row \{ "
                foreach apl_col [array names row_arr] {
                    append rows_def "$row_arr($apl_col) "
                }
                append rows_def "\}\}"
            }
            append tbl_def \
            "column-names \{ [array names row_arr] \} rows \{ $rows_def \}"
            array unset row_arr
        } else {
            append tbl_def "rows none"
        }
        append tbl_def " \} "
    }
    regsub -all "\n" $tbl_def {} tbl_def
    set cmd "sys app ser $tmsh::app_name \
        variables modify \{ \
            $pivot_var \{ value $::offload_history \} \
            $upgrade_var \{ value No \} \
        \} \
        tables modify \{ $tbl_def \}"
    iapp_debug "TEMPLATE DOWNGRADE"
    iapp_conf modify $cmd
    return
}

proc iapp_get_ca_certs { args } {
    # Procedure formats and returns ca-bundle 509 certificates from ca-bundle.bak
    # (copy of tmos supplied ca-bundle.crt)
    # Returns backup files when using -files flag
    # Returns specified restore file certificates when using -restore -return flags
    # Returns specified restore file table certificates when using -restore -tablename
    # Returns selected certificates
    #
    # Set defaults. Flag actions may overwrite defaults later.
    set rest_files         0
    set do_restore         0
    set restore_return     0
    set restore_table_name 0
    set do_certs 0
    set user_get [iapp_get_user]
    set username [string range $user_get [expr {[string last user $user_get] +5 }] end-3 ]
    # Set up flag-based actions.
    array set flags  {
        -files     { [set rest_files 1] }
        -return    { [set do_restore 1] [set restore_return 1] }
        -tablename { [set do_restore 1] [set restore_table_name 1] }
        -certs     { [set do_certs 1] }
    }
    iapp_process_flags flags args
    set fn_ca_bundle "[lindex $args 0]"
    set cert_choices "[lindex $args 1]"
    set duplicate " "
    if { $rest_files eq 0 || $do_restore } {
        set fh_ca_bundle [open $fn_ca_bundle r]
        set ca_bundle_data [read $fh_ca_bundle]
        close $fh_ca_bundle
        set ca_bundle_split [split [string map "{-----END CERTIFICATE-----} \001" $ca_bundle_data] "\001"]
        set final ""
        # Grab Subject Name and Serial number from each certificate
        foreach subject $ca_bundle_split {
            if {$subject eq {}} {
                continue
            }
            set a [string first Subject: $subject]
            set b [string first \n $subject $a]
            set ab [string range $subject $a $b]
            set c [expr {[string first O= $ab] +2}]
            if { $c < 2 }{
                set c [expr {[string first CN= $ab] +2}]
            }
            set d [expr {[string first , $ab $c] -1}]
            # Deal with case were comma is not present after subject name
            if { $d < 0 }{
                set dc [string range $ab $c end-1]
            # Deal with case were text is not able to be located using common name, just grab the first 30 characters
            } elseif { $d > 2000 }{
                set dc [string range $ab $c 47]
            } else {
                set dc [string range $ab $c $d]
            }
            set f [expr {[string first Number: $subject] +7}]
            set g [expr {[string first Signature $subject $f] -1}]
            set fg [string range $subject $f $g]
            # Remove spaces and new line characters from serial number
            set fg_nospace [string map {" " "" "\n" "" ":" ""} $fg]
            set first_5 [string map {"(" ""} [string range $fg_nospace 0 4]]
            # -cert flag returns list of selected root certificates
            if { $do_certs }{
                foreach selection $cert_choices {
                    if { $first_5 eq $selection }{
                        # setup to remove duplicate root certificates - tmos supplied ca-bundle can have duplicates
                        set i 0
                        set duplicate_split [split [string map "{ } \001" $duplicate] "\001"]
                        foreach dup $duplicate_split {
                            if { $dup eq $first_5 }{
                                incr i
                            }
                        }
                        # add certificate if not a duplicate
                        if { $i < 1 }{
                            append final "${subject}-----END CERTIFICATE-----\n"
                            puts [tmsh::log notice "User:'${username}' Modified CA-Bundle, adding the following Root CA:(SN) ${fg_nospace} Name:${dc}"]
                            append duplicate "$first_5 "
                        }
                    }
                }
            } elseif { $dc !="" || $fg_nospace !="" || $restore_table_name eq 1 }{
                if { $restore_return eq 0 && $restore_table_name eq 0 }{
                    append final "${dc},SN:${fg_nospace}\t${first_5}\n"
                } elseif { $restore_table_name eq 1 }{
                    set table_cert [string first ### $subject]
                    if { $table_cert > -1 && $table_cert < 500 } {
                        set ending "$subject-----END CERTIFICATE-----"
                        set table_certificate [string range $ending [string first -----BEGIN $ending] [ expr { [string first -----END $ending] +24 }]]
                        append final  "{ row { \"[string map {"\n" " "} $table_certificate]\" \"[string range $subject 4 [expr { [string first \n $subject 1] -1 }]]\" } }"
                    }

                } else {
                    set table_cert [string first ### $subject]
                    if { $table_cert < 0 || $table_cert > 500 } {
                        append final "${first_5} "
                    }
                }
            }
        }
        if { $do_restore && $restore_table_name eq 0 }{
            set final [string map {"(" ""} $final]
        }
        return $final
    }
    if { $rest_files }{
        # Pull TMOS ca-bundle file into list
        catch { set fn_bak_ca_bundle [exec ls -t /config/ssl/ssl.crt/] } err
        if { $::errorCode != "" } {
            puts "Error during file lookup in ssl certificate directory: ${err}"
            error "Error during file lookup in ssl certificate directory: ${err}"
        }
        foreach bak [join "$fn_bak_ca_bundle"] {
            set full_path "/config/ssl/ssl.crt/$bak"
            if { [iapp_is full_path $fn_ca_bundle] }{
                set fn_bak_exists 1
                break
            } else {
                set fn_bak_exists 0
            }
        }
        if { $fn_bak_exists }{
            puts "Backup of factory TMOS ca-bundle /config/ssl/ssl.crt/ca-bundle.crt, at:${fn_ca_bundle}, already exists. No need to backup"
        } elseif { $fn_bak_exists eq 0 }{
            puts "Backing up factory TMOS ca-bundle /config/ssl/ssl.crt/ca-bundle.crt, to ${fn_ca_bundle}."
            catch { exec cp /config/ssl/ssl.crt/ca-bundle.crt ${fn_ca_bundle} } err
            if { $::errorCode != "" } {
                puts "Error creating backup file:${fn_ca_bundle}: ${err}"
                error "Error creating backup file:${fn_ca_bundle}: ${err}"
            }
        }
        set restore_list [lsearch -all -inline $fn_bak_ca_bundle *_bak*]
        set restore_final ""
        foreach res $restore_list {
            append restore_final "${res}\t${res}\n"
        }
        if { $restore_final == "" }{
            return "No restore files found"
        } else {
            return $restore_final
        }
    }
}
}


cli admin-partitions {
    update-partition Common
}
sys application template f5.analytics.v3.7.1rc2 {
    actions {
        definition {
            html-help {
            }
            implementation {
tmsh::include f5.iapp.1.5.3.cli
catch {iapp_template start}

# Read in an APL table even when some columns are empty or contain spaces:
#  table=name of table variable (like ::xx__tbl)
#  cols=list of column names, in desired order, like {name ip port}
# Returns a list of lists; each inner list is column values (no names) from
# one table row in the order specified.  Column values may be empty strings,
# like: {{hello "" "value with embedded spaces"} {goodbye "to all that" ""}}
proc scan_APL_table {table cols} {
 if {![info exists [set table]] || ![llength [set [set table]]]} { return [list] }

 set matrix [list]
 foreach {row} [set [set table]] {
  set rank [list]
  foreach {elem} [split [join $row] "\n"] {
   if {$elem eq ""} { continue }
   set n [set v ""]
   regexp {^\s*(\S+)\s*(.*)$} $elem junk n v
   lappend rank $n $v
  }
  set line [list]
  foreach {name} $cols {
   set val ""
   if {[set x [lsearch -exact $rank $name]] >= 0} {
    set val [lindex $rank [incr x]]
   }
   lappend line $val
  }
  lappend matrix $line
 }
 return $matrix
} ; #proc scan_APL_table


    proc fix_tmsh_esc {v} {
        if {([string range $v 0 0] eq {"}) && ([string range $v end end] eq {"})} {
            set v [string range $v 1 end-1]
        }
        set v [string map [list "\x5c\x5c" "_" "\x5c" "" "\x22" "_"] $v]
        return [regsub -all {[\x00-\x08\x0b\x0c\x0e-\x1f\xff]} $v {!}]
    } ; #fix_tmsh_esc

    proc get_obj_name {obj} {
        return [expr {[catch {eval tmsh::get_name {$obj}} v] ? "" : [fix_tmsh_esc $v]}]
    } ; #get_obj_name

    proc get_fld_value {obj field} {
        return [expr {[eval tmsh::get_field_value {$obj} {$field} v] ? [fix_tmsh_esc $v] : ""}]
    } ; #get_fld_value


    set ::time [clock seconds]
    if {![regexp {([1-9][0-9]*[.][0-9]+[.][0-9]+)[^.]*$} "f5.analytics.v3.7.1rc2" junk iappversion]} {
        set iappversion "3.7.1"
    }

    if {[catch {set ::app $::localmode__orginalapp}]}{set ::app [fix_tmsh_esc $tmsh::app_name]}
    catch {set ::localmode__uniqueid $::basic__uniqueid}
    if {[catch {set ::uniqueid $::localmode__uniqueid}]}{set ::uniqueid 1000}
    if {[catch {set ::intro__localmode $::intro__localmode}]}{set ::intro__localmode "No"}
    if {[catch {set ::basic__format $::basic__format}]}{set ::basic__format "Splunk"}
    if {[catch {set ::basic__appiqformat $::basic__appiqformat}]}{
        if {([tmsh::run_proc f5.app_utils:get_provisioned avr] eq "provisioned") &&
            ([tmsh::run_proc f5.app_utils:get_bigip_version_is_equal_or_later 13.0.0] eq "true") &&
            ($::basic__format eq "F5 Analytics")} {
            set ::basic__appiqformat "Yes"
        } else {
            set ::basic__appiqformat "No"
        }
    }


    if {[catch {set ::basic__stats $::basic__stats}]}{set ::basic__stats "No"}
    if {[catch {set ::basic__ihealth $::basic__ihealth}]}{set ::basic__ihealth "No"}
    if {[catch {set ::basic__logging $::basic__logging}]}{set ::basic__logging "No"}
    if {[catch {set ::basic__syslog $::basic__syslog}]}{set ::basic__syslog "No"}
    if {[catch {set ::basic__alerts $::basic__alerts}]}{set ::basic__alerts "No"}
    if {[catch {set ::basic__facility $::basic__facility}]}{set ::basic__facility ""}
    if {[catch {set ::basic__systemtenant $::basic__systemtenant}]}{set ::basic__systemtenant ""}
    if {[catch {set ::basic__hostnameoverride $::basic__hostnameoverride}]}{set ::basic__hostnameoverride ""}
    if {[catch {set ::basic__devicegroupoverride $::basic__devicegroupoverride}]}{set ::basic__devicegroupoverride ""}
    if {[catch {set ::basic__tenantdefault $::basic__tenantdefault}]}{set ::basic__tenantdefault ""}
    if {[catch {set ::basic__devicegroupoverride $::basic__devicegroupoverride}]}{set ::basic__devicegroupoverride ""}
    if {[catch {set ::basic__callbackurl $::basic__callbackurl}]}{set ::basic__callbackurl ""}
    if {[catch {set ::basic__callbacktype $::basic__callbacktype}]}{set ::basic__callbacktype "Use Management"}
    if {[catch {set ::basic__rbac $::basic__rbac}]}{set ::basic__rbac "No"}
    if {[catch {set ::basic__debug $::basic__debug}]}{set ::basic__debug "Yes"}

    if {[catch {set ::applicationmapping__mode $::applicationmapping__mode}]}{set ::applicationmapping__mode ""}
    if {[catch {set ::applicationmapping__irulesearch $::applicationmapping__irulesearch}]}{set ::applicationmapping__irulesearch "No"}
    if {[catch {set ::statistics__splunkdestinationip $::statistics__splunkdestinationip}]}{set ::statistics__splunkdestinationip ""}

    if {[catch {set ::statistics__pushstate $::statistics__pushstate}]}{set ::statistics__pushstate "Yes"}
    if {[catch {set ::statistics__pushtmstats $::statistics__pushtmstats}]}{set ::statistics__pushtmstats "Yes"}
    if {[catch {set ::statistics__pushistats $::statistics__pushistats}]}{set ::statistics__pushistats "Yes"}
    if {[catch {set ::statistics__pushsslistats $::statistics__pushsslistats}]}{set ::statistics__pushsslistats "No"}
    if {[catch {set ::statistics__pushavr $::statistics__pushavr}]}{set ::statistics__pushavr "Yes"}

    if {[catch {set ::statistics__pushsessiondb $::statistics__pushsessiondb}]}{set ::statistics__pushsessiondb "Yes"}

    set v12plus [expr {[tmsh::run_proc f5.app_utils:get_bigip_version_is_equal_or_later 12.0.0] eq "true"}]
    if {!$v12plus} { set ::statistics__pushsessiondb "No" }

    if {[catch {set ::statistics__pushconfig $::statistics__pushconfig}]}{set ::statistics__pushconfig "Yes"}
    if {$::basic__format eq "F5 BIG-IQ"} { set ::statistics__pushconfig "No" }
    if {[catch {set ::statistics__certexpiration $::statistics__certexpiration}]}{set ::statistics__certexpiration "Yes"}

    if {[catch {set ::statistics__customsessiondb $::statistics__customsessiondb}]}{set ::statistics__customsessiondb "No"}
    if {[catch {set ::statistics__customsessiondb1 $::statistics__customsessiondb1}]}{set ::statistics__customsessiondb1 ""}
    if {[catch {set ::statistics__customsessiondb2 $::statistics__customsessiondb2}]}{set ::statistics__customsessiondb2 ""}
    if {[catch {set ::statistics__customsessiondb3 $::statistics__customsessiondb3}]}{set ::statistics__customsessiondb3 ""}
    if {[catch {set ::statistics__customsessiondb4 $::statistics__customsessiondb4}]}{set ::statistics__customsessiondb4 ""}
    if {[catch {set ::statistics__customsessiondb5 $::statistics__customsessiondb5}]}{set ::statistics__customsessiondb5 ""}

    if {[catch {set ::statistics__randomstart $::statistics__randomstart}]}{set ::statistics__randomstart "No"}
    if {[catch {set ::statistics__customcollection $::statistics__customcollection}]}{set ::statistics__customcollection "No"}
    if {[catch {set ::statistics__customcollectionconfig $::statistics__customcollectionconfig}]}{set ::statistics__customcollectionconfig ""}

    if {[catch {set ::rbac__indexprefix $::rbac__indexprefix }]}{set ::rbac__indexprefix "Yes"}
    if {[catch {set ::rbac__indexprefixstring $::rbac__indexprefixstring }]}{set ::rbac__indexprefixstring "f5-"}
    if {[catch {set ::rbac__systemindex $::rbac__systemindex }]}{set ::rbac__systemindex "Use Default Tenant"}
    if {[catch {set ::rbac__systemindexstring $::rbac__systemindexstring }]}{set ::rbac__systemindexstring "system_stats"}
    if {[catch {set ::rbac__defaultindex $::rbac__defaultindex }]}{set ::rbac__defaultindex "Use Default Tenant"}
    if {[catch {set ::rbac__defaultindexstring $::rbac__defaultindexstring }]}{set ::rbac__defaultindexstring "unknown_stats"}
    if {[catch {set ::rbac__logindex $::rbac__logindex }]}{set ::rbac__logindex "Use Default Tenant"}
    if {[catch {set ::rbac__logindexstring $::rbac__logindexstring }]}{set ::rbac__logindexstring "events"}
    if {[catch {set ::rbac__sharedindex $::rbac__sharedindex }]}{set ::rbac__sharedindex "Use Default Tenant"}
    if {[catch {set ::rbac__sharedindexstring $::rbac__sharedindexstring }]}{set ::rbac__sharedindexstring "shared_stats"}


    if {[catch {set ::statistics__splunkdestinationhostheader $::statistics__splunkdestinationhostheader}]}{set ::statistics__splunkdestinationhostheader $::statistics__splunkdestinationip}
    if {$::statistics__splunkdestinationhostheader eq ""} {set ::statistics__splunkdestinationhostheader $::statistics__splunkdestinationip}


    if {[catch {set ::statistics__splunkdestinationprotocol $::statistics__splunkdestinationprotocol}]}{set ::statistics__splunkdestinationprotocol ""}
    if {[catch {set ::statistics__splunkdestinationport $::statistics__splunkdestinationport}]}{set ::statistics__splunkdestinationport ""}
    if {[catch {set ::statistics__splunkapikey $::statistics__splunkapikey}]}{set ::statistics__splunkapikey ""}
    if {[catch {set ::statistics__pushinterval $::statistics__pushinterval}]}{set ::statistics__pushinterval 60}
    if {[catch {set ::basic__avrinterval $::basic__avrinterval}]}{set ::basic__avrinterval "300"}

    if {[catch {set ::statistics__proxy $::statistics__proxy}]}{set ::statistics__proxy "No"}
    if {[catch {set ::statistics__proxyip $::statistics__proxyip}]}{set ::statistics__proxyip ""}
    if {[catch {set ::statistics__proxyport $::statistics__proxyport}]}{set ::statistics__proxyport ""}
    if {[catch {set ::statistics__proxyuser $::statistics__proxyuser}]}{set ::statistics__proxyuser ""}
    if {[catch {set ::statistics__proxypassword $::statistics__proxypassword}]}{set ::statistics__proxypassword ""}


    if {[catch {set ::ihealth__ihealthpassword $::ihealth__ihealthpassword}]}{set ::ihealth__ihealthpassword ""}
    if {[catch {set ::ihealth__ihealthuser $::ihealth__ihealthuser}]}{set ::ihealth__ihealthuser ""}
    if {[catch {set ::ihealth__schedule $::ihealth__schedule}]}{set ::ihealth__schedule ""}
    if {[catch {set ::ihealth__time $::ihealth__time}]}{set ::ihealth__time ""}
    if {[catch {set ::ihealth__endtime $::ihealth__endtime}]}{set ::ihealth__endtime ""}
    if {[catch {set ::ihealth__dayofweek $::ihealth__dayofweek}]}{set ::ihealth__dayofweek ""}
    if {[catch {set ::ihealth__dayofmonth $::ihealth__dayofmonth}]}{set ::ihealth__dayofmonth ""}

    if {[catch {set ::ihealth__proxy $::ihealth__proxy}]}{set ::ihealth__proxy "No"}
    if {$::ihealth__proxy eq "From Main Configuration"} {
        set ::ihealth__proxyip $::statistics__proxyip
        set ::ihealth__proxyport $::statistics__proxyport
        set ::ihealth__proxyuser $::statistics__proxyuser
        set ::ihealth__proxypassword $::statistics__proxypassword
    } else {
        if {[catch {set ::ihealth__proxyip $::ihealth__proxyip}]}{set ::ihealth__proxyip ""}
        if {[catch {set ::ihealth__proxyport $::ihealth__proxyport}]}{set ::ihealth__proxyport ""}
        if {[catch {set ::ihealth__proxyuser $::ihealth__proxyuser}]}{set ::ihealth__proxyuser ""}
        if {[catch {set ::ihealth__proxypassword $::ihealth__proxypassword}]}{set ::ihealth__proxypassword ""}
    }

    if {($::ihealth__ihealthpassword ne "") && ($::intro__localmode eq "No")} {
        #we do this up here b/c we want to error before we get started with deployment as well as we use the start var for the icall script set command below.
        regexp {(.*):(.*)} $::ihealth__time junk start_hour start_minute
        regexp {(.*):(.*)} $::ihealth__endtime junk end_hour end_minute

        set start_minute [expr {($start_hour * 60) + $start_minute}]
        set end_minute [expr {($end_hour * 60) + $end_minute}]

        if {($end_minute - $start_minute) < 120} {
            puts "You must specify a minimum of a two hour window for iHealth qkview transfers."
            error "You must specify a minimum of a two hour window for iHealth qkview transfers."
        }

        #pick a random time between the two numbers
        set start_random [expr {int(rand()*($end_minute-$start_minute+1)+$start_minute)}]

        set start_random [expr {$start_random / 60.00}]
        set start_random [split $start_random "."]
        set start_hour [lindex $start_random 0]
        set start_minute "0"
        catch {set start_minute [format %02d [expr {round("00.[lindex $start_random 1]" * 60)}]]}

        set ::ihealth__time "${start_hour}:${start_minute}"
    }

    set ::request_logging_string {category=\\"response_logging\\",virtual_name=\\"\$VIRTUAL_NAME\\",virtual_ip=\\"\$VIRTUAL_IP\\",virtual_port=\\"\$VIRTUAL_PORT\\",server_ip=\\"\$SERVER_IP\\",server_port=\\"\$SERVER_PORT\\",snat_ip=\\"\$SNAT_IP\\",client_ip=\\"\$CLIENT_IP\\",request=\\"\$HTTP_REQUEST\\",referer=\\"\$Referer\\",user_agent=\\"\${User-agent}\\",reponse_code=\\"\$HTTP_STATCODE\\",response_size=\\"\$RESPONSE_SIZE\\",latency=\\"\$RESPONSE_MSECS\\"}


    #RBAC var setup
    if {$basic__rbac eq "Yes"} {
        regsub -all "\\.| " $::basic__tenantdefault "_" tenantdefault_index
        set tenantdefault_index


        if {$::rbac__indexprefix eq "Yes"} {
            set rbac_prefix $::rbac__indexprefixstring
        } else {
            set rbac_prefix ""
        }

        if {$::rbac__systemindex eq "Use Default Tenant"} {
            set rbac_system_index ",\"index\":\"$rbac_prefix$tenantdefault_index\""
        } else {
            set rbac_system_index ",\"index\":\"$rbac_prefix$::rbac__systemindexstring\""
        }

        if {$::rbac__defaultindex eq "Use Default Tenant"} {
            set rbac_default_index ",\"index\":\"$rbac_prefix$tenantdefault_index\""
        } else {
            set rbac_default_index ",\"index\":\"$rbac_prefix$::rbac__defaultindexstring\""
        }

        if {$::rbac__logindex eq "Use Default Tenant"} {
            set rbac_log_index ",\"index\":\"$rbac_prefix$tenantdefault_index\""
            set rbac_log_index_irule ",\\\\\\\\\\\"index\\\\\\\\\\\":\\\\\\\\\\\"${rbac_prefix}${tenantdefault_index}\\\\\\\\\\\""
        } else {
            set rbac_log_index ",\"index\":\"$rbac_prefix$::rbac__logindexstring\""
            set rbac_log_index_irule ",\\\\\\\\\\\"index\\\\\\\\\\\":\\\\\\\\\\\"${rbac_prefix}${::rbac__logindexstring}\\\\\\\\\\\""
        }

        if {$::rbac__sharedindex eq "Use Default Tenant"} {
            set rbac_shared_index ",\"index\":\"$rbac_prefix$tenantdefault_index\""
        } else {
            set rbac_shared_index ",\"index\":\"$rbac_prefix$::rbac__sharedindexstring\""
        }

    } else {
        set rbac_prefix ""
        set rbac_system_index ""
        set rbac_default_index ""
        set rbac_log_index ""
        set rbac_shared_index ""
        set rbac_log_index_irule ""
    }

    regsub -all "\"" $rbac_prefix "\\\"" rbac_prefix_icall
    regsub -all "\"" $rbac_system_index "\\\"" rbac_system_index_icall
    regsub -all "\"" $rbac_default_index "\\\"" rbac_default_index_icall
    regsub -all "\"" $rbac_log_index "\\\"" rbac_log_index_icall
    regsub -all "\"" $rbac_shared_index "\\\"" rbac_shared_index_icall



    set deviceinfo ""
    set ::version ""
    catch {set deviceinfo [tmsh::show sys version]}
    regexp {.*Version\s*(\S*)\s*} $deviceinfo junk ::version

    #hostname override logic 114310721
    if {$::basic__hostnameoverride ne ""} {
        set hostname $::basic__hostnameoverride
        set hostnamemapping $::basic__hostnameoverride
    } else {
        if {![catch {tmsh::get_config sys global-settings hostname} deviceinfo]} {
            foreach {object} $deviceinfo {
                set hostname [get_fld_value $object "hostname"]
                break
            }
        } else {
            set hostname "unknown"
        }
        set hostnamemapping "\\\\\$static::tcl_platform(machine)"
    }


    set device_base_mac ""
    if {![catch {tmsh::get_status sys hardware} deviceinfo]} {
        foreach {object} $deviceinfo {
            set device_base_mac [get_fld_value $object "base-mac"]
            break
        }
    }
    if {$device_base_mac ne ""} {
        set parts [list]
        foreach {macpart} [split $device_base_mac ":"] {
            lappend parts [string range $macpart [expr {[string range $macpart 0 0] eq "0"}] end]
        }
        set device_base_mac [join $parts ":"]
    }


    set devicegroup $hostname
    #device group override logic and collection 114278039
    if {$basic__devicegroupoverride ne ""} {
        set devicegroup $basic__devicegroupoverride
    } elseif {![catch {tmsh::get_config cm device-group} deviceinfo]} {
        foreach {object} $deviceinfo {
            if {[get_fld_value $object "type"] eq "sync-failover"} {
                set devicegroup [get_obj_name $object]
                break
            }
        }
    }

    set devicegroup [string map [list "/Common/" ""] $devicegroup]

    switch -- $::basic__format {
        "Splunk" {
            set datareceiverurl "/services/collector/event"
            set datareceiverauth "Authorization: Splunk $::statistics__splunkapikey"
            set eventformat_start "\\\\\\\\\\\"event\\\\\\\\\\\":\\\\\\\\\{"
            set eventformat_end "\\\\\\\\\}"
            set bofdata ""
            set eofdata ""
            set bordata ""
            set eordata ""
        }
        "Sumo Logic" {
            set datareceiverurl "/receiver/v1/http/$::basic__systemtenant"
            set datareceiverauth ""
            set eventformat_start ""
            set eventformat_end ""
            set bofdata ""
            set eofdata ""
            set bordata ""
            set eordata ""
        }
        "F5 Analytics" {
            set datareceiverurl "/mgmt/ap/v1/tenants/$::basic__systemtenant/sources/$hostname/raw-data"
            set datareceiverauth "Postman-Token: $::statistics__splunkapikey"
            set eventformat_start ""
            set eventformat_end ""
            set bofdata "\\\\\\\\\["
            set eofdata "\\\\\\\\\]"
            set bordata ""
            set eordata ""
        }
        "F5 BIG-IQ" {
            set datareceiverurl "/mgmt/ap/v1/tenants/$::basic__systemtenant/sources/$hostname/raw-data"
            set datareceiverauth "Postman-Token: $::statistics__splunkapikey"
            set eventformat_start ""
            set eventformat_end ""
            set bofdata "\\\\\\\\\["
            set eofdata "\\\\\\\\\]"
            set bordata ""
            set eordata ""
        }
        "F5 Risk Engine" {
            set datareceiverurl "/"
            set datareceiverauth "HealthStats: $::statistics__splunkapikey"
            set eventformat_start ""
            set eventformat_end ""
            set bofdata "\\\\\\\\\["
            set eofdata "\\\\\\\\\]"
            set bordata ""
            set eordata ""
        }
        "F5 Risk Engine - Full" {
            set datareceiverurl "/"
            set datareceiverauth "HealthStats: $::statistics__splunkapikey"
            set eventformat_start ""
            set eventformat_end ""
            set bofdata "\\\\\\\\\["
            set eofdata "\\\\\\\\\]"
            set bordata ""
            set eordata ""
        }
    } ; #switch


    ########SplunkStats Script Start ########
    #yeah we could do some substr stuff here but to keep things simple we will do an append
    set tmp "\nset url \x22${::statistics__splunkdestinationprotocol}://${::statistics__splunkdestinationip}:${::statistics__splunkdestinationport}\x22\n"
    append tmp  "set devicegroupoverride \"$::basic__devicegroupoverride\"\n"
    append tmp  "set hostnameoverride \"${::basic__hostnameoverride}\"\n"
    append tmp  "set format \"${::basic__format}\"\n"
    append tmp  "set systemtenant \"${::basic__systemtenant}\"\n"
    append tmp  "set tenantdefault \"${::basic__tenantdefault}\"\n"
    append tmp  "set callbacktype \"${::basic__callbacktype}\"\n"
    append tmp  "set callbackurl \"${::basic__callbackurl}\"\n"
    append tmp  "set hostheader \"${::statistics__splunkdestinationhostheader}\"\n"
    append tmp  "set apikey \"${datareceiverauth}\"\n"
    append tmp  "set iappversion \"${iappversion}\"\n"
    append tmp  "set appname ${::app}\n"
    append tmp  "set facility \"${::basic__facility}\"\n"
    append tmp  "set irulesearch ${::applicationmapping__irulesearch}\n"
    append tmp  "set ihealthusername \"[regsub -all {[$\x22\x5b\x5c\x5d]} ${::ihealth__ihealthuser} {\\\\&}]\"\n"
    append tmp  "set ihealthpassword \"[regsub -all {[$\x22\x5b\x5c\x5d]} ${::ihealth__ihealthpassword} {\\\\&}]\"\n"
    append tmp  "set debug \"${::basic__debug}\"\n"

    append tmp  "set pushstate \"${::statistics__pushstate}\"\n"
    append tmp  "set pushtmstats \"${::statistics__pushtmstats}\"\n"
    append tmp  "set pushistats \"${::statistics__pushistats}\"\n"
    append tmp  "set pushsslistats \"${::statistics__pushsslistats}\"\n"
    append tmp  "set pushavr \"${::statistics__pushavr}\"\n"
    append tmp  "set pushsessiondb \"${::statistics__pushsessiondb}\"\n"
    append tmp  "set pushconfig \"${::statistics__pushconfig}\"\n"
    append tmp  "set certexpiration \"${::statistics__certexpiration}\"\n"
    append tmp  "set pushinterval \"${::statistics__pushinterval}\"\n"

    append tmp  "set rbac \"${::basic__rbac}\"\n"
    append tmp  "set rbac_prefix \"${rbac_prefix_icall}\"\n"
    append tmp  "set rbac_system_index \"${rbac_system_index_icall}\"\n"
    append tmp  "set rbac_default_index \"${rbac_default_index_icall}\"\n"
    append tmp  "set rbac_log_index \"${rbac_log_index_icall}\"\n"
    append tmp  "set rbac_shared_index \"${rbac_shared_index_icall}\"\n"

    append tmp  "set uniqueid \"${::uniqueid}\"\n"
    append tmp  "set customsessiondb \"${::statistics__customsessiondb}\"\n"
    append tmp  "set customsessiondb1 \"${::statistics__customsessiondb1}\"\n"
    append tmp  "set customsessiondb2 \"${::statistics__customsessiondb2}\"\n"
    append tmp  "set customsessiondb3 \"${::statistics__customsessiondb3}\"\n"
    append tmp  "set customsessiondb4 \"${::statistics__customsessiondb4}\"\n"
    append tmp  "set customsessiondb5 \"${::statistics__customsessiondb5}\"\n"

    set ::icall_splunkstats $tmp

    append ::icall_splunkstats {

        proc fix_tmsh_esc {v} {
            if {([string range $v 0 0] eq {"}) && ([string range $v end end] eq {"})} {
                set v [string range $v 1 end-1]
            }
            set v [string map [list "\x5c\x5c" "_" "\x5c" "" "\x22" "_"] $v]
            return [regsub -all {[\x00-\x08\x0b\x0c\x0e-\x1f\xff]} $v {!}]
        } ; #fix_tmsh_esc
    
        proc get_obj_name {obj} {
            return [expr {[catch {eval tmsh::get_name {$obj}} v] ? "" : [fix_tmsh_esc $v]}]
        } ; #get_obj_name
    
        proc get_fld_value {obj field} {
            return [expr {[eval tmsh::get_field_value {$obj} {$field} v] ? [fix_tmsh_esc $v] : ""}]
        } ; #get_fld_value


        # initialize a named array, from a source list if
        # it exists, otherwise to empty
        proc my_array_init {the_name the_src} {
			upvar $the_name name
			upvar $the_src src

            array unset name
            array set name [expr {([info exists src] && ([llength $src] > 1)) ?
									  $src : [list]}]
        } ; #my_array_init


        # if an array element exists, return its value else $dfl
        # (default $dfl is empty string)
        proc array_val {the_name {dfl ""}} {
			upvar $the_name name
            return [expr {[info exists name] ? $name : $dfl}]
        } ; #array_val


        # load contents of an internal data group into a list
        # (of {rowname rowdata} sublists).  Optionally sort list
        # by rownames
        proc load_dg {dgname {sort false}} {
            set tmp [list]
            if {![catch "tmsh::get_config \x22ltm data-group internal ${dgname}\x22" objs]} {
                foreach {obj} $objs {
                    if {[lsearch -exact [tmsh::get_field_names nested $obj] records] >= 0} {
                        if {[tmsh::get_field_value $obj records recs]} {
                            foreach {rec} $recs {
                                lappend tmp [list [get_obj_name $rec] [get_fld_value $rec data]]
                            }
                        }
                    }
                }
            }
            return [expr {$sort ? [lsort -dictionary -index 0 $tmp] : $tmp}]
        } ; #load_dg


        set date [clock seconds] ; #set a common epoch

        if {($pushstate eq "Yes") || ($pushavr eq "Yes")} {
            #set mysqlpw
            set mysqlpassword ""
            catch {set mysqlpassword [exec /usr/bin/perl -MPassCrypt -nle "print PassCrypt::decrypt_password(\$_)" /var/db/mysqlpw]}
        }

        if {[catch {tmsh::show sys version} sysversion]} { set sysversion "" }
        set ::version ""
        regexp {.*Version\s*(\S*)\s*} $sysversion junk ::version

        #hostname override logic 114310721
        if {$hostnameoverride ne ""} {
            set hostname $hostnameoverride
        } elseif {![catch {tmsh::get_config sys global-settings hostname} deviceinfo]} {
            foreach {object} $deviceinfo {
                set hostname [get_fld_value $object hostname]
                break
            }
        } else {
            set hostname "unknown"
        }

        set device_base_mac ""
        if {![catch {tmsh::get_status sys hardware} deviceinfo]} {
            foreach {object} $deviceinfo {
                set device_base_mac [get_fld_value $object "base-mac"]
                break
            }
        }
        if {$device_base_mac ne ""} {
            set parts [list]
            foreach {macpart} [split $device_base_mac ":"] {
                lappend parts [string range $macpart [expr {[string range $macpart 0 0] eq "0"}] end]
            }
            set device_base_mac [join $parts ":"]
        }

        switch -- $format {
            "Splunk" {
                set beginningdata ""
                set bofdata ""
                set eofdata ""
                set eventformat_start "\"event\":\{"
                set eventformat_end "\}"
                set url "${url}/services/collector/event"
                set bordata ""
                set eordata ""
            }
            "Sumo Logic" {
                set beginningdata ""
                set bofdata ""
                set eofdata ""
                set eventformat_start ""
                set eventformat_end ""
                set url "${url}/receiver/v1/http/$systemtenant"
                set bordata ""
                set eordata ""
            }
            "F5 Analytics" {
                set beginningdata ","
                set bofdata "\["
                set eofdata "\]"
                set eventformat_start ""
                set eventformat_end ""
                set configurl "${url}/mgmt/ap/v1/tenants/$systemtenant/sources/${hostname}/config-models"
                set url "${url}/mgmt/ap/v1/tenants/$systemtenant/sources/${hostname}/raw-data"
                set bordata ""
                set eordata ""
            }
            "F5 BIG-IQ" {
                set beginningdata ","
                set bofdata "\["
                set eofdata "\]"
                set eventformat_start ""
                set eventformat_end ""
                set url "${url}/mgmt/ap/v1/tenants/$systemtenant/sources/${hostname}/raw-data"
                set bordata ""
                set eordata ""
            }
            "F5 Risk Engine" {
                set beginningdata ","
                set bofdata "\["
                set eofdata "\]"
                set eventformat_start ""
                set eventformat_end ""
                set url "${url}/"
                set bordata ""
                set eordata ""
                #set bordata "\\\\\\\\\{\\\\\\\\\\\"body\\\\\\\\\\\":\\\\\\\\\\\""
                #set eordata "\\\\\\\\\\\"\\\\\\\\\}"
            }
            "F5 Risk Engine - Full" {
                set beginningdata ","
                set bofdata "\["
                set eofdata "\]"
                set eventformat_start ""
                set eventformat_end ""
                set url "${url}/"
                set bordata ""
                set eordata ""
                #set bordata "\\\\\\\\\{\\\\\\\\\\\"body\\\\\\\\\\\":\\\\\\\\\\\""
                #set eordata "\\\\\\\\\\\"\\\\\\\\\}"
            }
        }


        #load info from data group into associative array
        catch {array unset datagroup_array}
        array set datagroup_array [join [load_dg "/Common/${appname}-send_stats"]]

        #set the values from the data group (e.g., unpack into more arrays)

        my_array_init application_mapping datagroup_array(application_mapping)
        my_array_init avr_commands datagroup_array(avr_commands)
        my_array_init tmctl_commands datagroup_array(tmctl_commands)

        set source_metrics_to_ignore ""
        catch {set source_metrics_to_ignore $datagroup_array(source_metrics_to_ignore)}
        set sessiondbkeys ""
        catch {set sessiondbkeys $datagroup_array(sessiondbkeys)}

        array set vip2tenant {}
        array set vip2application {}
        array set vip2tier {}
        array set application2tenant {}
        array set tenantapplicationtier2tier {}

        array set wideip2tenant {}
        array set wideip2application {}
        array set wideip2tier {}


        #pull in AVR buckets and other settings
        array set lastpollsettings {}
        array set newpollsettings {}
        set max_avr_buckets 5
        set max_ihealth_attempts 20
        if {![catch {set fp [open "/shared/tmp/f5_analytics-${appname}-lastpollsettings" r]}]} {
                # we assume correct file format here
            while {[gets $fp data] >= 0} {
                foreach {key val} [split $data "|"] {
                    set lastpollsettings($key) $val
                    break
                }
            }
            close $fp
        }

        #lookup callback url 114439165
        if {$callbacktype eq "Use Management"} {
            set deviceinfo ""
            catch {set deviceinfo [tmsh::get_config sys management-ip]}
            foreach object $deviceinfo {
                set mgmtip ""
                catch {set mgmtip [get_obj_name $object]}
                if {$mgmtip ne ""} {
                    set mgmtip [split $mgmtip "/"]
                    set callbackurl "https://[lindex $mgmtip 0]"
                }
            }
        }

        set lastsentdate [array_val lastpollsettings(lastsentdate)]
        set aggr_period ""
        if {$lastsentdate ne ""} {
            set aggr_period [expr {$date - $lastsentdate}]
        }

        set docertcheck "No"
        if {$certexpiration eq "Yes"} {
            #Certificate Expiration Dates

            set lastcertcheck [array_val lastpollsettings(lastcertcheck) 0]
            set key "lastcertcheck"
            if {($date - $lastcertcheck) > 43200} {
                set docertcheck "Yes"
                set newpollsettings($key) $date
            } else {
                set newpollsettings($key) $lastcertcheck
            }

        }


        set doconfigpush "No"
        #Certificate Expiration Dates

        set lastconfigpush [array_val lastpollsettings(lastconfigpush) 0]

        #were there changes?
        set ltmconfigtime 0x7fffffff
        if {![catch {tmsh::get_config sys db ltm.configtime} deviceinfo]} {
            foreach {object} $deviceinfo {
                set ltmconfigtime [get_fld_value $object value]
                break
            }
        }

        set gtmconfigtime 0x7fffffff
        if {![catch {tmsh::get_config sys db gtm.configtime} deviceinfo]} {
            foreach {object} $deviceinfo {
                set gtmconfigtime [get_fld_value $object value]
                break
            }
        }

        set key "lastconfigpush"
        if {(($date - $lastconfigpush) > 43200) ||
                ($lastconfigpush < $gtmconfigtime) ||
                    ($lastconfigpush < $ltmconfigtime) ||
                        ($docertcheck eq "Yes")} {
            set doconfigpush "Yes"
            set newpollsettings($key) $date
        } else {
            set newpollsettings($key) $lastconfigpush
        }


        #because BIG-IQ collects the data we cant really set an aggr period as we won't know if they collected the file
        if {$format eq "F5 BIG-IQ"} {
            set aggr_period ""
        }

        #open the first file
        set stat_bytes_transfered 0
        set currentfile 0

        set stat_bytes_transfered_config 0
        set currentfile_config 0

        #BIG-IQ wants one file
        if {$format eq "F5 BIG-IQ"} {
            set maxfilesize 100000000
        } else {
            set maxfilesize 990000
        }

        set filename_config "/shared/tmp/${appname}-config_"

        if {$pushinterval < 11} {
            set filename "/shared/tmp/${appname}-stats-${date}_"
        } else {
            set filename "/shared/tmp/${appname}-stats_"
        }
        set infile [open "$filename$currentfile" "w" "0644"]
        if {$bofdata ne ""} {puts $infile $bofdata}
        set beginningdata_running ""

        if {($format eq "F5 Analytics") && ($doconfigpush eq "Yes")} {

            set infile_config [open "$filename_config$currentfile_config" "w" "0644"]
            set beginningdata_running ""
            puts $infile_config "\x7b\"tenantId\":\"$systemtenant\",\"sourceId\":\"$hostname\",\"vertices\":\x5b"
            set beginningdata_running_config ""

        }

        set devicegroup $hostname
        #device group override logic and collection 114278039
        if {$devicegroupoverride ne ""} {
            set devicegroup $devicegroupoverride
        } elseif {![catch {tmsh::get_config cm device-group} objs]} {
            foreach {obj} $objs {
                if {[get_fld_value $obj type] eq "sync-failover"} {
                    set devicegroup [get_obj_name $obj]
                    break
                }
            }
        }

        if {$pushstate eq "Yes"} {
            ###now let's get basic device status
            #need DSC info, need state of DSC am I active
            set deviceinfo_version ""
            set deviceinfo_location ""
            set deviceinfo_description ""
            set deviceinfo_marketing_name ""
            set deviceinfo_platform_id ""
            set deviceinfo_build ""
            set deviceinfo_failover_state ""
            set deviceinfo_chassis_id ""
            set deviceinfo_mode ""
            set deviceinfo_sync_status ""
            set deviceinfo_sync_summary ""
            set deviceinfo_sync_color ""

            set deviceinfo [tmsh::get_config sys global-settings hostname]
            foreach {object} $deviceinfo {
                set realhostname [get_fld_value $object hostname]
            }

            set deviceinfo ""
            catch {set deviceinfo [tmsh::get_status cm device $realhostname]}
            foreach object $deviceinfo {
                if {[get_obj_name $object] eq $hostname} {
                    set deviceinfo_version [get_fld_value $object "version"]
                    set deviceinfo_location [get_fld_value $object "location"]
                    set deviceinfo_description [get_fld_value $object "description"]
                    set deviceinfo_marketing_name [get_fld_value $object "marketing-name"]
                    set deviceinfo_platform_id [get_fld_value $object "platform-id"]
                    set deviceinfo_build [get_fld_value $object "build"]
                    set deviceinfo_failover_state [get_fld_value $object "failover-state"]
                    set deviceinfo_chassis_id [get_fld_value $object "chassis-id"]
                    break
                }
            }

            set deviceinfo ""
            catch {set deviceinfo [tmsh::get_status cm sync-status]}
            foreach object $deviceinfo {
                set deviceinfo_mode [get_fld_value $object "mode"]
                set deviceinfo_sync_status [get_fld_value $object "status"]
                set deviceinfo_sync_summary [get_fld_value $object "summary"]
                set deviceinfo_sync_color [get_fld_value $object "color"]
                break
            }

            #need service info, insync, apm, asm policies need to be applied?


            set last_asm_change ""
            set asm_state ""

            if {$mysqlpassword ne ""} {
                set mysql_command {select CASE WHEN max(event_time) IS NOT NULL THEN "Pending Policy Changes" ELSE "Policies Consistent" END as asm_state, max(event_time) as last_asm_change from PL_CONFIG_LOG where event_type <> 2 and element_type <> 18 and event_time > (select max(from_date) as asm_last_changed from PL_POLICY_VERSIONS)}
                if {![catch {set output [exec /usr/bin/mysql -uroot "-p${mysqlpassword}" PLC -B -e $mysql_command | /usr/bin/tr '\\t' ',']}]} {
                    #split the output into a list
                    set output [split $output "\n"]
                    set row_number 0
                    if {[llength $output] > 1} {
                        foreach outputline $output {
                            #skip the col name
                            if {$row_number > 0} {
                                set outputline [split $outputline ","]
                                set asm_state [lindex $outputline 0]
                                if {[lindex $outputline 1] ne "NULL"} {
                                    set last_asm_change [lindex $outputline 1]
                                }
                            }
                            incr row_number
                        }
                    }
                }
            }

            set apm_state ""
            if {![catch {exec /usr/bin/guishell -c "select max(config_sync_state) from profile_access_misc_stat;"} info]} {
                #info from guishell is not formatted conveniently
                set lines [split $info "\n"]
                regexp {([0-9]+)} [lindex $deviceinfo 5] junk tmp
                set apm_state [expr {(($tmp ne "") && ($tmp > 0)) ?
                                        "Pending Policy Changes" : "Policies Consistent"}]
            }

            set afm_state ""
            set last_afm_deploy ""
            if {![catch {tmsh::get_status security firewall current-state} deviceinfo]} {
                foreach {object} $deviceinfo {
                        set afm_state [get_fld_value $object "pccd-status"]
                        set last_afm_deploy [get_fld_value $object "rule-deploy-end-time-fmt"]
                }
            }


            set row "\"iapp_version\":\"$iappversion\",\"aggr_period\":\"$aggr_period\",\"device_base_mac\":\"$device_base_mac\",\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"version\":\"$deviceinfo_version\",\"location\":\"$deviceinfo_location\",\"callbackurl\":\"$callbackurl\",\"description\":\"$deviceinfo_description\",\"marketing-name\":\"$deviceinfo_marketing_name\",\"platform-id\":\"$deviceinfo_platform_id\",\"build\":\"$deviceinfo_build\",\"failover-state\":\"$deviceinfo_failover_state\",\"chassis-id\":\"$deviceinfo_chassis_id\",\"mode\":\"$deviceinfo_mode\",\"sync-status\":\"$deviceinfo_sync_status\",\"sync-summary\":\"$deviceinfo_sync_summary\",\"sync-color\":\"$deviceinfo_sync_color\",\"asm_state\":\"$asm_state\",\"last_asm_change\":\"$last_asm_change\",\"apm_state\":\"$apm_state\",\"afm_state\":\"$afm_state\",\"last_afm_deploy\":\"$last_afm_deploy\",\"ltm_config_time\":\"$ltmconfigtime\",\"gtm_config_time\":\"$gtmconfigtime\""
            puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_system_index,\"host\":\"$hostname\",\"source\":\"bigip.tmsh.system_status\",\"sourcetype\":\"f5:bigip:status:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
            set beginningdata_running $beginningdata
            if {[file size "$filename$currentfile"] > $maxfilesize} {
                #file too large create new
                incr stat_bytes_transfered [file size "$filename$currentfile"]
                incr currentfile
                if {$eofdata ne ""} {puts $infile $eofdata}
                close $infile
                set infile [open "$filename$currentfile" "w" "0644"]
                if {$bofdata ne ""} {puts $infile $bofdata}
                set beginningdata_running ""
            }


            ##interface state

            set interface_status ""
            if {![catch {tmsh::get_status net interface} deviceinfo]} {
                foreach {object} $deviceinfo {
                    set interface_name [get_obj_name $object]
                    set interface_status [get_fld_value $object "status"]
                    if {($interface_status ne "") && ($interface_name ne "")} {
                        set row "\"aggr_period\":\"$aggr_period\",\"device_base_mac\":\"$device_base_mac\",\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"interface_name\":\"$interface_name\",\"interface_status\":\"$interface_status\""
                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_system_index,\"host\":\"$hostname\",\"source\":\"bigip.tmsh.interface_status\",\"sourcetype\":\"f5:bigip:status:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                        set beginningdata_running $beginningdata
                        if {[file size "$filename$currentfile"] > $maxfilesize} {
                            #file too large create new
                            incr stat_bytes_transfered [file size "$filename$currentfile"]
                            incr currentfile
                            if {$eofdata ne ""} {puts $infile $eofdata}
                            close $infile
                            set infile [open "$filename$currentfile" "w" "0644"]
                            if {$bofdata ne ""} {puts $infile $bofdata}
                            set beginningdata_running ""
                        }
                    }
                }
            }


            ##disk storage usage
            set diskinfo ""
            catch {set diskinfo [exec /bin/df -P | /usr/bin/tr -s "\x20" ","]}
            set row_number 0
                if {[llength $diskinfo] > 1} {
                    foreach outputline $diskinfo {
                        if {$row_number == 0} {
                            #this has our columns lets store this info
                            set column_names [split $outputline ","]
                        } else {
                            #this is a row of data we need to split the row
                            set row "\"aggr_period\":\"$aggr_period\",\"device_base_mac\":\"$device_base_mac\",\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\","

                            set column_number 0
                            set columns [split $outputline ","]
                            foreach column $columns {
                                set metric_name [lindex $column_names $column_number]

                                #value processing
                                set value $column

                                if {![string is integer $value] || ($value eq "")} {
                                    set value "\"$value\""
                                }
                                append row "\"$metric_name\":$value,"
                                incr column_number
                            }
                            set row [string trimright $row ","]
                            puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_system_index,\"host\":\"$hostname\",\"source\":\"bigip.tmsh.disk_usage\",\"sourcetype\":\"f5:bigip:status:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                            set beginningdata_running $beginningdata
                            if {[file size "$filename$currentfile"] > $maxfilesize} {
                                #file too large create new
                                incr stat_bytes_transfered [file size "$filename$currentfile"]
                                incr currentfile
                                if {$eofdata ne ""} {puts $infile $eofdata}
                                close $infile
                                set infile [open "$filename$currentfile" "w" "0644"]
                                if {$bofdata ne ""} {puts $infile $bofdata}
                                set beginningdata_running ""
                            }
                        }
                        incr row_number
                    }

                }

            ##disk latency
            set diskinfo ""
            set lastoutputline ""
            set colrow 9999999
            catch {set diskinfo [exec /usr/bin/iostat -x -d -N | /usr/bin/tr -s " " ","]}
            set row_number 0
                if {[llength $diskinfo] > 1} {
                    foreach outputline $diskinfo {
                        if {$outputline contains "Device:"} {
                            set outputline [string map [list ":" ""] $outputline]
                            #this has our columns lets store this info
                            set column_names [split $outputline ","]
                            set colrow $row_number
                        }
                        if {($row_number > $colrow) && ($outputline contains ",")} {
                            #this is a row of data we need to split the row
                            set row "\"aggr_period\":\"$aggr_period\",\"device_base_mac\":\"$device_base_mac\",\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\","

                            #deal with split lines
                            if {!($lastoutputline contains ",")} {
                                set outputline $lastoutputline$outputline
                            }

                            set column_number 0
                            set columns [split $outputline ","]
                            foreach column $columns {
                                set metric_name [lindex $column_names $column_number]

                                #value processing
                                set value $column

                                if {![string is integer $value] || ($value eq "")} {
                                    set value "\"$value\""
                                }
                                append row "\"$metric_name\":$value,"
                                incr column_number
                            }
                            set row [string trimright $row ","]
                            puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_system_index,\"host\":\"$hostname\",\"source\":\"bigip.tmsh.disk_latency\",\"sourcetype\":\"f5:bigip:status:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                            set beginningdata_running $beginningdata
                            if {[file size "$filename$currentfile"] > $maxfilesize} {
                                #file too large create new
                                incr stat_bytes_transfered [file size "$filename$currentfile"]
                                incr currentfile
                                if {$eofdata ne ""} {puts $infile $eofdata}
                                close $infile
                                set infile [open "$filename$currentfile" "w" "0644"]
                                if {$bofdata ne ""} {puts $infile $bofdata}
                                set beginningdata_running ""
                            }
                        }
                        set lastoutputline $outputline
                        incr row_number
                    }

                }
        }


        #change to root for getting the rest of the data
        tmsh::cd /

        if {$pushconfig eq "Yes"} {
            ###now let's get the object model for ADC

            #pull in port number mappings 112280241
            array set service2port {}
            set fp [open "/etc/services" r]
            while {[gets $fp data] >= 0} {
                set service ""
                set port ""
                regexp {(\S*)\s*(\d*)} $data junk service port
                set service2port($service) $port
            }
            close $fp

            set irules ""
            set appiq_profiles ""
            set appiq_perrequestprofiles ""
            set appiq_urlfilters ""
            set appiq_apps ""
            set appiq_tenants ""
            set appiq_iapps ""
            set appiq_processedprofiles ""

            set virtual_id 0
            set virtual_list [tmsh::get_config ltm virtual recursive]
            foreach virtual $virtual_list {
                set virtualdata [lindex $virtual_list $virtual_id]
                set virtual_name [get_obj_name $virtual]

                regexp {(.*)/(.*)} $virtual_name junk partition virtual_name

                #softlanding
                set application ""
                set applicationdone ""
                set destination ""
                set mask ""
                set description ""
                set profiles ""
                set rules ""
                set appservice ""
                set perrequest ""
                set protocol ""
                set policies ""
                set pool ""
                set index $rbac_default_index
                set tenant $tenantdefault
                set tenantdone ""
                set wideip_name ""
                set partition "/$partition"
                set tier ""
                set tierdone ""
                set applicationdependencies ""
                set applicationdependenciesdone ""
                set appiqvirtual_outedges ""


                set destination [get_fld_value $virtualdata "destination"]
                set description [get_fld_value $virtualdata "description"]
                set appservice [get_fld_value $virtualdata "app-service"]
                set protocol [get_fld_value $virtualdata "ip-protocol"]
                set mask [get_fld_value $virtualdata "mask"]
                set policies [get_fld_value $virtualdata "policies"]
                set pool [get_fld_value $virtualdata "pool"]

                set destination [split $destination "/"]
                set destination_split [split [lindex $destination 1] ":"]
                if {[llength $destination_split] > 2} {
                    #IPv6 destination 112280165
                    set destination [split [lindex $destination 1] "."]
                    if {$mask eq ""} { set mask "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff" }
                } else {
                    set destination $destination_split
                }

                set ip [lindex $destination 0]
                set port [lindex $destination 1]

                if {![string is integer $port] && ($port ne "")} {
                    catch {set port $service2port($port)}
                }


                ###app mapping
                foreach key [lsort -dictionary [array names application_mapping]] {
                    set map [split $application_mapping($key) "~"]
                    set match ""; set m1 ""; set m2 ""; set m3 ""; set m4 ""; set m5 ""; set m6 ""; set m7 ""; set m8 ""; set m9 ""; set m10 ""; set m11 ""; set m12 ""
                    regexp [lindex $map 2] [set [lindex $map 1]] match m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 m11 m12
                    set data "$m1$m2$m3$m4$m5$m6$m7$m8$m9$m10$m11$m12"
                    set type [lindex $map 3]

                    if {([lindex $map 0] eq "Tenant Name") && ($tenantdone ne "yes")} {
                        if {($type eq "Map") && ($data ne "")} {
                            set tenant [lindex $map 5]$data
                            set tenantdone "yes"
                        }
                        if {($type eq "Append") && ($data ne "")} {
                            append tenant [lindex $map 5]$data
                        }
                        if {($type eq "Ignore") && ($match ne "")} {
                            set tenant "ignore"
                            set tenantdone "yes"
                        }
                        if {($type eq "Direct Mapping") && ($match ne "")} {
                            set tenant [lindex $map 4]
                            set tenantdone "yes"
                        }
                        if {($type eq "Direct Mapping Append") && ($match ne "")} {
                            set tenant [lindex $map 5][lindex $map 4]
                        }
                    }
                    if {([lindex $map 0] eq "App Name") && ($applicationdone ne "yes")} {
                        if {($type eq "Map") && ($data ne "")} {
                            set application [lindex $map 5]$data
                            set applicationdone "yes"
                        }
                        if {($type eq "Append") && ($data ne "")} {
                            append application [lindex $map 5]$data
                        }
                        if {($type eq "Ignore") && ($match ne "")} {
                            set application "ignore"
                            set applicationdone "yes"
                        }
                        if {($type eq "Direct Mapping") && ($match ne "")} {
                            set application [lindex $map 4]
                            set applicationdone "yes"
                        }
                        if {($type eq "Direct Mapping Append") && ($match ne "")} {
                            append application [lindex $map 5][lindex $map 4]
                        }
                    }
                    if {([lindex $map 0] eq "App Component Name") &&
                        ($tierdone ne "yes")} {
                        if {($type eq "Map") && ($data ne "")} {
                            set tier [lindex $map 5]$data
                            set tierdone "yes"
                        }
                        if {($type eq "Append") && ($data ne "")} {
                            append tier [lindex $map 5]$data
                        }
                        if {($type eq "Ignore") && ($match ne "")} {
                            set tier "ignore"
                            set tierdone "yes"
                        }
                        if {($type eq "Direct Mapping") && ($match ne "")} {
                            set tier [lindex $map 4]
                            set tierdone "yes"
                        }
                        if {($type eq "Direct Mapping Append") && ($match ne "")} {
                            append tier [lindex $map 5][lindex $map 4]
                        }
                    }
                    if {([lindex $map 0] eq "App Dependencies") &&
                        ($applicationdependenciesdone ne "yes")} {
                        if {($type eq "Map") && ($data ne "")} {
                            set applicationdependencies [lindex $map 5]$data
                            set applicationdependenciesdone "yes"
                        }
                        if {($type eq "Append") && ($data ne "")} {
                            append applicationdependencies [lindex $map 5]$data
                        }
                        if {($type eq "Ignore") && ($match ne "")} {
                            set applicationdependencies "ignore"
                            set applicationdependenciesdone "yes"
                        }
                        if {($type eq "Direct Mapping") && ($match ne "")} {
                            set applicationdependencies [lindex $map 4]
                            set applicationdependenciesdone "yes"
                        }
                        if {($type eq "Direct Mapping Append") && ($match ne "")} {
                            append applicationdependencies [lindex $map 5][lindex $map 4]
                        }
                    }

                }

                set virtual_name "$partition/$virtual_name"
                if {($tenantdone eq "yes") && ($rbac eq "Yes")} {
                    set index ",\"index\":\"$rbac_prefix$tenant\""
                }


                if {$format eq "F5 Analytics"} {
                    if {$doconfigpush eq "Yes"} {
                        ##APP-IQ Format

                        set appiqvirtual "\{\"kind\":\"ap:bigip:Virtual\",\"id\":\"$virtual_name\""

                        if {($tier ne "") || ($application ne "") ||
                                                        ($appservice ne "")} {
                            append appiqvirtual ",\"inEdges\":\["
                            if {$application ne ""} {
                                append appiqvirtual "\{\"sourceKind\":\"ap:common:App\",\"sourceId\":\"$application\"\},"
                            }
                            if {$appservice ne ""} {
                                append appiqvirtual "\{\"sourceKind\":\"ap:bigip:iApp\",\"sourceId\":\"$appservice\"\},"
                            }
                            if {$tier ne ""} {
                                append appiqvirtual "\{\"sourceKind\":\"ap:common:AppComponent\",\"sourceId\":\"$tenant-$application-$tier\"\},"
                            }
                            set appiqvirtual [string trimright $appiqvirtual ","]
                            append appiqvirtual "\]"

                        }
                        append appiqvirtual ",\"description\":\"$description\",\"ip\":\"$ip\",\"port\":\"$port\",\"protocol\":\"$protocol\",\"mask\":\"$mask\""

                        lappend appiq_apps $application
                        lappend appiq_tenants $tenant
                        lappend appiq_iapps $appservice
                        set application2tenant($application) $tenant
                        set tenantapplicationtier2tier($tenant-$application-$tier) $tier
                    }
                } else {
                    set row "\"devicegroup\":\"$devicegroup\",\"virtual_name\":\"$virtual_name\",\"description\":\"$description\",\"appComponent\":\"$tier\",\"iapp_name\":\"$appservice\",\"ip\":\"$ip\",\"port\":\"$port\",\"protocol\":\"$protocol\",\"app\":\"$application\",\"mask\":\"$mask\",\"tenant\":\"$tenant\",\"facility\":\"$facility\""
                    puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.virtual\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                    set beginningdata_running $beginningdata
                }


                #set the array lookup for stats
                set vip2tenant($virtual_name) $tenant
                set vip2application($virtual_name) $application
                set vip2tier($virtual_name) $tier


                if {($applicationdependencies ne "") && ($format ne "F5 Analytics")} {
                    set applicationdependencies [split $applicationdependencies ","]
                    foreach applicationdependency $applicationdependencies {
                        set applicationdependency [split $applicationdependency "|"]
                        switch [llength $applicationdependency] {
                            1   {
                                    set row "\"devicegroup\":\"$devicegroup\",\"tenant\":\"$tenant\",\"facility\":\"$facility\",\"virtual_name\":\"$virtual_name\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"dependency_type\":\"app\",\"dependency_tenant\":\"$tenant\",\"dependency_name\":\"[lindex $applicationdependency 0]\""
                                    puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.virtual.dependencies\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                    set beginningdata_running $beginningdata
                                 }
                            2    {
                                    if {[string tolower [lindex $applicationdependency 0]] eq "component"} {
                                        set row "\"devicegroup\":\"$devicegroup\",\"tenant\":\"$tenant\",\"facility\":\"$facility\",\"virtual_name\":\"$virtual_name\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"dependency_type\":\"appComponent\",\"dependency_tenant\":\"$tenant\",\"dependency_name\":\"[lindex $applicationdependency 1]\""
                                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.virtual.dependencies\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                        set beginningdata_running $beginningdata

                                    } else {
                                        set row "\"devicegroup\":\"$devicegroup\",\"tenant\":\"$tenant\",\"facility\":\"$facility\",\"virtual_name\":\"$virtual_name\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"dependency_type\":\"app\",\"dependency_tenant\":\"[lindex $applicationdependency 0]\",\"dependency_name\":\"[lindex $applicationdependency 1]\""
                                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.virtual.dependencies\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                        set beginningdata_running $beginningdata
                                    }
                                }
                        }
                    }
                }

                if {![tmsh::get_field_value $virtualdata "rules" rules]} {
                    set rules ""
                }
                if {$rules ne ""} {
                    set rules [split $rules " "]
                    foreach rule $rules {
                        if {$rule ne ""} {
                            set rule "/$rule"
                            lappend irules $rule

                            if {$format eq "F5 Analytics"} {
                                if {$doconfigpush eq "Yes"} {
                                    ##APP-IQ Format
                                    append  appiqvirtual_outedges "\{\"targetKind\":\"ap:bigip:iRule\",\"targetId\":\"$rule\"\},"
                                }
                            } else {
                                set row "\"devicegroup\":\"$devicegroup\",\"tenant\":\"$tenant\",\"appComponent\":\"$tier\",\"facility\":\"$facility\",\"app\":\"$application\",\"virtual_name\":\"$virtual_name\",\"rule_name\":\"$rule\""
                                puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.virtual.rules\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                set beginningdata_running $beginningdata
                            }


                        }

                    }
                }

                if {![tmsh::get_field_value $virtualdata "profiles" profiles]} {
                    set profiles [list]
                }
                foreach {profile} $profiles {
                    set profile_name "/[get_obj_name $profile]"

                    lappend appiq_profiles $profile_name

                    if {$format eq "F5 Analytics"} {
                        if {$doconfigpush eq "Yes"} {
                            ##APP-IQ Format
                            append appiqvirtual_outedges "\{\"targetKind\":\"ap:bigip:Profile\",\"targetId\":\"$profile_name\"\},"
                        }
                    } else {
                        set row "\"devicegroup\":\"$devicegroup\",\"tenant\":\"$tenant\",\"appComponent\":\"$tier\",\"facility\":\"$facility\",\"app\":\"$application\",\"virtual_name\":\"$virtual_name\",\"profile_name\":\"$profile_name\",\"profile_type\":\"profile\""
                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.virtual.profiles\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                        set beginningdata_running $beginningdata
                    }
                }


                if {[set perrequest [get_fld_value $virtualdata "per-flow-request-access-policy"]] ne ""} {
                    set perrequest "/$perrequest"

                    if {$format eq "F5 Analytics"} {
                        if {$doconfigpush eq "Yes"} {
                            ##APP-IQ Format
                            lappend appiq_perrequestprofiles $perrequest
                            append  appiqvirtual_outedges "\{\"targetKind\":\"ap:bigip:PerRequestProfile\",\"targetId\":\"$perrequest\"\},"
                        }
                    } else {
                        set row "\"devicegroup\":\"$devicegroup\",\"tenant\":\"$tenant\",\"appComponent\":\"$tier\",\"facility\":\"$facility\",\"app\":\"$application\",\"virtual_name\":\"$virtual_name\",\"profile_name\":\"$perrequest\",\"profile_type\":\"per_request\""
                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.virtual.profiles\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                        set beginningdata_running $beginningdata
                    }

                    #list policy objects list apm policy access-policy

                    set apmpolicy_list ""
                    catch {set apmpolicy_list [tmsh::get_config apm policy access-policy $perrequest]}
                    foreach policyline $apmpolicy_list {
                        if {![tmsh::get_field_value $policyline "items" items]} {
                            set items [list]
                        }
                        foreach item $items {
                            set item "/[lindex [split $item " "] 1]"
                            set policy_items ""
                            catch {set policy_items [tmsh::get_config apm policy policy-item $item]}
                            foreach policy_item $policy_items {
                                if {![tmsh::get_field_value $policy_item "agents" agents]} {
                                    set agents [list]
                                }
                                foreach agent $agents {
                                    if {[get_fld_value $agent "type"] eq "url-filter-lookup"} {
                                        set agent "/[get_obj_name $agent]"
                                        set urlfilters ""
                                        catch {set urlfilters [tmsh::get_config apm policy agent url-filter-lookup $agent]}
                                        foreach urlfilter $urlfilters {
                                            set urlfilter_name "/[get_fld_value $urlfilter "filter-name"]"
                                            if {$format eq "F5 Analytics"} {
                                                if {$doconfigpush eq "Yes"} {
                                                    ##APP-IQ Format
                                                    lappend appiq_urlfilters $urlfilter_name
                                                    append  appiqvirtual_outedges "\{\"targetKind\":\"ap:bigip:UrlFilter\",\"targetId\":\"$urlfilter_name\"\},"
                                                }
                                            } else {
                                                set row "\"devicegroup\":\"$devicegroup\",\"tenant\":\"$tenant\",\"appComponent\":\"$tier\",\"facility\":\"$facility\",\"app\":\"$application\",\"virtual_name\":\"$virtual_name\",\"profile_name\":\"$urlfilter_name\",\"profile_type\":\"url_filter\""
                                                puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.virtual.profiles\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                                set beginningdata_running $beginningdata
                                            }
                                        }

                                    }
                                }
                            }

                        }
                    }
                }

                if {$pool ne ""} {
                    set pool "/$pool"

                    if {$format eq "F5 Analytics"} {
                        if {$doconfigpush eq "Yes"} {
                            ##APP-IQ Format
                            append  appiqvirtual_outedges "\{\"targetKind\":\"ap:bigip:Pool\",\"targetId\":\"$pool\"\},"
                        }
                    } else {
                        set row "\"devicegroup\":\"$devicegroup\",\"tenant\":\"$tenant\",\"appComponent\":\"$tier\",\"facility\":\"$facility\",\"app\":\"$application\",\"virtual_name\":\"$virtual_name\",\"pool_name\":\"$pool\""
                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.virtual.pools\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                        set beginningdata_running $beginningdata
                    }

                }

                if {$format eq "F5 Analytics"} {
                    if {$doconfigpush eq "Yes"} {
                        ##APP-IQ Format
                        set appiqvirtual_outedges [string trimright $appiqvirtual_outedges ","]
                        if {$appiqvirtual_outedges ne ""} {
                            set appiqvirtual_outedges ",\"outEdges\":\[$appiqvirtual_outedges\]"
                        }

                        set appiqvirtual "$appiqvirtual$appiqvirtual_outedges\}"
                        puts $infile_config $beginningdata_running_config$appiqvirtual
                        set beginningdata_running_config $beginningdata
                    }
                } else {
                    if {[file size "$filename$currentfile"] > $maxfilesize} {
                        #file too large create new
                        incr stat_bytes_transfered [file size "$filename$currentfile"]
                        incr currentfile
                        if {$eofdata ne ""} {puts $infile $eofdata}
                        close $infile
                        set infile [open "$filename$currentfile" "w" "0644"]
                        if {$bofdata ne ""} {puts $infile $bofdata}
                        set beginningdata_running ""
                    }
                }


                incr virtual_id
            }


            #search irules for pools and responds
            set irules [lsort -unique $irules]
            if {$irulesearch eq "Yes"} {
                foreach rule $irules {
                    set iruleconfig ""
                    catch {set iruleconfig [tmsh::get_config ltm rule $rule]}
                    set iruleconfig [split $iruleconfig "\n"]

                    if {$format eq "F5 Analytics"} {
                        if {$doconfigpush eq "Yes"} {
                            ##APP-IQ Format
                            set appiqirule "\{\"kind\":\"ap:bigip:iRule\",\"id\":\"$rule\""
                            set appiqirule_outedges ""
                        }
                    }

                    foreach iruleconfigline $iruleconfig {
                        set pool ""
                        set context ""
                        set istat ""
                        regexp {[ |\t]+pool[ |\t]+(\S+)} $iruleconfigline junk pool
                        regexp {;#.*context: +["]([^"]*)"} $iruleconfigline junk context
                        regexp {;#.*istat: +["]([^"]*)"} $iruleconfigline junk istat




                        if {$pool ne ""} {
                            if {![string match "*/*" $pool]} {set pool "/Common/$pool"}

                            if {$format eq "F5 Analytics"} {
                                if {$doconfigpush eq "Yes"} {
                                    ##APP-IQ Format
                                    append  appiqirule_outedges "\{\"targetKind\":\"ap:bigip:Pool\",\"targetId\":\"$pool\",\"context\":\"$context\",\"istat_name\":\"$istat\"\},"
                                }
                            } else {
                                set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"rule_name\":\"$rule\",\"pool_name\":\"$pool\",\"context\":\"$context\",\"istat_name\":\"$istat\""
                                puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_shared_index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.rule.pools\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                set beginningdata_running $beginningdata
                            }


                        } else {
                            if {($iruleconfigline contains "::respond") &&
                                (($context ne "") || ($istat ne ""))} {
                                if {$format ne "F5 Analytics"} {
                                    set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"rule_name\":\"$rule\",\"context\":\"$context\",\"istat_name\":\"$istat\""
                                    puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_shared_index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.rule.respond\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                    set beginningdata_running $beginningdata
                                }
                            }
                        }

                    }

                    if {$format eq "F5 Analytics"} {
                        if {$doconfigpush eq "Yes"} {
                            ##APP-IQ Format
                            set appiqirule_outedges [string trimright $appiqirule_outedges ","]
                            if {$appiqirule_outedges ne ""} {
                                set appiqirule_outedges ",\"outEdges\":\[$appiqirule_outedges\]"
                            }

                            set appiqirule "$appiqirule$appiqirule_outedges\}"
                            puts $infile_config $beginningdata_running_config$appiqirule
                            set beginningdata_running_config $beginningdata
                        }
                    } else {

                        if {[file size "$filename$currentfile"] > $maxfilesize} {
                            #file too large create new
                            incr stat_bytes_transfered [file size "$filename$currentfile"]
                            incr currentfile
                            if {$eofdata ne ""} {puts $infile $eofdata}
                            close $infile
                            set infile [open "$filename$currentfile" "w" "0644"]
                            if {$bofdata ne ""} {puts $infile $bofdata}
                            set beginningdata_running ""
                        }
                    }
                }
            } else {
                if {($format eq "F5 Analytics") && ($doconfigpush eq "Yes")} {
                    ##APP-IQ Format
                    foreach rule $irules {
                        puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:bigip:iRule\",\"id\":\"$rule\"\}"
                        set beginningdata_running_config $beginningdata

                    }
                }
            }

            ###let's check the certs for expiration if we have been asked to

            if {$docertcheck eq "Yes"} {
                #Certificate Expiration Dates
                set clientprofile_list ""
                set certs ""
                catch {set clientprofile_list [tmsh::get_config ltm profile client-ssl recursive]}
                foreach clientprofile $clientprofile_list {
                    set profile_name "/[get_obj_name $clientprofile]"
                    set cert_name [get_fld_value $clientprofile "cert"]
                    if {$cert_name ne ""} {
                        set cert_name "/${cert_name}"
                        lappend certs $cert_name
                    }

                    if {$format eq "F5 Analytics"} {
                        if {$doconfigpush eq "Yes"} {
                            ##APP-IQ Format
                            puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:bigip:Profile\",\"id\":\"$profile_name\",\"outEdges\":\[\{\"targetKind\":\"ap:common:Cert\",\"targetId\":\"$cert_name\"\}\]\}"
                            set beginningdata_running_config $beginningdata
                            lappend appiq_processedprofiles $profile_name
                        }
                    } else {
                        set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"profile_name\":\"$profile_name\",\"profile_type\":\"client-ssl\",\"cert_name\":\"$cert_name\""
                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_shared_index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.profile\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                        set beginningdata_running $beginningdata

                        if {[file size "$filename$currentfile"] > $maxfilesize} {
                            #file too large create new
                            incr stat_bytes_transfered [file size "$filename$currentfile"]
                            incr currentfile
                            if {$eofdata ne ""} { puts $infile $eofdata }
                            close $infile
                            set infile [open "$filename$currentfile" "w" "0644"]
                            if {$bofdata ne ""} { puts $infile $bofdata }
                            set beginningdata_running ""
                        }
                    }
                }
                set certs [lsort -unique $certs]
                foreach cert $certs {
                    set certinfo ""
                    catch {set certinfo [tmsh::get_config sys file ssl-cert $cert]}
                    if {$certinfo eq ""} { continue }
                    set certdata [lindex $certinfo 0]
                    set cert_subject [get_fld_value $certdata "subject"]
                    set cert_expiration_date [get_fld_value $certdata "expiration-date"]

                    if {$format eq "F5 Analytics"} {
                        if {$doconfigpush eq "Yes"} {
                            ##APP-IQ Format
                            puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:common:Cert\",\"id\":\"$cert\",\"cert_subject\":\"$cert_subject\",\"cert_expiration_date\":\"$cert_expiration_date\"\}"
                            set beginningdata_running_config $beginningdata
                        }
                    } else {
                        set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"cert_name\":\"$cert\",\"cert_subject\":\"$cert_subject\",\"cert_expiration_date\":\"$cert_expiration_date\""
                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_shared_index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.cert\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                        set beginningdata_running $beginningdata

                        if {[file size "$filename$currentfile"] > $maxfilesize} {
                            #file too large create new
                            incr stat_bytes_transfered [file size "$filename$currentfile"]
                            incr currentfile
                            if {$eofdata ne ""} { puts $infile $eofdata }
                            close $infile
                            set infile [open "$filename$currentfile" "w" "0644"]
                            if {$bofdata ne ""} { puts $infile $bofdata }
                            set beginningdata_running ""
                        }
                    }
                }

            }


            ###now let's get GTM object model

            set irules ""
            set wideip_list ""
            catch {set wideip_list [tmsh::get_config gtm wideip recursive]}
            foreach {wideip} $wideip_list {
                set wideip_name [get_obj_name $wideip]

                regexp {(.*)/(.*)} $wideip_name junk partition wideip_name

                #softlanding
                set application ""
                set applicationdone ""
                set description ""
                set rules ""
                set appservice ""
                set pools ""
                set partition "/$partition"
                set aliases ""
                set lastresort ""
                set index $rbac_default_index
                set tenant $tenantdefault
                set tenantdone ""
                set virtual_name ""
                set tier ""
                set tierdone ""
                set applicationdependencies ""
                set applicationdependenciesdone ""
                set appiqwideip_outedges ""

                set description [get_fld_value $wideip "description"]
                set appservice [get_fld_value $wideip "app-service"]

                #NXT
                set wideip_type [lindex $wideip 2]

                ###app mapping
                foreach key [lsort -dictionary [array names application_mapping]] {
                    set map [split $application_mapping($key) "~"]
                    set match ""; set m1 ""; set m2 ""; set m3 ""; set m4 ""; set m5 ""; set m6 ""; set m7 ""; set m8 ""; set m9 ""; set m10 ""; set m11 ""; set m12 ""
                    regexp [lindex $map 2] [set [lindex $map 1]] match m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 m11 m12
                    set data "$m1$m2$m3$m4$m5$m6$m7$m8$m9$m10$m11$m12"
                    set type [lindex $map 3]

                     if {([lindex $map 0] eq "Tenant Name") && ($tenantdone ne "yes")} {
                        if {($type eq "Map") && ($data ne "")} {
                            set tenant [lindex $map 5]$data
                            set tenantdone "yes"
                        }
                        if {($type eq "Append") && ($data ne "")} {
                            append tenant [lindex $map 5]$data
                        }
                        if {($type eq "Ignore") && ($match ne "")} {
                            set tenant "ignore"
                            set tenantdone "yes"
                        }
                        if {($type eq "Direct Mapping") && ($match ne "")} {
                            set tenant [lindex $map 4]
                            set tenantdone "yes"
                        }
                        if {($type eq "Direct Mapping Append") && ($match ne "")} {
                            set tenant [lindex $map 5][lindex $map 4]
                        }
                    }
                    if {([lindex $map 0] eq "App Name") && ($applicationdone ne "yes")} {
                        if {($type eq "Map") && ($data ne "")} {
                            set application [lindex $map 5]$data
                            set applicationdone "yes"
                        }
                        if {($type eq "Append") && ($data ne "")} {
                            append application [lindex $map 5]$data
                        }
                        if {($type eq "Ignore") && ($match ne "")} {
                            set application "ignore"
                            set applicationdone "yes"
                        }
                        if {($type eq "Direct Mapping") && ($match ne "")} {
                            set application [lindex $map 4]
                            set applicationdone "yes"
                        }
                        if {($type eq "Direct Mapping Append") && ($match ne "")} {
                            append application [lindex $map 5][lindex $map 4]
                        }
                    }
                    if {([lindex $map 0] eq "App Component Name") &&
                        ($tierdone ne "yes")} {
                        if {($type eq "Map") && ($data ne "")} {
                            set tier [lindex $map 5]$data
                            set tierdone "yes"
                        }
                        if {($type eq "Append") && ($data ne "")} {
                            append tier [lindex $map 5]$data
                        }
                        if {($type eq "Ignore") && ($match ne "")} {
                            set tier "ignore"
                            set tierdone "yes"
                        }
                        if {($type eq "Direct Mapping") && ($match ne "")} {
                            set tier [lindex $map 4]
                            set tierdone "yes"
                        }
                        if {($type eq "Direct Mapping Append") && ($match ne "")} {
                            append tier [lindex $map 5][lindex $map 4]
                        }
                    }
                    if {([lindex $map 0] eq "App Dependencies") &&
                        ($applicationdependenciesdone ne "yes")} {
                        if {($type eq "Map") && ($data ne "")} {
                            set applicationdependencies [lindex $map 5]$data
                            set applicationdependenciesdone "yes"
                        }
                        if {($type eq "Append") && ($data ne "")} {
                            append applicationdependencies [lindex $map 5]$data
                        }
                        if {($type eq "Ignore") && ($match ne "")} {
                            set applicationdependencies "ignore"
                            set applicationdependenciesdone "yes"
                        }
                        if {($type eq "Direct Mapping") && ($match ne "")} {
                            set applicationdependencies [lindex $map 4]
                            set applicationdependenciesdone "yes"
                        }
                        if {($type eq "Direct Mapping Append") && ($match ne "")} {
                            append applicationdependencies [lindex $map 5][lindex $map 4]
                        }
                    }

                }
                set fqdn $wideip_name
                set wideip_name "${partition}/${wideip_name}"
                if {($tenantdone eq "yes") && ($rbac eq "Yes")} {
                    set index ",\"index\":\"$rbac_prefix$tenant\""
                }

                if {$format eq "F5 Analytics"} {
                    if {$doconfigpush eq "Yes"} {
                        ##APP-IQ Format

                        set appiqwideip "\{\"kind\":\"ap:bigip:WideIP-$wideip_type\",\"id\":\"$wideip_name\""

                        if {($tier ne "") ||
                                ($application ne "") ||
                                        ($appservice ne "")} {
                            append appiqwideip ",\"inEdges\":\["
                            if {$application ne ""} {
                                append appiqwideip "\{\"sourceKind\":\"ap:common:App\",\"sourceId\":\"$application\"\},"
                            }
                            if {$appservice ne ""} {
                                append appiqwideip "\{\"sourceKind\":\"ap:bigip:iApp\",\"sourceId\":\"$appservice\"\},"
                            }
                            if {$tier ne ""} {
                                append appiqwideip "\{\"sourceKind\":\"ap:common:AppComponent\",\"sourceId\":\"$tenant-$application-$tier\"\},"
                            }
                            set appiqwideip [string trimright $appiqwideip ","]
                            append appiqwideip "\]"

                        }
                        append appiqwideip ",\"description\":\"$description\",\"type\":\"$wideip_type\",\"fqdn\":\"$fqdn\",\"AppComponent\":\"$tier\""

                        append appiqwideip_outedges "\{\"targetKind\":\"ap:bigip:FQDN-$wideip_type\",\"targetId\":\"$fqdn\"\},"

                        puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:bigip:FQDN-$wideip_type\",\"id\":\"$fqdn\"\}"
                        set beginningdata_running_config $beginningdata


                        lappend appiq_apps $application
                        lappend appiq_tenants $tenant
                        lappend appiq_iapps $appservice
                        set application2tenant($application) $tenant
                        set tenantapplicationtier2tier($tenant-$application-$tier) $tier
                    }
                } else {

                    set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"wideip_name\":\"$wideip_name\",\"app\":\"$application\",\"description\":\"$description\",\"appComponent\":\"$tier\",\"iapp_name\":\"$appservice\",\"type\":\"$wideip_type\",\"fqdn\":\"$fqdn\",\"tenant\":\"$tenant\""
                    puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.wideip\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                    set beginningdata_running $beginningdata

                    set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"app\":\"$application\",\"tenant\":\"$tenant\",\"appComponent\":\"$tier\",\"wideip_name\":\"$wideip_name\",\"type\":\"$wideip_type\",\"fqdn\":\"$fqdn\",\"main\":\"1\""
                    puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.wideip.fqdns\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                    set beginningdata_running $beginningdata

                }

                set wideip2tenant($wideip_name) $tenant
                set wideip2application($wideip_name) $application
                set wideip2tier($wideip_name) $tier

                if {($applicationdependencies ne "") && ($format ne "F5 Analytics")} {
                    set applicationdependencies [split $applicationdependencies ","]
                    foreach applicationdependency $applicationdependencies {
                        set applicationdependency [split $applicationdependency "|"]
                        switch [llength $applicationdependency] {
                            1     {
                                    set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"wideip_name\":\"$wideip_name\",\"app\":\"$application\",\"description\":\"$description\",\"appComponent\":\"$tier\",\"type\":\"$wideip_type\",\"tenant\":\"$tenant\",\"dependency_type\":\"app\",\"dependency_tenant\":\"$tenant\",\"dependency_name\":\"[lindex $applicationdependency 0]\""
                                    puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.wideip.dependencies\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                    set beginningdata_running $beginningdata
                                }
                            2    {
                                    if {[string tolower [lindex $applicationdependency 0]] eq "component"} {
                                        set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"wideip_name\":\"$wideip_name\",\"app\":\"$application\",\"description\":\"$description\",\"appComponent\":\"$tier\",\"type\":\"$wideip_type\",\"tenant\":\"$tenant\",\"dependency_type\":\"appComponent\",\"dependency_tenant\":\"$tenant\",\"dependency_name\":\"[lindex $applicationdependency 0]\""
                                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.wideip.dependencies\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                        set beginningdata_running $beginningdata

                                    } else {
                                        set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"wideip_name\":\"$wideip_name\",\"app\":\"$application\",\"description\":\"$description\",\"appComponent\":\"$tier\",\"type\":\"$wideip_type\",\"tenant\":\"$tenant\",\"dependency_type\":\"app\",\"dependency_tenant\":\"[lindex $applicationdependency 0]\",\"dependency_name\":\"[lindex $applicationdependency 1]\""
                                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.wideip.dependencies\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                        set beginningdata_running $beginningdata
                                    }
                                }
                        }
                    }
                }

                if {![tmsh::get_field_value $wideip "rules" rules]} {
                    set rules ""
                }
                if {$rules ne ""} {
                    set rules [split $rules " "]
                    foreach rule $rules {
                        if {$rule ne ""} {
                            set rule "/$rule"
                            lappend irules $rule


                            if {$format eq "F5 Analytics"} {
                                if {$doconfigpush eq "Yes"} {
                                    ##APP-IQ Format
                                    append  appiqwideip_outedges "\{\"targetKind\":\"ap:bigip:GTMiRule\",\"targetId\":\"$rule\"\},"
                                }
                            } else {
                                set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"app\":\"$application\",\"tenant\":\"$tenant\",\"appComponent\":\"$tier\",\"wideip_name\":\"$wideip_name\",\"type\":\"$wideip_type\",\"gtmrule_name\":\"$rule\""
                                puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.wideip.gtmrules\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                set beginningdata_running $beginningdata
                            }
                        }

                    }

                }

                if {![tmsh::get_field_value $wideip "last-resort-pool" lastresort]} {
                    set lastresort ""
                }
                if {$lastresort ne ""} {
                #NXT
                    set pool_name [lindex $lastresort 1]

                    if {$format eq "F5 Analytics"} {
                        if {$doconfigpush eq "Yes"} {
                            ##APP-IQ Format
                            append  appiqwideip_outedges "\{\"targetKind\":\"ap:bigip:GTMPool-$wideip_type\",\"targetId\":\"$pool_name\",\"lastResort\":\"true\"\},"
                        }
                    } else {
                        set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"tenant\":\"$tenant\",\"wideip_name\":\"$wideip_name\",\"type\":\"$wideip_type\",\"gtmpool_name\":\"$pool_name\",\"pool_order\":\"1000000000\",\"last_resort\":\"1\""
                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.wideip.gtmpools\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                        set beginningdata_running $beginningdata
                    }
                }

                if {![tmsh::get_field_value $wideip "aliases" aliases]} {
                    set aliases ""
                }
                if {$aliases ne ""} {
                    set aliases [split $aliases " "]
                    foreach alias $aliases {
                        if {$alias ne ""} {

                            if {$format eq "F5 Analytics"} {
                                if {$doconfigpush eq "Yes"} {
                                    ##APP-IQ Format
                                    append appiqwideip_outedges "\{\"targetKind\":\"ap:bigip:FQDN-$wideip_type\",\"targetId\":\"$alias\"\},"
                                    puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:bigip:FQDN-$wideip_type\",\"id\":\"$alias\"\}"
                                    set beginningdata_running_config $beginningdata
                                }
                            } else {
                                set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"app\":\"$application\",\"tenant\":\"$tenant\",\"appComponent\":\"$tier\",\"wideip_name\":\"$wideip_name\",\"type\":\"$wideip_type\",\"fqdn\":\"$alias\",\"main\":\"0\""
                                puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.wideip.fqdns\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                set beginningdata_running $beginningdata
                            }
                        }

                    }

                }


                if {![tmsh::get_field_value $wideip "pools" pools]} {
                    set pools [list]
                }
                foreach {pool} $pools {
                    set pool_name "/[get_obj_name $pool]"
                    set order [get_fld_value $pool "order"]

                    if {$format eq "F5 Analytics"} {
                        if {$doconfigpush eq "Yes"} {
                            ##APP-IQ Format
                            append  appiqwideip_outedges "\{\"targetKind\":\"ap:bigip:GTMPool-$wideip_type\",\"targetId\":\"$pool_name\",\"pool_order\":\"$order\"\},"
                        }
                    } else {
                        set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"tenant\":\"$tenant\",\"wideip_name\":\"$wideip_name\",\"type\":\"$wideip_type\",\"gtmpool_name\":\"$pool_name\",\"pool_order\":\"$order\",\"last_resort\":\"0\""
                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.wideip.gtmpools\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                        set beginningdata_running $beginningdata
                    }
                }


                if {$format eq "F5 Analytics"} {
                    if {$doconfigpush eq "Yes"} {
                        ##APP-IQ Format
                        set appiqwideip_outedges [string trimright $appiqwideip_outedges ","]
                        if {$appiqwideip_outedges ne ""} {
                            set appiqwideip_outedges ",\"outEdges\":\[$appiqwideip_outedges\]"
                        }

                        set appiqwideip "$appiqwideip$appiqwideip_outedges\}"
                        puts $infile_config $beginningdata_running_config$appiqwideip
                        set beginningdata_running_config $beginningdata
                    }
                } else {
                    if {[file size "$filename$currentfile"] > $maxfilesize} {
                        #file too large create new
                        incr stat_bytes_transfered [file size "$filename$currentfile"]
                        incr currentfile
                        if {$eofdata ne ""} { puts $infile $eofdata }
                        close $infile
                        set infile [open "$filename$currentfile" "w" "0644"]
                        if {$bofdata ne ""} { puts $infile $bofdata }
                        set beginningdata_running ""
                    }
                }
            }

            #search irules for pools and responds
            set irules [lsort -unique $irules]
            if {$irulesearch eq "Yes"} {
                foreach rule $irules {
                    if {($format eq "F5 Analytics") && ($doconfigpush eq "Yes")} {
                        ##APP-IQ Format
                        set appiqirule "\{\"kind\":\"ap:bigip:GTMiRule\",\"id\":\"$rule\""
                        set appiqirule_outedges ""
                    }

                    set iruleconfig ""
                    catch {set iruleconfig [tmsh::get_config gtm rule $rule]}
                    set iruleconfig [split $iruleconfig "\n"]
                    foreach iruleconfigline $iruleconfig {
                        set pool ""
                        set context ""
                        set istat ""
                        regexp {[ |\t]+pool[ |\t]+(\S+)} $iruleconfigline junk pool
                        regexp {;#.*context: +["]([^"]*)"} $iruleconfigline junk context
                        regexp {;#.*istat: +["]([^"]*)"} $iruleconfigline junk istat
                        if {$pool ne ""} {

                            if {$format eq "F5 Analytics"} {
                                if {$doconfigpush eq "Yes"} {
                                    ##APP-IQ Format
                                    append  appiqirule_outedges "\{\"targetKind\":\"ap:bigip:GTMPool-ALL\",\"targetId\":\"$pool\",\"context\":\"$context\",\"istat_name\":\"$istat\"\},"
                                }
                            } else {
                                set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"gtmrule_name\":\"$rule\",\"gtmpool_name\":\"$pool\",\"context\":\"$context\",\"istat_name\":\"$istat\""
                                puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_shared_index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.gtmrule.gtmpools\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                set beginningdata_running $beginningdata
                            }
                        } else {
                            if {$format ne "F5 Analytics"} {
                                if {($iruleconfigline contains "::answer") &&
                                    (($context ne "") || ($istat ne ""))} {
                                    set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"gtmrule_name\":\"$rule\",\"context\":\"$context\",\"istat_name\":\"$istat\""
                                    puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_shared_index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.gtmrule.respond\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                                    set beginningdata_running $beginningdata
                                }
                            }
                        }

                    }


                    if {$format eq "F5 Analytics"} {
                        if {$doconfigpush eq "Yes"} {
                            ##APP-IQ Format
                            set appiqirule_outedges [string trimright $appiqirule_outedges ","]
                            if {$appiqirule_outedges ne ""} {
                                set appiqirule_outedges ",\"outEdges\":\[$appiqirule_outedges\]"
                            }

                            set appiqirule "$appiqirule$appiqirule_outedges\}"
                            puts $infile_config $beginningdata_running_config$appiqirule
                            set beginningdata_running_config $beginningdata
                        }
                    } else {
                        if {[file size "$filename$currentfile"] > $maxfilesize} {
                            #file too large create new
                            incr stat_bytes_transfered [file size "$filename$currentfile"]
                            incr currentfile
                            if {$eofdata ne ""} { puts $infile $eofdata }
                            close $infile
                            set infile [open "$filename$currentfile" "w" "0644"]
                            if {$bofdata ne ""} { puts $infile $bofdata }
                            set beginningdata_running ""
                        }
                    }
                }
            } else {
                if {($format eq "F5 Analytics") && ($doconfigpush eq "Yes")} {
                    ##APP-IQ Format
                    foreach rule $irules {
                        puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:bigip:GTMiRule\",\"id\":\"$rule\"\}"
                        set beginningdata_running_config $beginningdata

                    }
                }
            }

            ###let's get the pools
            set gtmpool_list [list]
            catch {set gtmpool_list [tmsh::get_config gtm pool recursive]}
            foreach {gtmpool} $gtmpool_list {
                set gtmpool_name [get_obj_name $gtmpool]
                set appiqgtmpool_outedges ""

                #softlanding
                if {![tmsh::get_field_value $gtmpool "members" members]} {
                    set members [list]
                }
                #NXT
                set pool_type [lindex $gtmpool 2]

                set gtmpool_name "/$gtmpool_name"
                if {($format eq "F5 Analytics") && ($doconfigpush eq "Yes")} {
                    ##APP-IQ Format
                    set appiqgtmpool "\{\"kind\":\"ap:bigip:GTMPool-$pool_type\",\"id\":\"$gtmpool_name\",\"type\":\"$pool_type\""
                }

                foreach {member} $members {
                    set order ""
                    set dsc_name ""
                    set virtual_name ""

                    set virtual [get_obj_name $member]
                    set order [get_fld_value $member "member-order"]
                    regexp {\/(.*):(.*)} $virtual junk dsc_name virtual_name

                    if {$format eq "F5 Analytics"} {
                        ##APP-IQ Format
                        append  appiqgtmpool_outedges "\{\"targetKind\":\"ap:bigip:Virtual\",\"targetId\":\"$virtual_name\",\"member_order\":\"$order\",\"DeviceGroup\":\"$dsc_name\"\},"
                    } else {
                        set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"gtmpool_name\":\"$gtmpool_name\",\"type\":\"$pool_type\",\"member_order\":\"$order\",\"virtual_devicegroup\":\"$dsc_name\",\"virtual_name\":\"$virtual_name\""
                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_shared_index,\"host\":\"$hostname\",\"source\":\"bigip.objectmodel.gtmpool\",\"sourcetype\":\"f5:bigip:config:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                        set beginningdata_running $beginningdata
                    }
                }



                if {$format eq "F5 Analytics"} {
                    if {$doconfigpush eq "Yes"} {
                        ##APP-IQ Format
                        set appiqgtmpool_outedges [string trimright $appiqgtmpool_outedges ","]
                        if {$appiqgtmpool_outedges ne ""} {
                            set appiqgtmpool_outedges ",\"outEdges\":\[$appiqgtmpool_outedges\]"
                        }
                        set appiqgtmpool "$appiqgtmpool$appiqgtmpool_outedges\}"
                        puts $infile_config $beginningdata_running_config$appiqgtmpool
                        set beginningdata_running_config $beginningdata
                    }
                } else {
                    if {[file size "$filename$currentfile"] > $maxfilesize} {
                        #file too large create new
                        incr stat_bytes_transfered [file size "$filename$currentfile"]
                        incr currentfile
                        if {$eofdata ne ""} { puts $infile $eofdata }
                        close $infile
                        set infile [open "$filename$currentfile" "w" "0644"]
                        if {$bofdata ne ""} { puts $infile $bofdata }
                        set beginningdata_running ""
                    }
                }
            }

            if {($format eq "F5 Analytics") && ($doconfigpush eq "Yes")} {
                ##APP-IQ Format

                set appiq_apps [lsort -unique $appiq_apps]
                set appiq_tenants [lsort -unique $appiq_tenants]
                set appiq_iapps [lsort -unique $appiq_iapps]

                set appiq_profiles [lsort -unique $appiq_profiles]
                set appiq_perrequestprofiles [lsort -unique $appiq_perrequestprofiles]
                set appiq_urlfilters [lsort -unique $appiq_urlfilters]
                set appiq_processedprofiles [lsort -unique $appiq_processedprofiles]


                foreach app $appiq_apps {
                    if {$app ne ""} {
                        set tenant ""
                        catch {set tenant $application2tenant($app)}
                        if {$tenant ne ""} {
                            puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:common:App\",\"id\":\"$app\",\"inEdges\":\[\{\"sourceKind\":\"ap:common:AppGroup\",\"sourceId\":\"$tenant\"\}\]\}"
                            set beginningdata_running_config $beginningdata

                        } else {
                            puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:common:App\",\"id\":\"$app\"\}"
                            set beginningdata_running_config $beginningdata

                        }
                    }
                }
                foreach tenant $appiq_tenants {
                    if {$tenant ne ""} {
                        puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:common:AppGroup\",\"id\":\"$tenant\",\"inEdges\":\[\{\"sourceKind\":\"ap:common:DeviceGroup\",\"sourceId\":\"$devicegroup\"\},\{\"sourceKind\":\"ap:device:BIG-IP\",\"sourceId\":\"$hostname\"\}\]\}"
                        set beginningdata_running_config $beginningdata

                    }
                    #add outedge
                    #add inedge
                }
                foreach iapp $appiq_iapps {
                    if {$iapp ne ""} {
                        puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:bigip:iApp\",\"id\":\"$iapp\"\}"
                        set beginningdata_running_config $beginningdata

                    }
                }
                foreach profile $appiq_perrequestprofiles {
                    puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:bigip:PerRequestProfile\",\"id\":\"$profile\"\}"
                    set beginningdata_running_config $beginningdata

                }
                foreach urlfilter $appiq_urlfilters {
                    puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:bigip:UrlFilter\",\"id\":\"$urlfilter\"\}"
                    set beginningdata_running_config $beginningdata

                }

                foreach profile $appiq_profiles {
                    if {[lsearch $appiq_processedprofiles $profile] == -1} {
                        puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:bigip:Profile\",\"id\":\"$profile\"\}"
                        set beginningdata_running_config $beginningdata

                    }
                }
                foreach {key value} [array get tenantapplicationtier2tier] {
                    if {$value ne ""} {
                        puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:common:AppComponent\",\"id\":\"$key\",\"name\":\"$value\"\}"
                        set beginningdata_running_config $beginningdata
                    }
                }

                puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:common:DeviceGroup\",\"id\":\"$devicegroup\"\}"
                set beginningdata_running_config $beginningdata

                puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:device:BIG-IP\",\"id\":\"$hostname\",\"inEdges\":\[\{\"sourceKind\":\"ap:common:DeviceGroup\",\"sourceId\":\"$devicegroup\"\}\]\}"
                set beginningdata_running_config $beginningdata
            }
        }


        if {$pushtmstats eq "Yes"} {
            ###let's get data from TMStats

            foreach {tmcl_command key_column_number} [array get tmctl_commands] {
                if {$tmcl_command ne ""} {
                    set column_names {}
                    if {![catch {set output [exec /usr/bin/tmctl $tmcl_command -c]}]} {
                        #split the output into a list
                        regsub -all "\{\n" $output "" output ;#fix for awk process spitting out a new line in the tmstats table, seems to be 11.5.3 related bug
                        set output [split $output "\n"]
                        set row_number 0
                        if {[llength $output] > 1} {
                            foreach outputline $output {
                                if {$row_number == 0} {
                                    #this has our columns lets store this info
                                    set column_names [split $outputline ","]
                                } else {
                                    set ignore 0
                                    #this is a row of data we need to split the row
                                    set column_number 0
                                    set columns [split $outputline ","]
                                    set row ""


                                    #assign tenant, application, and tier
                                    set application ""
                                    set tier ""
                                    set tenant $tenantdefault
                                    set index ""
                                    if {$key_column_number >= 0} {
                                        set index $rbac_default_index
                                        catch {set application $vip2application([lindex $columns $key_column_number])}
                                        catch {set tier $vip2tier([lindex $columns $key_column_number])}
                                        catch {set tenant $vip2tenant([lindex $columns $key_column_number])}
                                        if {$rbac eq "Yes"} {
                                            catch {set index ",\"index\":\"$rbac_prefix$vip2tenant([lindex $columns $key_column_number])\""}
                                            regsub -all "\\.| " $index "_" index
                                        }
                                    }
                                    if {$key_column_number eq "-1"} {
                                        set index $rbac_system_index
                                    }
                                    if {$key_column_number eq "-2"} {
                                        set index $rbac_shared_index
                                    }


                                    #if we don't ignore this row

                                    if {$ignore != 1} {
                                        foreach column $columns {
                                            set metric_name [lindex $column_names $column_number]
                                            regsub -all " |\\.|/" $metric_name "_" metric_name

                                            #value processing
                                            set value $column

                                            if {($metric_name eq "ip_address") &&
                                                ($tmcl_command eq "monitor_instance_stat")} {
                                                set value [string map [list "::ffff:" ""] $value]
                                            }

                                            #IP HEX Mapping
                                            if {$metric_name eq "addr"} {
                                                set hexroutedomain ""
                                                set hexip ""
                                                set hexip_1 ""
                                                set hexip_2 ""
                                                set hexip_3 ""
                                                set hexip_4 ""
                                                set hexipv6_1 ""
                                                set hexipv6_2 ""
                                                set hexipv6_3 ""
                                                set hexipv6_4 ""
                                                set hexipv6_5 ""
                                                set hexipv6_6 ""
                                                set hexipv6_7 ""
                                                set hexipv6_8 ""

                                                set value [string map [list ":" ""] $value]

                                                regexp {([[:xdigit:]]{32})([[:xdigit:]]{8})} $value junk hexip hexroutedomain
                                                regexp {FFFF([[:xdigit:]].)([[:xdigit:]].)([[:xdigit:]].)([[:xdigit:]].)} $hexip junk hexip_1 hexip_2 hexip_3 hexip_4

                                                if {$hexip_1 ne ""} {
                                                    set value "[expr 0x$hexip_1].[expr 0x$hexip_2].[expr 0x$hexip_3].[expr 0x$hexip_4]"
                                                } else {
                                                    regexp {([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})} $hexip junk hexipv6_1 hexipv6_2 hexipv6_3 hexipv6_4 hexipv6_5 hexipv6_6 hexipv6_7 hexipv6_8
                                                    set value "$hexipv6_1:$hexipv6_2:$hexipv6_3:$hexipv6_4:$hexipv6_5:$hexipv6_6:$hexipv6_7:$hexipv6_8"
                                                }
                                            }

                                            if {![string is integer $value] || ($value eq "")} {
                                                set value "\"$value\""
                                            }


                                            #should we ignore this stat/key?
                                            set metric_match $tmcl_command.[lindex $column_names $column_number]
                                            if {[lsearch $source_metrics_to_ignore $metric_match] == -1} {
                                                append row "\"$metric_name\":$value,"
                                            }
                                            incr column_number
                                        }
                                        set row [string trimright $row ","]
                                        if {$row ne ""} {
                                            puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.tmstats.$tmcl_command\",\"sourcetype\":\"f5:bigip:stats:iapp:json\",$eventformat_start\"device_base_mac\":\"$device_base_mac\",\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"tenant\":\"$tenant\",\"aggr_period\":\"$aggr_period\",$row$eventformat_end\}$eordata"
                                            set beginningdata_running $beginningdata
                                            if {[file size "$filename$currentfile"] > $maxfilesize} {
                                                #file too large create new
                                                incr stat_bytes_transfered [file size "$filename$currentfile"]
                                                incr currentfile
                                                if {$eofdata ne ""} { puts $infile $eofdata }
                                                close $infile
                                                set infile [open "$filename$currentfile" "w" "0644"]
                                                if {$bofdata ne ""} { puts $infile $bofdata }
                                                set beginningdata_running ""
                                            }
                                        }
                                    }

                                }
                                incr row_number
                            }
                        }
                    }
                }
            }
        }

        if {$pushavr eq "Yes"} {
            ###now let's get data from AVR
            if {$mysqlpassword ne ""} {
                foreach {avr_table_info avr_command} [array get avr_commands] {
                    if {$avr_command ne ""} {
                        set avr_table_info [split $avr_table_info "|"]
                        set key_column_number [lindex $avr_table_info 1]
                        set avr_table [lindex $avr_table_info 0]
                        set column_names {}

                        set lastsentbuckets ""
                        set key "${avr_table}_sentbuckets"
                        catch {set lastsentbuckets $lastpollsettings($key)}
                        set lastsentbuckets [split $lastsentbuckets ","]


                        set newlastsentbuckets ""
                        set tosendbuckets ""
                        set tosendbuckets_count 0

                        set avr_command_buckets "select distinct time_stamp from ${avr_table}_T where time_stamp < (select UNIX_TIMESTAMP(now())-(aggr_period+1) from ${avr_table}_T order by time_stamp DESC limit 1 )  order by time_stamp DESC"

                        if {![catch {set output [exec /usr/bin/mysql -uroot "-p${mysqlpassword}" AVR -B -e $avr_command_buckets | /usr/bin/tr '\\t' ',']}]} {
                            #split the output into a list
                            set output [split $output "\n"]
                            set row_number 0
                            if {[llength $output] > 0} {
                                foreach outputline $output {
                                    #skip the col name and the current working bucket
                                    if {$row_number > 0} {
                                        if {([lsearch $lastsentbuckets $outputline] == -1) &&
                                            ($tosendbuckets_count <= $max_avr_buckets)} {
                                            incr tosendbuckets_count
                                            append tosendbuckets "$outputline,"
                                            append newlastsentbuckets "$outputline,"
                                        }
                                        if {[lsearch $lastsentbuckets $outputline] > -1} {
                                            append newlastsentbuckets "$outputline,"
                                        }
                                    }
                                    incr row_number
                                }
                            }

                            set newlastsentbuckets [string trimright $newlastsentbuckets ","]
                            set key "${avr_table}_sentbuckets"
                            set newpollsettings($key) $newlastsentbuckets

                            set tosendbuckets [string trimright $tosendbuckets ","]

                        }

                        if {$tosendbuckets ne ""} {
                            #update the command to use the to send buckets
                            set map "<tosendbuckets> $tosendbuckets"
                            set avr_command [string map $map $avr_command]


                            if {![catch {set output [exec /usr/bin/mysql -uroot "-p${mysqlpassword}" AVR -B -e $avr_command | /usr/bin/tr '\\t' ',']}]} {
                                #split the output into a list
                                set output [split $output "\n"]
                                set row_number 0
                                if {[llength $output] > 1} {
                                    foreach outputline $output {
                                        if {$row_number == 0} {
                                            #this has our columns lets store this info
                                            set column_names [split $outputline ","]
                                        } else {
                                            set ignore 0
                                            #this is a row of data we need to split the row
                                            set column_number 0
                                            set columns [split $outputline ","]
                                            set row ""


                                            #assign tenant, application, and tier
                                            set application ""
                                            set tier ""
                                            set tenant $tenantdefault
                                            set index ""
                                            if {$key_column_number >= 0} {
                                                set index $rbac_default_index
                                                catch {set application $vip2application([lindex $columns $key_column_number])}
                                                catch {set tier $vip2tier([lindex $columns $key_column_number])}
                                                catch {set tenant $vip2tenant([lindex $columns $key_column_number])}
                                                if {$rbac eq "Yes"} {
                                                    catch {set index ",\"index\":\"$rbac_prefix$vip2tenant([lindex $columns $key_column_number])\""}
                                                    regsub -all "\\.| " $index "_" index
                                                }
                                            }
                                            if {$key_column_number eq "-1"} {
                                                set index $rbac_system_index
                                            }
                                            if {$key_column_number eq "-2"} {
                                                set index $rbac_shared_index
                                            }


                                            if {$ignore != 1} {
                                                foreach column $columns {
                                                    set metric_name [lindex $column_names $column_number]
                                                    regsub -all " |\\.|/" $metric_name "_" metric_name
                                                    #value processing
                                                    set value $column

                                                    #IP HEX Mapping
                                                    set mtrc_names [list "source_ip" "dest_ip" "pool_member_addr" "client_ip" "self_ip" "server_ip" "subnet_addr" "remote_host_ip" "subnet"]
                                                    if {[lsearch -exact $mtrc_names $metric_name] >= 0} {
                                                        set hexroutedomain ""
                                                        set hexip ""
                                                        set hexip_1 ""
                                                        set hexip_2 ""
                                                        set hexip_3 ""
                                                        set hexip_4 ""
                                                        set hexipv6_1 ""
                                                        set hexipv6_2 ""
                                                        set hexipv6_3 ""
                                                        set hexipv6_4 ""
                                                        set hexipv6_5 ""
                                                        set hexipv6_6 ""
                                                        set hexipv6_7 ""
                                                        set hexipv6_8 ""

                                                        regexp {([[:xdigit:]]{32})([[:xdigit:]]{8})} $value junk hexip hexroutedomain
                                                        regexp {FFFF([[:xdigit:]].)([[:xdigit:]].)([[:xdigit:]].)([[:xdigit:]].)} $hexip junk hexip_1 hexip_2 hexip_3 hexip_4

                                                        if {$hexip_1 ne ""} {
                                                            set value "[expr 0x$hexip_1].[expr 0x$hexip_2].[expr 0x$hexip_3].[expr 0x$hexip_4]"
                                                        } else {
                                                            regexp {([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})} $hexip junk hexipv6_1 hexipv6_2 hexipv6_3 hexipv6_4 hexipv6_5 hexipv6_6 hexipv6_7 hexipv6_8
                                                            set value "$hexipv6_1:$hexipv6_2:$hexipv6_3:$hexipv6_4:$hexipv6_5:$hexipv6_6:$hexipv6_7:$hexipv6_8"
                                                        }
                                                    }


                                                    if {![string is integer $value] || ($value eq "")} {
                                                        set value "\"$value\""
                                                    }
                                                    if {$value eq "\"\NULL\""} {
                                                        set value "\"\""
                                                    }

                                                    if {$metric_name eq "time_stamp"} {
                                                        set avrtime $value
                                                    } else {
                                                        append row "\"$metric_name\":$value,"
                                                    }

                                                    incr column_number
                                                }
                                                set row [string trimright $row ","]
                                                if {$row ne ""} {
                                                    puts $infile "$beginningdata_running$bordata\{\"time\":$avrtime$index,\"host\":\"$hostname\",\"source\":\"bigip.avrstats.$avr_table\",\"sourcetype\":\"f5:bigip:stats:iapp:json\",$eventformat_start\"device_base_mac\":\"$device_base_mac\",\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"tenant\":\"$tenant\",$row$eventformat_end\}$eordata"
                                                    set beginningdata_running $beginningdata
                                                    if {[file size "$filename$currentfile"] > $maxfilesize} {
                                                        #file too large create new
                                                        incr stat_bytes_transfered [file size "$filename$currentfile"]
                                                        incr currentfile
                                                        if {$eofdata ne ""} { puts $infile $eofdata }
                                                        close $infile
                                                        set infile [open "$filename$currentfile" "w" "0644"]
                                                        if {$bofdata ne ""} { puts $infile $bofdata }
                                                        set beginningdata_running ""
                                                    }
                                                }
                                            }
                                        }
                                        incr row_number
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }


        if {($pushstate eq "Yes") || ($pushconfig eq "Yes")} {
            ###now let's get pool member status

            set pool_id 0
            set pool_list ""
            catch {set pool_list [tmsh::get_status ltm pool recursive members]}
            foreach pool $pool_list {
                set pool_members [lindex $pool_list $pool_id]
                set pool_name "/[get_obj_name $pool]"
                set memberlist ""
                if {($format eq "F5 Analytics") && ($doconfigpush eq "Yes")} {
                    ##APP-IQ Format
                    set appiqpool_outedges ""
                    set appiqpool "\{\"kind\":\"ap:bigip:Pool\",\"id\":\"$pool_name\""
                }

                if {![tmsh::get_field_value $pool_members "members" memberlist]} {
                    set memberlist [list]
                }
                foreach {member} $memberlist {
                    set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"callbackurl\":\"$callbackurl\",\"pool_name\":\"$pool_name\",\"pool_member_name\":\"/[get_obj_name $member]\",\"address\":\"[get_fld_value $member "addr"]\",\"port\":\"[get_fld_value $member "port"]\","
                    append row "\"session_status\":\"[get_fld_value $member "session-status"]\","
                    append row "\"availability_state\":\"[get_fld_value $member "status.availability-state"]\","
                    append row "\"enabled_state\":\"[get_fld_value $member "status.enabled-state"]\","
                    append row "\"status_reason\":\"[get_fld_value $member "status.status-reason"]\""


                    puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_shared_index,\"host\":\"$hostname\",\"source\":\"bigip.tmsh.pool_member_status\",\"sourcetype\":\"f5:bigip:status:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                    set beginningdata_running $beginningdata
                    if {[file size "$filename$currentfile"] > $maxfilesize} {
                        #file too large create new
                        incr stat_bytes_transfered [file size "$filename$currentfile"]
                        incr currentfile
                        if {$eofdata ne ""} { puts $infile $eofdata }
                        close $infile
                        set infile [open "$filename$currentfile" "w" "0644"]
                        if {$bofdata ne ""} { puts $infile $bofdata }
                        set beginningdata_running ""
                    }
                    if {($format eq "F5 Analytics") && ($doconfigpush eq "Yes")} {
                        ##APP-IQ Format
                        append  appiqpool_outedges "\{\"targetKind\":\"ap:bigip:PoolMember\",\"targetId\":\"$pool_name-/[get_obj_name $member]\"\},"

                        puts $infile_config "$beginningdata_running_config\{\"kind\":\"ap:bigip:PoolMember\",\"id\":\"$pool_name-/[get_obj_name $member]\",\"name\":\"/[get_obj_name $member]\",\"enabled_state\":\"[get_fld_value $member "status.enabled-state"]\",\"address\":\"[get_fld_value $member "addr"]\",\"port\":\"[get_fld_value $member "port"]\"\}"
                        set beginningdata_running_config $beginningdata
                    }

                }
                if {($format eq "F5 Analytics") && ($doconfigpush eq "Yes")} {
                    ##APP-IQ Format
                    set appiqpool_outedges [string trimright $appiqpool_outedges ","]
                    if {$appiqpool_outedges ne ""} {
                        set appiqpool_outedges ",\"outEdges\":\[$appiqpool_outedges\]"
                    }

                    set appiqpool "$appiqpool$appiqpool_outedges\}"
                    puts $infile_config $beginningdata_running_config$appiqpool
                    set beginningdata_running_config $beginningdata
                }


                incr pool_id
            }


            ###now let's get Virtual Server status

            set virtual_list ""
            catch {set virtual_list [tmsh::get_status ltm virtual recursive]}
            foreach virtual $virtual_list {
                set virtual_name "/[get_obj_name $virtual]"

                #assign tenant, application, and tier
                set application ""
                set tier ""
                set tenant $tenantdefault
                set index $rbac_default_index
                catch {set application $vip2application($virtual_name)}
                catch {set tier $vip2tier($virtual_name)}
                catch {set tenant $vip2tenant($virtual_name)}
                if {$rbac eq "Yes"} {
                    catch {set index ",\"index\":\"$rbac_prefix$vip2tenant($virtual_name)\""}
                    regsub -all "\\.| " $index "_" index
                }

                set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"virtual_name\":\"$virtual_name\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"tenant\":\"$tenant\","
                append row "\"availability_state\":\"[get_fld_value $virtual "status.availability-state"]\","
                append row "\"enabled_state\":\"[get_fld_value $virtual "status.enabled-state"]\","
                append row "\"status_reason\":\"[get_fld_value $virtual "status.status-reason"]\""

                puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_shared_index,\"host\":\"$hostname\",\"source\":\"bigip.tmsh.virtual_status\",\"sourcetype\":\"f5:bigip:status:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                set beginningdata_running $beginningdata
                if {[file size "$filename$currentfile"] > $maxfilesize} {
                    #file too large create new
                    incr stat_bytes_transfered [file size "$filename$currentfile"]
                    incr currentfile
                    if {$eofdata ne ""} { puts $infile $eofdata }
                    close $infile
                    set infile [open "$filename$currentfile" "w" "0644"]
                    if {$bofdata ne ""} { puts $infile $bofdata }
                    set beginningdata_running ""
                }
            }

        }

        for {} {$pushsessiondb eq "Yes"} {break} {
            ###now let's get sessiondb

            # first purge any abandoned dumps which may be
            # lying around in /shared/tmp
            if {[catch {exec /bin/bash -c "/bin/rm -f /shared/tmp/f5-analytics-sessdata-*"} err]} {
                catch {exec /bin/logger -p local0.err "Analytics: rm /shared/tmp/f5-analytics-sessdata-* fails (${err})"}
                break
            }

            # then choose a sessiondump version to run
            foreach {majorversion minorversion} [split $::version "."] { break }

            if {$majorversion >= 12} {
                # built-in sessiondump utility is fine
                set dumper "/usr/bin/sessiondump"
            } elseif {$majorversion == 11} {
                catch {exec /bin/logger -p local0.info "Analytics: cannot use sessiondump on TMOS v11.x"}
                break
            } else {
                catch {exec /bin/logger -p local0.err "Analytics: cannot use sessiondump on TMOS v10.x"}
                break
            }

            set dumpfile "/shared/tmp/f5-analytics-sessdata-[pid]-[clock clicks]"

            if {[catch {exec $dumper --allkeys > $dumpfile} err]} {
              catch {exec /bin/logger -p local0.err "Analytics: ${dumper} --allkeys to ${dumpfile} fails (${err})"}
              break
            } else {
                set row ""
                set sessionid ""
                set fp [open $dumpfile r]
                while {[gets $fp data] >= 0} {
                    if {$data ne ""} {
                        set newsessionid [string range $data 0 7]
                        #deal with first session
                        if {$sessionid eq ""} {set sessionid $newsessionid}

                        #if not the same session write out
                        if {($sessionid ne $newsessionid) && !($newsessionid contains "\x20") && ($newsessionid ne "")} {
                            puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.sessiondb\",\"sourcetype\":\"f5:bigip:stats:iapp:json\",$eventformat_start\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"tenant\":\"$tenant\",\"aggr_period\":\"$aggr_period\",$row\"sessionid\":\"$sessionid\"$eventformat_end\}$eordata"
                            set beginningdata_running $beginningdata
                            if {[file size "$filename$currentfile"] > $maxfilesize} {
                                #file too large create new
                                incr stat_bytes_transfered [file size "$filename$currentfile"]
                                incr currentfile
                                if {$eofdata ne ""} { puts $infile $eofdata }
                                close $infile
                                set infile [open "$filename$currentfile" "w" "0644"]
                                if {$bofdata ne ""} { puts $infile $bofdata }
                                set beginningdata_running ""
                            }
                            set sessionid $newsessionid
                            set row ""
                            set application ""
                            set tier ""
                            set tenant $tenantdefault
                            set index $rbac_default_index

                        }
                        set key ""
                        set value ""
                        regexp "\\\.(.*) (.*) (.*)" $data junk key junk2 value
                        if {[lsearch $sessiondbkeys $key] != -1} {
                            if {$key eq "session.server.listener.name"} {
                                #assign tenant, application, and tier
                                catch {set application $vip2application($value)}
                                catch {set tier $vip2tier($value)}
                                catch {set tenant $vip2tenant($value)}
                                if {$rbac eq "Yes"} {
                                    catch {set index ",\"index\":\"$rbac_prefix$vip2tenant($value)\""}
                                    regsub -all "\\.| " $index "_" index
                                }
                            }
                            append row "\"$key\":\"$value\","
                        }

                        if {$customsessiondb eq "Yes"} {
                            if {($key eq $customsessiondb1) && ($customsessiondb1 ne "")} {
                                append row "\"customvar1\":\"$value\",\"customvar1_name\":\"$key\","
                            }
                            if {($key eq $customsessiondb2) && ($customsessiondb2 ne "")} {
                                append row "\"customvar2\":\"$value\",\"customvar2_name\":\"$key\","
                            }
                            if {($key eq $customsessiondb3) && ($customsessiondb3) ne ""} {
                                append row "\"customvar3\":\"$value\",\"customvar3_name\":\"$key\","
                            }
                            if {($key eq $customsessiondb4) && ($customsessiondb4 ne "")} {
                                append row "\"customvar4\":\"$value\",\"customvar4_name\":\"$key\","
                            }
                            if {($key eq $customsessiondb5) && ($customsessiondb5 ne "")} {
                                append row "\"customvar5\":\"$value\",\"customvar5_name\":\"$key\","
                            }
                        }
                    }
                }
                #write last row
                if {$row ne ""} {
                    puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.sessiondb\",\"sourcetype\":\"f5:bigip:stats:iapp:json\",$eventformat_start\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"tenant\":\"$tenant\",\"aggr_period\":\"$aggr_period\",$row\"sessionid\":\"$sessionid\"$eventformat_end\}$eordata"
                    set beginningdata_running $beginningdata
                }

                close $fp
                catch {exec /bin/rm -f $dumpfile}
            }
        }

        if {$pushistats eq "Yes"} {
            ###now let's get istats
            set output ""
            catch {set output [exec /usr/bin/istats dump |& grep " "]}
            set output [split $output "\n"]
            foreach line $output {
                set junk ""
                set keyspace ""
                set object ""
                set name ""
                set value ""
                set index $rbac_system_index
                set application ""
                set tier ""
                set tenant $tenantdefault

                if {$line contains "sys.application.service="} {
                    regexp {\[ (.*) \]\[(.*)\] = (\S*)} $line junk keyspace name value
                    set row ""

                    set keyspace [split $keyspace " "]
                    foreach key $keyspace {
                        set key [split $key "="]
                        append row "\"[lindex $key 0]\":\"[lindex $key 1]\","
                        if {[lindex $key 0] eq "ltm.virtual"} {
                            set index $rbac_default_index
                            #assign tenant, application, and tier
                            catch {set application $vip2application([lindex $key 1])}
                            catch {set tier $vip2tier([lindex $key 1])}
                            catch {set tenant $vip2tenant([lindex $key 1])}
                            if {$rbac eq "Yes"} {
                                catch {set index ",\"index\":\"$rbac_prefix$vip2tenant([lindex $key 1])\""}
                                regsub -all "\\.| " $index "_" index
                            }
                        }
                    }

                    append row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"aggr_period\":\"$aggr_period\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"tenant\":\"$tenant\",\"istat_name\":\"$name\",\"value\":\"$value\""


                    puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.istats.ssli\",\"sourcetype\":\"f5:bigip:stats:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                    set beginningdata_running $beginningdata

                    if {[file size "$filename$currentfile"] > $maxfilesize} {
                        #file too large create new
                        incr stat_bytes_transfered [file size "$filename$currentfile"]
                        incr currentfile
                        if {$eofdata ne ""} { puts $infile $eofdata }
                        close $infile
                        set infile [open "$filename$currentfile" "w" "0644"]
                        if {$bofdata ne ""} { puts $infile $bofdata }
                        set beginningdata_running ""
                    }

                } else {
                    regexp {\[ (.*)=(.*) \]\[(.*)\] = (\S*)} $line junk keyspace object name value
                    if {$keyspace ne ""} {
                        if {$keyspace eq "ltm.virtual"} {
                            set index $rbac_default_index
                            #assign tenant, application, and tier
                            catch {set application $vip2application($object)}
                            catch {set tier $vip2tier($object)}
                            catch {set tenant $vip2tenant($object)}
                            if {$rbac eq "Yes"} {
                                catch {set index ",\"index\":\"$rbac_prefix$vip2tenant($object)\""}
                                regsub -all "\\.| " $index "_" index
                            }
                        }

                        set row "\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"aggr_period\":\"$aggr_period\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"tenant\":\"$tenant\",\"keyspace\":\"$keyspace\",\"object\":\"$object\",\"istat_name\":\"$name\",\"value\":\"$value\""
                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"bigip.istats\",\"sourcetype\":\"f5:bigip:stats:iapp:json\",$eventformat_start$row$eventformat_end\}$eordata"
                        set beginningdata_running $beginningdata

                        if {[file size "$filename$currentfile"] > $maxfilesize} {
                            #file too large create new
                            incr stat_bytes_transfered [file size "$filename$currentfile"]
                            incr currentfile
                            if {$eofdata ne ""} { puts $infile $eofdata }
                            close $infile
                            set infile [open "$filename$currentfile" "w" "0644"]
                            if {$bofdata ne ""} { puts $infile $bofdata }
                            set beginningdata_running ""
                        }
                    }
                }
            }
        }


        if {$pushsslistats eq "Yes"} {
            set curl_response "fail"
            catch {set curl_response [exec /usr/bin/curl http://255.255.255.253:[expr {$uniqueid + 5}] --connect-timeout 10 --max-time 50 -o - -s]}


            if {$curl_response ne "fail"} {
                set output [split $curl_response "\n"]
                foreach outputline $output {
                    set sourcestring ""
                    set outputline [split $outputline "|"]

                    #change to switch statement when we add more
                    if {[lindex $outputline 0] eq "AVR_STAT_SSLI_DOMAIN"} {
                        set index $rbac_default_index
                        #{table}|${value}|${key}
                        #  0      1       2            3           4            5             6           7             8               9         10
                        #table, value, appName, virtual-server,domain-name, TLS version, ciphersuite, cipher bits,L7 protocol code, chain name, URLCat


                        set virtual [lindex $outputline 3]

                        #assign tenant, application, and tier
                        catch {set application $vip2application($virtual)}
                        catch {set tier $vip2tier($virtual)}
                        catch {set tenant $vip2tenant($virtual)}
                        if {$rbac eq "Yes"} {
                            catch {set index ",\"index\":\"$rbac_prefix$vip2tenant($virtual)\""}
                            regsub -all "\\.| " $index "_" index
                        }


                        set sourcestring "bigip.avrstats.AVR_STAT_SSLI_DOMAIN"
                        set url_catagory "Uncategorized"
                        catch {set url_catagory [lindex $outputline 10]}
                        set row "\"aggr_period\":\"$aggr_period\",\"app\":\"$application\",\"appComponent\":\"$tier\",\"tenant\":\"$tenant\",\"hits_count\":\"[lindex $outputline 1]\",\"app_name\":\"[lindex $outputline 2]\",\"vip_name\":\"$virtual\",\"domain-name\":\"[lindex $outputline 4]\",\"tls_version\":\"[lindex $outputline 5]\",\"cipher\":\"[lindex $outputline 6]\",\"cipher_bits\":\"[lindex $outputline 7]\",\"protocol\":\"[lindex $outputline 8]\",\"chain\":\"[lindex $outputline 9]\",\"url_filter_catagory\":\"$url_catagory\""
                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$index,\"host\":\"$hostname\",\"source\":\"$sourcestring\",\"sourcetype\":\"f5:bigip:stats:iapp:json\",$eventformat_start\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",$row$eventformat_end\}$eordata"
                        set beginningdata_running $beginningdata
                        if {[file size "$filename$currentfile"] > $maxfilesize} {
                            #file too large create new
                            incr stat_bytes_transfered [file size "$filename$currentfile"]
                            incr currentfile
                            if {$eofdata ne ""} { puts $infile $eofdata }
                            close $infile
                            set infile [open "$filename$currentfile" "w" "0644"]
                            if {$bofdata ne ""} { puts $infile $bofdata }
                            set beginningdata_running ""
                        }
                    }
                }
            }
        }

         ###now let's get iHealth data
         set qkview_location "fail"
         set qkview_number ""

         set ihealthattempts 0
        set key "ihealthattempts"
        catch {set ihealthattempts $lastpollsettings($key)}


         catch {set qkview_location [exec /bin/cat /shared/tmp/f5_analytics-${appname}-ihealthpickuplocation]}
         regexp {qkviews\/(.*)} $qkview_location junk qkview_number

        if {($qkview_location ne "fail") && ($ihealthattempts < $max_ihealth_attempts)} {
            set cookie_file "/shared/tmp/qkview_${appname}_ihealthpickup.cookie"

            set curl_response "fail"
            catch {set curl_response [exec /usr/bin/curl -k <ihealthproxyinfo> --connect-timeout 10 --max-time 50 -H "Content-type: application/json" --user-agent "F5 Analytics Auto Upload" --cookie-jar $cookie_file -o - --data-ascii "{\"user_id\": \"$ihealthusername\", \"user_secret\": \"${ihealthpassword}\"}" https://api.f5.com/auth/pub/sso/login/ihealth-api -sw "%{http_code}\n"]}
            tmsh::log "F5 Analytics - ${appname}: Received $curl_response when logging into iHealth for qkview pickup: $qkview_location"

            #check to see if it's done, calling the CSV first will create a blank file and we will never the the results
            set curl_response "fail"
            catch {set curl_response [exec /usr/bin/curl -k <ihealthproxyinfo> --connect-timeout 10 --max-time 50 -H "Accept: application/vnd.f5.ihealth.api.v1.0" --user-agent "F5 Analytics Auto Upload" --cookie $cookie_file --cookie-jar $cookie_file  ${qkview_location} -o - -s]}
            tmsh::log "F5 Analytics - ${appname}: Received $curl_response when checking for data in iHealth for qkview pickup: $qkview_location"

            if {($curl_response ne "fail") && ($curl_response ne "")} {

                set curl_response "fail"
                catch {set curl_response [exec /usr/bin/curl -k <ihealthproxyinfo> --connect-timeout 10 --max-time 50 -H "Accept: application/vnd.f5.ihealth.api.v1.0+csv" --user-agent "F5 Analytics Auto Upload" --cookie $cookie_file --cookie-jar $cookie_file  ${qkview_location}/diagnostics.csv -o - -s]}


                tmsh::log "F5 Analytics - ${appname}: Received $curl_response when pulling data from iHealth for qkview pickup: $qkview_location"


                if {$curl_response ne "fail"} {
                    set output $curl_response

                    set column_names {}
                    #split the output into a list

                    regsub -all "\"Serial Number\",\"Platform\"\n" $output "\"Serial Number\",\"Platform\"~lineend~" output
                    regsub -all ",\"$hostname\",\"\[^\n\]*\",\"\[^\n\]*\",\"\[^\n\]*\",\"\[^\n\]*\"\n" $output "~lineend~" output
                    regsub -all "\n" $output "\\n" output

                    regsub -all "~lineend~" $output "\n" output


                    set output [split $output "\n"]
                    set row_number 0
                    #tmsh::log "FINDME 1 [llength $output]"
                    if {[llength $output] > 1} {
                        foreach outputline $output {
                            if {$row_number == 0} {
                                #this has our columns lets store this info
                                set column_names [split $outputline ","]
                                #tmsh::log "FINDME 2 $outputline"
                            } else {
                                set ignore 0
                                #this is a row of data we need to split the row
                                set column_number 0
                                regsub -all "\",\"" $outputline "\"|\"" outputline
                                #tmsh::log "FINDME 3 $outputline"
                                set columns [split $outputline "|"]
                                set row ""
                                if {$ignore != 1} {
                                    foreach column $columns {
                                        #tmsh::log "FINDME 4 $column"
                                        set metric_name [lindex $column_names $column_number]
                                        if {$column ne "\"\""} {
                                            regsub -all {""} $column "" column
                                        }


                                        append row "$metric_name:$column,"

                                        incr column_number
                                    }
                                    set row [string trimright $row ","]
                                    if {$row ne ""} {
                                        #tmsh::log "FINDME: $row"
                                        puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_system_index,\"host\":\"$hostname\",\"source\":\"bigip.ihealth.diagnostics\",\"sourcetype\":\"f5:bigip:ihealth:iapp:json\",$eventformat_start\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"qkview_number\":\"$qkview_number\",\"ihealth_link\":\"https://ihealth.f5.com/qkview-analyzer/qv/$qkview_number\",$row$eventformat_end\}$eordata"
                                        set beginningdata_running $beginningdata
                                        if {[file size "$filename$currentfile"] > $maxfilesize} {
                                            #file too large create new
                                            incr stat_bytes_transfered [file size "$filename$currentfile"]
                                            incr currentfile
                                            if {$eofdata ne ""} { puts $infile $eofdata }
                                            close $infile
                                            set infile [open "$filename$currentfile" "w" "0644"]
                                            if {$bofdata ne ""} { puts $infile $bofdata }
                                            set beginningdata_running ""
                                        }
                                    }
                                }
                            }
                            incr row_number
                        }
                        catch {exec /bin/rm -f /shared/tmp/f5_analytics-${appname}-ihealthpickuplocation}
                        set key "ihealthattempts"
                        set newpollsettings($key) 0
                    }
                } else {
                    tmsh::log "F5 Analytics - ${appname}: Received $curl_response when pulling data from iHealth for qkview pickup: $qkview_location"
                    set key "ihealthattempts"
                    set newpollsettings($key) [expr {$ihealthattempts + 1}]
                }
            } else {
                set key "ihealthattempts"
                set newpollsettings($key) [expr {$ihealthattempts + 1}]
            }
            catch {exec /bin/rm -f $cookie_file}



        }

        if {$ihealthattempts >= $max_ihealth_attempts} {
            catch {exec /bin/rm -f /shared/tmp/f5_analytics-${appname}-ihealthpickuplocation}
            set key "ihealthattempts"
            set newpollsettings($key) 0
        }

        #add report on how many bytes and files were sent.
        puts $infile "$beginningdata_running$bordata\{\"time\":$date$rbac_system_index,\"host\":\"$hostname\",\"source\":\"bigip.stats.summary\",\"sourcetype\":\"f5:bigip:stats:iapp:json\",$eventformat_start\"devicegroup\":\"$devicegroup\",\"facility\":\"$facility\",\"aggr_period\":\"$aggr_period\",\"files_sent\":\"[expr {$currentfile + 1}]\",\"bytes_transfered\":\"$stat_bytes_transfered\"$eventformat_end\}$eordata"
        set beginningdata_running $beginningdata

        if {$eofdata ne ""} { puts $infile $eofdata }
        close $infile

        if {($format eq "F5 Analytics") && ($doconfigpush eq "Yes")} {
            puts $infile_config "\x5d\x7d"

            close $infile_config
        }

        for {set i 0} {$i <= $currentfile} {incr i} {
            set curl_response "fail"
            set ext ""
        switch -- $format {
                "Splunk" -
                "F5 Analytics" {
                    catch {exec /bin/gzip $filename$i$ext -f}
                    append ext ".gz"
                    #gzip
                    catch {set curl_response [exec /usr/bin/curl --connect-timeout 10 --max-time 50 -k $url <statsproxyinfo> --compressed -H "Host: $hostheader\nContent-Type: application/json\n$apikey\nAccept-Encoding: gzip\nContent-Encoding: gzip" -X POST --data-binary @$filename$i$ext -o /shared/tmp/${appname}-stats_output_$i -0 -sw "%{http_code}\n"]}
                    catch {exec /bin/rm -f "${filename}${i}${ext}"}
                }
                "Sumo Logic" {
                    catch {set curl_response [exec /usr/bin/curl --connect-timeout 10 --max-time 50 -k $url <statsproxyinfo> -H "Host: $hostheader\nContent-Type: application/json" -X POST --data-binary @$filename$i$ext -o /shared/tmp/${appname}-stats_output_$i -0 -sw "%{http_code}\n"]}
                    catch {exec /bin/rm -f "${filename}${i}${ext}"}
                }
                "F5 Risk Engine" -
                "F5 Risk Engine - Full" {
                    #non gzip
                    catch {set curl_response [exec /usr/bin/curl --connect-timeout 10 --max-time 50 -k $url <statsproxyinfo> -H "Host: $hostheader\nContent-Type: application/json\n$apikey" -X POST -d @$filename$i -o /shared/tmp/${appname}-stats_output_$i -0 -sw "%{http_code}\n"]}
                    if {$pushinterval < 11} {
                        catch {exec /bin/rm -f "$filename$i"}
                    }
                }
                "F5 BIG-IQ" {
                    set curl_response "Moved"
                    catch {exec /bin/gzip $filename$i$ext -f}
                    append ext ".gz"
                    catch {exec /bin/mv -f $filename$i$ext /var/local/ucs/f5.analytics-BIG-IQ$ext}
                }
            }


            if {$debug eq "Yes"} {
                tmsh::log "Stats Response for $appname $date $i $curl_response"
            }
        }

        #send config data for F5 Analytics
        if {($format eq "F5 Analytics") && ($doconfigpush eq "Yes")} {
            set curl_response "fail"
            set ext ""
            set i 0
            catch {exec /bin/gzip $filename_config$i$ext -f}
            append ext ".gz"
            #gzip
            catch {set curl_response [exec /usr/bin/curl --connect-timeout 10 --max-time 50 -k $configurl <statsproxyinfo> --compressed -H "Host: $hostheader\nContent-Type: application/json\n$apikey\nAccept-Encoding: gzip\nContent-Encoding: gzip" -X POST --data-binary @$filename_config$i$ext -o /shared/tmp/${appname}-config_output_$i -0 -sw "%{http_code}\n"]}
            if {$debug eq "Yes"} {
                tmsh::log "Config Response for $appname $date $i $curl_response"
            }
        }


        #write the new settings
        set filename "/shared/tmp/f5_analytics-${appname}-lastpollsettings"
        set settingsfile [open "$filename" "w" "0644"]
        puts $settingsfile "lastsentdate|$date"
        foreach {key value} [array get newpollsettings] {
            puts $settingsfile "$key|$value"
        }
        close $settingsfile
    }
    ########SplunkStats Script End ########


    ########SplunkStats DataGroup Start ########
    #tmctl format     "<tablename1> <colnumberforvipmapping> <tablename1> <colnumberforvipmapping>"
    #avr format "{<Name1>|<colnumberforvipmapping>} {<SQL QUERY>} {<Name2>|<colnumberforvipmapping>} {<SQL QUERY>}"
    #avr note "<tosendbuckets>" will be filled with a list of bucket time staps that have yet to be sent and are done being filled

    #set defaults
    if {$::statistics__customcollection ne "Yes"} {
        set ::statistics__customcollectionconfig "mcp_request_stat mcp_transaction_stat monitor_instance_stat monitor_stat disk_info_stat profile_dns_stat gtm_wideip_stat dns_cache_resolver_stat tmmdns_zone_stat tmmdns_server_stat dnsexpress_zone_stat gtm_dc_stat tmm_stat memory_usage_stat profile_udp_stat interface_stat virtual_server_conn_stat rule_stat kvm_vcpu_stat kvm_vm_stat vcmp_global_stat vcmp_stat asm_cpu_util_stats cpu_info_stat dos_stat dosl7_plugin_stats proc_pid_stat dosl7d_stat flow_eviction_policy_stat host_info_stat ifc_stats ip_intelligence_stat ip_stat iprepd_stat pool_member_stat pool_stat profile_bigproto_stat profile_clientssl_stat profile_connpool_stat profile_ftp_stat profile_http_stat profile_httpcompression_stat profile_serverssl_stat profile_tcp_stat profile_webacceleration_stat virtual_server_cpu_stat virtual_server_stat AVR_STAT_DNS_QUERY AVR_STAT_DNS_CLIENT_IP AVR_STAT_APM_SWG_BLOCKED AVR_STAT_APM_SWG_URL_INFO AVR_STAT_APM_SWG_USER_INFO AVR_STAT_URL AVR_STAT_POOL_MEMBER AVR_STAT_ASM_ANOMALIES AVR_STAT_ASM_HTTP_ATTACK_DATA AVR_STAT_ASM_HTTP_VIOLATION AVR_STAT_ASM_NETWORK AVR_STAT_GEO_LOCATION AVR_STAT_METHOD AVR_STAT_USER_AGENT AVR_STAT_VIP AVR_STAT_ENFORCED_ACL AVR_STAT_STAGING_ACL AVR_STAT_RESPONSE_CODE AVR_STAT_CLIENT_IP AVR_STAT_TCP"
    }

    if {($::statistics__customcollection ne "Yes") && ($::basic__appiqformat eq "Yes")} {
        set ::statistics__customcollectionconfig "mcp_request_stat mcp_transaction_stat monitor_instance_stat monitor_stat dnsexpress_zone_stat gtm_dc_stat virtual_server_conn_stat kvm_vcpu_stat kvm_vm_stat vcmp_global_stat dos_stat dosl7_plugin_stats dosl7d_stat flow_eviction_policy_stat ifc_stats ip_intelligence_stat iprepd_stat pool_stat profile_bigproto_stat profile_clientssl_stat profile_connpool_stat profile_ftp_stat profile_http_stat profile_httpcompression_stat profile_serverssl_stat"
    }

    if {($::basic__format eq "F5 Risk Engine") &&
                ($::statistics__customcollection ne "Yes")} {

    ##########################################################################################################################################################################################################################################################################################################################################################################
    #########################################################################################################################################################################################################################################################################################################################################################################
    ############################################################################################################################################################# START START  Risk Engine Team Code  START START ############################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################

        set ::statistics__customcollectionconfig "profile_http_stat virtual_server_stat dos_stat flow_eviction_policy_stat profile_tcp_stat"

    ##########################################################################################################################################################################################################################################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################
    ############################################################################################################################################################ END END END  Risk Engine Team Code  END END END #############################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################

    }

    if {($::basic__format eq "F5 BIG-IQ") && ($::statistics__customcollection ne "Yes")} {

    ##########################################################################################################################################################################################################################################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################
    ############################################################################################################################################################# START START  BIG-IQ      Team Code  START START ############################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################

        set ::statistics__customcollectionconfig "mcp_request_stat mcp_transaction_stat monitor_instance_stat monitor_stat disk_info_stat tmmdns_server_stat profile_dns_stat gtm_wideip_stat dns_cache_resolver_stat tmmdns_zone_stat dnsexpress_zone_stat gtm_dc_stat tmm_stat memory_usage_stat profile_udp_stat interface_stat virtual_server_conn_stat rule_stat kvm_vcpu_stat kvm_vm_stat vcmp_global_stat vcmp_stat asm_cpu_util_stats cpu_info_stat dos_stat dosl7_plugin_stats proc_pid_stat dosl7d_stat flow_eviction_policy_stat host_info_stat ifc_stats ip_intelligence_stat ip_stat iprepd_stat pool_member_stat pool_stat profile_bigproto_stat profile_clientssl_stat profile_connpool_stat profile_ftp_stat profile_http_stat profile_httpcompression_stat profile_serverssl_stat profile_tcp_stat profile_webacceleration_stat virtual_server_cpu_stat virtual_server_stat AVR_STAT_DNS_QUERY AVR_STAT_DNS_CLIENT_IP"

    ##########################################################################################################################################################################################################################################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################
    ############################################################################################################################################################ END END END  BIG-IQ      Team Code  END END END #############################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################

    }


    array set tmctlmapping {mcp_request_stat -1 mcp_transaction_stat -1 monitor_instance_stat -2 monitor_stat -1 disk_info_stat -1 profile_dns_stat 1 gtm_wideip_stat -1 dns_cache_resolver_stat -1 tmmdns_zone_stat -1 tmmdns_server_stat -1 dnsexpress_zone_stat -1 gtm_dc_stat -1 tmm_stat -1 memory_usage_stat -1 profile_udp_stat 1 interface_stat -1 virtual_server_conn_stat 0 rule_stat -2 kvm_vcpu_stat -1 kvm_vm_stat -1 vcmp_global_stat -1 vcmp_stat -1 asm_cpu_util_stats 1 cpu_info_stat -1 dos_stat 0 dosl7_plugin_stats -1 proc_pid_stat -1 dosl7d_stat -1 flow_eviction_policy_stat 2 host_info_stat -1 ifc_stats -1 ip_intelligence_stat -1 ip_stat -1 iprepd_stat -1 pool_member_stat -2 pool_stat -2 profile_bigproto_stat 1 profile_clientssl_stat 1 profile_connpool_stat 1 profile_ftp_stat 1 profile_http_stat 1 profile_httpcompression_stat 1 profile_serverssl_stat 1 profile_tcp_stat 1 profile_webacceleration_stat 1 virtual_server_cpu_stat 0 virtual_server_stat 0}
    array set avrmapping {}
    if {[lindex [split $::version "."] 0] == 13} {
        array set avrmapping {
            AVR_STAT_DNS_QUERY "\{AVR_STAT_DNS_QUERY|4\} \{ select     A.aggr_period,   A.time_stamp,    A.hits_count, AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, attack_id, attack_type_id, AVR_DIM_DNS_QUERY_TYPE.query_type_name, AVR_DIM_DNS_QUERY_NAME.query_name, AVR_DIM_DNS_REQUEST_TYPE.request_type_name   from AVR_STAT_DNS_QUERY_T A  LEFT JOIN AVR_DIM_DNS_QUERY_TYPE ON A.query_type_id=AVR_DIM_DNS_QUERY_TYPE.query_type_id LEFT JOIN AVR_DIM_DNS_QUERY_NAME ON A.query_name_crc=AVR_DIM_DNS_QUERY_NAME.query_name_crc LEFT JOIN AVR_DIM_DNS_REQUEST_TYPE ON A.transaction_outcome_id=AVR_DIM_DNS_REQUEST_TYPE.request_type_id   LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc   where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_DNS_CLIENT_IP "\{AVR_STAT_DNS_CLIENT_IP|4\} \{ select     A.aggr_period,   A.time_stamp,    A.hits_count, AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, attack_id, attack_type_id, AVR_DIM_DNS_QUERY_TYPE.query_type_name, HEX(A.client_ip) as client_ip,  AVR_DIM_DNS_REQUEST_TYPE.request_type_name   from AVR_STAT_DNS_CLIENT_IP_T A  LEFT JOIN AVR_DIM_DNS_QUERY_TYPE ON A.query_type_id=AVR_DIM_DNS_QUERY_TYPE.query_type_id LEFT JOIN AVR_DIM_DNS_REQUEST_TYPE ON A.transaction_outcome_id=AVR_DIM_DNS_REQUEST_TYPE.request_type_id   LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc   where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_BLOCKED "\{AVR_STAT_APM_SWG_BLOCKED|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   ssl_bypass, AVR_DIM_APM_SWG_USERNAME.username_str, AVR_DIM_APM_SWG_URL.url_str,  HEX(A.client_ip) as client_ip, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_BLOCKED_T A   LEFT JOIN AVR_DIM_APM_SWG_USERNAME ON A.username_crc=AVR_DIM_APM_SWG_USERNAME.username_crc LEFT JOIN AVR_DIM_APM_SWG_URL ON A.url_crc=AVR_DIM_APM_SWG_URL.url_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_URL_INFO "\{AVR_STAT_APM_SWG_URL_INFO|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   AVR_DIM_APM_SWG_ACTION.action_str,  ssl_bypass, AVR_DIM_APM_SWG_HOST_NAME.host_name_str, AVR_DIM_APM_SWG_URL.url_str, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_URL_INFO_T A   LEFT JOIN AVR_DIM_APM_SWG_ACTION ON A.action_id=AVR_DIM_APM_SWG_ACTION.action_id LEFT JOIN AVR_DIM_APM_SWG_HOST_NAME ON A.host_name_crc=AVR_DIM_APM_SWG_HOST_NAME.host_name_crc LEFT JOIN AVR_DIM_APM_SWG_URL ON A.url_crc=AVR_DIM_APM_SWG_URL.url_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_USER_INFO "\{AVR_STAT_APM_SWG_USER_INFO|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   AVR_DIM_APM_SWG_ACTION.action_str,  ssl_bypass, AVR_DIM_APM_SWG_USERNAME.username_str,  HEX(A.client_ip) as client_ip, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_USER_INFO_T A   LEFT JOIN AVR_DIM_APM_SWG_ACTION ON A.action_id=AVR_DIM_APM_SWG_ACTION.action_id LEFT JOIN AVR_DIM_APM_SWG_USERNAME ON A.username_crc=AVR_DIM_APM_SWG_USERNAME.username_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_URL "\{AVR_STAT_URL|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, AVR_DIM_URL.url_name, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_URL_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc LEFT JOIN AVR_DIM_URL ON A.url_crc=AVR_DIM_URL.url_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_RESPONSE_CODE "\{AVR_STAT_RESPONSE_CODE|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, AVR_DIM_URL.url_name, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.response_code, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_RESPONSE_CODE_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc LEFT JOIN AVR_DIM_URL ON A.url_crc=AVR_DIM_URL.url_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_CLIENT_IP "\{AVR_STAT_CLIENT_IP|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, HEX( A.client_ip) as client_ip, HEX(AVR_DIM_CLIENT_SUBNET.subnet_addr) as subnet_addr, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_CLIENT_IP_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_CLIENT_SUBNET ON A.subnet_crc=AVR_DIM_CLIENT_SUBNET.subnet_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_POOL_MEMBER "\{AVR_STAT_POOL_MEMBER|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_POOL_MEMBER_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_ANOMALIES "\{AVR_STAT_ASM_ANOMALIES|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ASM_ANOMALIES.anomaly_type_name, A.new_attacks_count,  A.rejected_requests_count,  A.total_violations    from AVR_STAT_ASM_ANOMALIES_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ASM_ANOMALIES ON A.anomaly_type_id=AVR_DIM_ASM_ANOMALIES.anomaly_type_id  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_HTTP_ATTACK_DATA "\{AVR_STAT_ASM_HTTP_ATTACK_DATA|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, A.action_id,  A.severity_id,  A.rating,  A.protocol_id,  A.attack_types,  AVR_DIM_ASM_HTTP_VIRUS.virus_id,  AVR_DIM_ASM_HTTP_VIRUS.virus_name   from AVR_STAT_ASM_HTTP_ATTACK_DATA_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ASM_HTTP_VIRUS ON A.vip_crc=AVR_DIM_ASM_HTTP_VIRUS.vip_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_HTTP_VIOLATION "\{AVR_STAT_ASM_HTTP_VIOLATION|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ENFORCEMENT_ACTION.action_name, A.severity_id,  A.rating,  AVR_DIM_ASM_REPEV_PROTOCOL.protocol_name, A.attack_types,  AVR_DIM_ASM_HTTP_VIOLATION.violation_name, AVR_DIM_ASM_HTTP_VIRUS.virus_id, AVR_DIM_ASM_HTTP_VIRUS.virus_name   from AVR_STAT_ASM_HTTP_VIOLATION_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ENFORCEMENT_ACTION ON A.action_id=AVR_DIM_ENFORCEMENT_ACTION.action_type   LEFT JOIN AVR_DIM_ASM_REPEV_PROTOCOL ON A.protocol_id=AVR_DIM_ASM_REPEV_PROTOCOL.protocol_id  LEFT JOIN AVR_DIM_ASM_HTTP_VIOLATION ON A.violation_crc=AVR_DIM_ASM_HTTP_VIOLATION.violation_id LEFT JOIN AVR_DIM_ASM_HTTP_VIRUS ON A.vip_crc=AVR_DIM_ASM_HTTP_VIRUS.vip_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_NETWORK "\{AVR_STAT_ASM_NETWORK|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ENFORCEMENT_ACTION.action_name, A.total_request_size   from AVR_STAT_ASM_NETWORK_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ENFORCEMENT_ACTION ON A.action_id=AVR_DIM_ENFORCEMENT_ACTION.action_type  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_GEO_LOCATION "\{AVR_STAT_GEO_LOCATION|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, A.country_code,  A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16,  A.concurrent_sessions,  A.sessions   from AVR_STAT_GEO_LOCATION_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_METHOD "\{AVR_STAT_METHOD|4\} \{select A.aggr_period,  A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, AVR_DIM_METHOD.method_name, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16    from AVR_STAT_METHOD_T A    LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_METHOD ON A.method_crc=AVR_DIM_METHOD.method_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_USER_AGENT "\{AVR_STAT_USER_AGENT|4\} \{select A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, AVR_DIM_USER_AGENT.user_agent_name, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_USER_AGENT_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_USER_AGENT ON A.user_agent_crc=AVR_DIM_USER_AGENT.user_agent_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_VIP "\{AVR_STAT_VIP|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16,  A.concurrent_sessions,  A.sessions   from AVR_STAT_VIP_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ENFORCED_ACL "\{AVR_STAT_ENFORCED_ACL|6\} \{select           aggr_period,     time_stamp,     hits_count,     AVR_DIM_APPLICATION.app_name,      AVR_DIM_ACL_RULE.rule_name,     AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_name,     AVR_DIM_ACL_CONTEXT_INFO.context_info_name,     AVR_DIM_FW_ACL_ACTIONS.action,     AVR_DIM_VLAN.vlan_name,     AVR_DIM_ACL_POLICY.policy_name,     HEX( source_ip ) as source_ip,     source_port,     HEX( dest_ip ) as dest_ip,     dest_port,     AVR_DIM_ACL_SA_TRANS.translate_reason_name,     AVR_DIM_ACL_TRANSLATE_TYPE.translate_type_name,     HEX( self_ip ) as self_ip,     HEX( server_ip ) as server_ip,     source_country_code,     dest_country_code     from AVR_STAT_ENFORCED_ACL_T A      LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc      LEFT JOIN AVR_DIM_ACL_RULE ON A.rule_crc=AVR_DIM_ACL_RULE.rule_crc     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO_TYPE ON A.context_info_type_id=AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_id     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO ON A.context_info_crc=AVR_DIM_ACL_CONTEXT_INFO.context_info_crc     LEFT JOIN AVR_DIM_FW_ACL_ACTIONS ON A.action_id=AVR_DIM_FW_ACL_ACTIONS.action_id     LEFT JOIN AVR_DIM_VLAN ON A.vlan_crc=AVR_DIM_VLAN.vlan_crc     LEFT JOIN AVR_DIM_ACL_POLICY ON A.policy_crc=AVR_DIM_ACL_POLICY.policy_crc       LEFT JOIN AVR_DIM_ACL_SA_TRANS ON A.translate_reason_crc=AVR_DIM_ACL_SA_TRANS.translate_reason_crc     LEFT JOIN AVR_DIM_ACL_TRANSLATE_TYPE ON A.translate_type_id=AVR_DIM_ACL_TRANSLATE_TYPE.translate_type_id where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_STAGING_ACL "\{AVR_STAT_STAGING_ACL|6\} \{select           aggr_period,     time_stamp,     hits_count,     AVR_DIM_APPLICATION.app_name,      AVR_DIM_ACL_RULE.rule_name,     AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_name,     AVR_DIM_ACL_CONTEXT_INFO.context_info_name,     AVR_DIM_FW_ACL_ACTIONS.action,     AVR_DIM_VLAN.vlan_name,     AVR_DIM_ACL_POLICY.policy_name,     HEX( source_ip ) as source_ip,     source_port,     HEX( dest_ip ) as dest_ip,     dest_port,               source_country_code,     dest_country_code     from AVR_STAT_STAGING_ACL_T A      LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc      LEFT JOIN AVR_DIM_ACL_RULE ON A.rule_crc=AVR_DIM_ACL_RULE.rule_crc     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO_TYPE ON A.context_info_type_id=AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_id     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO ON A.context_info_crc=AVR_DIM_ACL_CONTEXT_INFO.context_info_crc     LEFT JOIN AVR_DIM_FW_ACL_ACTIONS ON A.action_id=AVR_DIM_FW_ACL_ACTIONS.action_id     LEFT JOIN AVR_DIM_VLAN ON A.vlan_crc=AVR_DIM_VLAN.vlan_crc     LEFT JOIN AVR_DIM_ACL_POLICY ON A.policy_crc=AVR_DIM_ACL_POLICY.policy_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_TCP "\{AVR_STAT_TCP|5\} \{ select  A.aggr_period, A.time_stamp, A.hits_count, AVR_DIM_APPLICATION.app_name, A.request_side, AVR_DIM_VIP.vip_name, HEX(A.remote_host_ip) as remote_host_ip, HEX(A.subnet) as subnet, AVR_DIM_TCP_NEXTHOP.nexthop_str, AVR_DIM_TCP_USERKEY.user_key, AVR_DIM_PEM_SUBSCRIBER.subscriber_name, AVR_DIM_PEM_SUBSCRIBER_TYPE.subscriber_type_name, AVR_DIM_PEM_TOWER.tower_name, AVR_DIM_RADIO_TYPE.radio_type, A.continent_code, AVR_DIM_TCP_COUNTRY_REGION.country_region, AVR_DIM_TCP_CITY_POSTCODE.city_postcode, A.rtt_count, A.rtt_sum, A.rtt_max, A.rtt_min, A.rtt_var_sum, A.pkts_recv, A.pkts_lost, A.pkts_sent, A.goodput_snd, A.goodput_rcv, A.ds_3whs, A.ds_rwnd, A.ds_retx, A.ds_waitforack, A.ds_closing, A.ds_cwnd, A.ds_nagle, A.ds_sndbuf, A.ds_app, A.ds_ratepace, A.cs_numstarts, A.cs_numendings, A.cs_dursum from AVR_STAT_TCP_T A LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc   LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc    LEFT JOIN AVR_DIM_TCP_NEXTHOP ON A.nexthop_crc=AVR_DIM_TCP_NEXTHOP.nexthop_crc LEFT JOIN AVR_DIM_TCP_USERKEY ON A.user_key_crc=AVR_DIM_TCP_USERKEY.user_key_crc LEFT JOIN AVR_DIM_TCP_CITY_POSTCODE ON A.city_postcode_crc=AVR_DIM_TCP_CITY_POSTCODE.city_postcode_crc LEFT JOIN AVR_DIM_TCP_COUNTRY_REGION ON A.country_region_crc=AVR_DIM_TCP_COUNTRY_REGION.country_region_crc LEFT JOIN AVR_DIM_PEM_SUBSCRIBER ON A.subscriber_name_crc=AVR_DIM_PEM_SUBSCRIBER.subscriber_name_crc LEFT JOIN AVR_DIM_PEM_TOWER ON A.tower_name_crc=AVR_DIM_PEM_TOWER.tower_name_crc LEFT JOIN AVR_DIM_RADIO_TYPE ON A.radio_type_crc=AVR_DIM_RADIO_TYPE.radio_type_crc LEFT JOIN AVR_DIM_PEM_SUBSCRIBER_TYPE ON A.subscriber_id_type=AVR_DIM_PEM_SUBSCRIBER_TYPE.subscriber_type_id  where A.time_stamp IN (<tosendbuckets>)\}"
        }
    }
    if {[lindex [split $::version "."] 0] == 12} {
        array set avrmapping {
            AVR_STAT_DNS_QUERY "\{AVR_STAT_DNS_QUERY|4\} \{ select     A.aggr_period,   A.time_stamp,    A.hits_count, AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, attack_id, attack_type_id, AVR_DIM_DNS_QUERY_TYPE.query_type_name, AVR_DIM_DNS_QUERY_NAME.query_name, AVR_DIM_DNS_REQUEST_TYPE.request_type_name   from AVR_STAT_DNS_QUERY_T A  LEFT JOIN AVR_DIM_DNS_QUERY_TYPE ON A.query_type_id=AVR_DIM_DNS_QUERY_TYPE.query_type_id LEFT JOIN AVR_DIM_DNS_QUERY_NAME ON A.query_name_crc=AVR_DIM_DNS_QUERY_NAME.query_name_crc LEFT JOIN AVR_DIM_DNS_REQUEST_TYPE ON A.transaction_outcome_id=AVR_DIM_DNS_REQUEST_TYPE.request_type_id   LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc   where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_DNS_CLIENT_IP "\{AVR_STAT_DNS_CLIENT_IP|4\} \{ select     A.aggr_period,   A.time_stamp,    A.hits_count, AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, attack_id, attack_type_id, AVR_DIM_DNS_QUERY_TYPE.query_type_name, HEX(A.client_ip) as client_ip,  AVR_DIM_DNS_REQUEST_TYPE.request_type_name   from AVR_STAT_DNS_CLIENT_IP_T A  LEFT JOIN AVR_DIM_DNS_QUERY_TYPE ON A.query_type_id=AVR_DIM_DNS_QUERY_TYPE.query_type_id LEFT JOIN AVR_DIM_DNS_REQUEST_TYPE ON A.transaction_outcome_id=AVR_DIM_DNS_REQUEST_TYPE.request_type_id   LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc   where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_BLOCKED "\{AVR_STAT_APM_SWG_BLOCKED|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   ssl_bypass, AVR_DIM_APM_SWG_USERNAME.username_str, AVR_DIM_APM_SWG_URL.url_str,  HEX(A.client_ip) as client_ip, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_BLOCKED_T A   LEFT JOIN AVR_DIM_APM_SWG_USERNAME ON A.username_crc=AVR_DIM_APM_SWG_USERNAME.username_crc LEFT JOIN AVR_DIM_APM_SWG_URL ON A.url_crc=AVR_DIM_APM_SWG_URL.url_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_URL_INFO "\{AVR_STAT_APM_SWG_URL_INFO|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   AVR_DIM_APM_SWG_ACTION.action_str,  ssl_bypass, AVR_DIM_APM_SWG_HOST_NAME.host_name_str, AVR_DIM_APM_SWG_URL.url_str, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_URL_INFO_T A   LEFT JOIN AVR_DIM_APM_SWG_ACTION ON A.action_id=AVR_DIM_APM_SWG_ACTION.action_id LEFT JOIN AVR_DIM_APM_SWG_HOST_NAME ON A.host_name_crc=AVR_DIM_APM_SWG_HOST_NAME.host_name_crc LEFT JOIN AVR_DIM_APM_SWG_URL ON A.url_crc=AVR_DIM_APM_SWG_URL.url_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_USER_INFO "\{AVR_STAT_APM_SWG_USER_INFO|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   AVR_DIM_APM_SWG_ACTION.action_str,  ssl_bypass, AVR_DIM_APM_SWG_USERNAME.username_str,  HEX(A.client_ip) as client_ip, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_USER_INFO_T A   LEFT JOIN AVR_DIM_APM_SWG_ACTION ON A.action_id=AVR_DIM_APM_SWG_ACTION.action_id LEFT JOIN AVR_DIM_APM_SWG_USERNAME ON A.username_crc=AVR_DIM_APM_SWG_USERNAME.username_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_URL "\{AVR_STAT_URL|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, AVR_DIM_URL.url_name, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_URL_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc LEFT JOIN AVR_DIM_URL ON A.url_crc=AVR_DIM_URL.url_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_RESPONSE_CODE "\{AVR_STAT_RESPONSE_CODE|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, AVR_DIM_URL.url_name, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.response_code, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_RESPONSE_CODE_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc LEFT JOIN AVR_DIM_URL ON A.url_crc=AVR_DIM_URL.url_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_CLIENT_IP "\{AVR_STAT_CLIENT_IP|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, HEX( A.client_ip) as client_ip, HEX(AVR_DIM_CLIENT_SUBNET.subnet_addr) as subnet_addr, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_CLIENT_IP_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_CLIENT_SUBNET ON A.subnet_crc=AVR_DIM_CLIENT_SUBNET.subnet_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_POOL_MEMBER "\{AVR_STAT_POOL_MEMBER|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_POOL_MEMBER_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_ANOMALIES "\{AVR_STAT_ASM_ANOMALIES|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ASM_ANOMALIES.anomaly_type_name, A.new_attacks_count,  A.rejected_requests_count,  A.total_violations    from AVR_STAT_ASM_ANOMALIES_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ASM_ANOMALIES ON A.anomaly_type_id=AVR_DIM_ASM_ANOMALIES.anomaly_type_id  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_HTTP_ATTACK_DATA "\{AVR_STAT_ASM_HTTP_ATTACK_DATA|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, A.action_id,  A.severity_id,  A.rating,  A.protocol_id,  A.attack_types,  AVR_DIM_ASM_HTTP_VIRUS.virus_id,  AVR_DIM_ASM_HTTP_VIRUS.virus_name   from AVR_STAT_ASM_HTTP_ATTACK_DATA_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ASM_HTTP_VIRUS ON A.vip_crc=AVR_DIM_ASM_HTTP_VIRUS.vip_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_HTTP_VIOLATION "\{AVR_STAT_ASM_HTTP_VIOLATION|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ENFORCEMENT_ACTION.action_name, A.severity_id,  A.rating,  AVR_DIM_ASM_REPEV_PROTOCOL.protocol_name, A.attack_types,  AVR_DIM_ASM_HTTP_VIOLATION.violation_name, AVR_DIM_ASM_HTTP_VIRUS.virus_id, AVR_DIM_ASM_HTTP_VIRUS.virus_name   from AVR_STAT_ASM_HTTP_VIOLATION_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ENFORCEMENT_ACTION ON A.action_id=AVR_DIM_ENFORCEMENT_ACTION.action_type   LEFT JOIN AVR_DIM_ASM_REPEV_PROTOCOL ON A.protocol_id=AVR_DIM_ASM_REPEV_PROTOCOL.protocol_id  LEFT JOIN AVR_DIM_ASM_HTTP_VIOLATION ON A.violation_crc=AVR_DIM_ASM_HTTP_VIOLATION.violation_id LEFT JOIN AVR_DIM_ASM_HTTP_VIRUS ON A.vip_crc=AVR_DIM_ASM_HTTP_VIRUS.vip_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_NETWORK "\{AVR_STAT_ASM_NETWORK|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ENFORCEMENT_ACTION.action_name, A.total_request_size   from AVR_STAT_ASM_NETWORK_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ENFORCEMENT_ACTION ON A.action_id=AVR_DIM_ENFORCEMENT_ACTION.action_type  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_GEO_LOCATION "\{AVR_STAT_GEO_LOCATION|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, A.country_code,  A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16,  A.concurrent_sessions,  A.sessions   from AVR_STAT_GEO_LOCATION_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_METHOD "\{AVR_STAT_METHOD|4\} \{select A.aggr_period,  A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, AVR_DIM_METHOD.method_name, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16    from AVR_STAT_METHOD_T A    LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_METHOD ON A.method_crc=AVR_DIM_METHOD.method_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_USER_AGENT "\{AVR_STAT_USER_AGENT|4\} \{select A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, AVR_DIM_USER_AGENT.user_agent_name, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_USER_AGENT_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_USER_AGENT ON A.user_agent_crc=AVR_DIM_USER_AGENT.user_agent_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_VIP "\{AVR_STAT_VIP|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16,  A.concurrent_sessions,  A.sessions   from AVR_STAT_VIP_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ENFORCED_ACL "\{AVR_STAT_ENFORCED_ACL|6\} \{select           aggr_period,     time_stamp,     hits_count,     AVR_DIM_APPLICATION.app_name,      AVR_DIM_ACL_RULE.rule_name,     AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_name,     AVR_DIM_ACL_CONTEXT_INFO.context_info_name,     AVR_DIM_FW_ACL_ACTIONS.action,     AVR_DIM_VLAN.vlan_name,     AVR_DIM_ACL_POLICY.policy_name,     HEX( source_ip ) as source_ip,     source_port,     HEX( dest_ip ) as dest_ip,     dest_port,     AVR_DIM_ACL_SA_TRANS.translate_reason_name,     AVR_DIM_ACL_TRANSLATE_TYPE.translate_type_name,     HEX( self_ip ) as self_ip,     HEX( server_ip ) as server_ip,     source_country_code,     dest_country_code     from AVR_STAT_ENFORCED_ACL_T A      LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc      LEFT JOIN AVR_DIM_ACL_RULE ON A.rule_crc=AVR_DIM_ACL_RULE.rule_crc     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO_TYPE ON A.context_info_type_id=AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_id     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO ON A.context_info_crc=AVR_DIM_ACL_CONTEXT_INFO.context_info_crc     LEFT JOIN AVR_DIM_FW_ACL_ACTIONS ON A.action_id=AVR_DIM_FW_ACL_ACTIONS.action_id     LEFT JOIN AVR_DIM_VLAN ON A.vlan_crc=AVR_DIM_VLAN.vlan_crc     LEFT JOIN AVR_DIM_ACL_POLICY ON A.policy_crc=AVR_DIM_ACL_POLICY.policy_crc       LEFT JOIN AVR_DIM_ACL_SA_TRANS ON A.translate_reason_crc=AVR_DIM_ACL_SA_TRANS.translate_reason_crc     LEFT JOIN AVR_DIM_ACL_TRANSLATE_TYPE ON A.translate_type_id=AVR_DIM_ACL_TRANSLATE_TYPE.translate_type_id where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_STAGING_ACL "\{AVR_STAT_STAGING_ACL|6\} \{select           aggr_period,     time_stamp,     hits_count,     AVR_DIM_APPLICATION.app_name,      AVR_DIM_ACL_RULE.rule_name,     AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_name,     AVR_DIM_ACL_CONTEXT_INFO.context_info_name,     AVR_DIM_FW_ACL_ACTIONS.action,     AVR_DIM_VLAN.vlan_name,     AVR_DIM_ACL_POLICY.policy_name,     HEX( source_ip ) as source_ip,     source_port,     HEX( dest_ip ) as dest_ip,     dest_port,               source_country_code,     dest_country_code     from AVR_STAT_STAGING_ACL_T A      LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc      LEFT JOIN AVR_DIM_ACL_RULE ON A.rule_crc=AVR_DIM_ACL_RULE.rule_crc     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO_TYPE ON A.context_info_type_id=AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_id     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO ON A.context_info_crc=AVR_DIM_ACL_CONTEXT_INFO.context_info_crc     LEFT JOIN AVR_DIM_FW_ACL_ACTIONS ON A.action_id=AVR_DIM_FW_ACL_ACTIONS.action_id     LEFT JOIN AVR_DIM_VLAN ON A.vlan_crc=AVR_DIM_VLAN.vlan_crc     LEFT JOIN AVR_DIM_ACL_POLICY ON A.policy_crc=AVR_DIM_ACL_POLICY.policy_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_TCP "\{AVR_STAT_TCP|5\} \{ select  A.aggr_period, A.time_stamp, A.hits_count, AVR_DIM_APPLICATION.app_name, A.request_side, AVR_DIM_VIP.vip_name, HEX(A.remote_host_ip) as remote_host_ip, HEX(A.subnet) as subnet, AVR_DIM_TCP_NEXTHOP.nexthop_str, AVR_DIM_TCP_USERKEY.user_key, AVR_DIM_PEM_SUBSCRIBER.subscriber_name, AVR_DIM_PEM_SUBSCRIBER_TYPE.subscriber_type_name, AVR_DIM_PEM_TOWER.tower_name, AVR_DIM_RADIO_TYPE.radio_type, A.continent_code, AVR_DIM_TCP_COUNTRY_REGION.country_region, AVR_DIM_TCP_CITY_POSTCODE.city_postcode, A.rtt_count, A.rtt_sum, A.rtt_max, A.rtt_min, A.rtt_var_sum, A.pkts_recv, A.pkts_lost, A.pkts_sent, A.goodput_snd, A.goodput_rcv, A.ds_3whs, A.ds_rwnd, A.ds_retx, A.ds_waitforack, A.ds_closing, A.ds_cwnd, A.ds_nagle, A.ds_sndbuf, A.ds_app, A.ds_ratepace, A.cs_numstarts, A.cs_numendings, A.cs_dursum from AVR_STAT_TCP_T A LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc   LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc    LEFT JOIN AVR_DIM_TCP_NEXTHOP ON A.nexthop_crc=AVR_DIM_TCP_NEXTHOP.nexthop_crc LEFT JOIN AVR_DIM_TCP_USERKEY ON A.user_key_crc=AVR_DIM_TCP_USERKEY.user_key_crc LEFT JOIN AVR_DIM_TCP_CITY_POSTCODE ON A.city_postcode_crc=AVR_DIM_TCP_CITY_POSTCODE.city_postcode_crc LEFT JOIN AVR_DIM_TCP_COUNTRY_REGION ON A.country_region_crc=AVR_DIM_TCP_COUNTRY_REGION.country_region_crc LEFT JOIN AVR_DIM_PEM_SUBSCRIBER ON A.subscriber_name_crc=AVR_DIM_PEM_SUBSCRIBER.subscriber_name_crc LEFT JOIN AVR_DIM_PEM_TOWER ON A.tower_name_crc=AVR_DIM_PEM_TOWER.tower_name_crc LEFT JOIN AVR_DIM_RADIO_TYPE ON A.radio_type_crc=AVR_DIM_RADIO_TYPE.radio_type_crc LEFT JOIN AVR_DIM_PEM_SUBSCRIBER_TYPE ON A.subscriber_id_type=AVR_DIM_PEM_SUBSCRIBER_TYPE.subscriber_type_id  where A.time_stamp IN (<tosendbuckets>)\}"
        }
    }
    set vrs [list "11.6.0" "11.6.1" "11.6.2" "11.6.3" "11.6.4" "11.6.5" "11.6.6"]
    if {[lsearch -exact $vrs $::version] >= 0} {
        array set avrmapping {
            AVR_STAT_DNS_QUERY "\{AVR_STAT_DNS_QUERY|4\} \{ select     A.aggr_period,   A.time_stamp,    A.hits_count, AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name,  AVR_DIM_DNS_QUERY_TYPE.query_type_name, AVR_DIM_DNS_QUERY_NAME.query_name   from AVR_STAT_DNS_QUERY_T A  LEFT JOIN AVR_DIM_DNS_QUERY_TYPE ON A.query_type_id=AVR_DIM_DNS_QUERY_TYPE.query_type_id LEFT JOIN AVR_DIM_DNS_QUERY_NAME ON A.query_name_crc=AVR_DIM_DNS_QUERY_NAME.query_name_crc   LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc   where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_DNS_CLIENT_IP "\{AVR_STAT_DNS_CLIENT_IP|4\} \{ select     A.aggr_period,   A.time_stamp,    A.hits_count, AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name,  AVR_DIM_DNS_QUERY_TYPE.query_type_name, HEX(A.client_ip) as client_ip   from AVR_STAT_DNS_CLIENT_IP_T A  LEFT JOIN AVR_DIM_DNS_QUERY_TYPE ON A.query_type_id=AVR_DIM_DNS_QUERY_TYPE.query_type_id   LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc   where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_BLOCKED "\{AVR_STAT_APM_SWG_BLOCKED|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   ssl_bypass, AVR_DIM_APM_SWG_USERNAME.username_str, AVR_DIM_APM_SWG_URL.url_str,  HEX(A.client_ip) as client_ip, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_BLOCKED_T A   LEFT JOIN AVR_DIM_APM_SWG_USERNAME ON A.username_crc=AVR_DIM_APM_SWG_USERNAME.username_crc LEFT JOIN AVR_DIM_APM_SWG_URL ON A.url_crc=AVR_DIM_APM_SWG_URL.url_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_URL_INFO "\{AVR_STAT_APM_SWG_URL_INFO|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   AVR_DIM_APM_SWG_ACTION.action_str,  ssl_bypass, AVR_DIM_APM_SWG_HOST_NAME.host_name_str, AVR_DIM_APM_SWG_URL.url_str, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_URL_INFO_T A   LEFT JOIN AVR_DIM_APM_SWG_ACTION ON A.action_id=AVR_DIM_APM_SWG_ACTION.action_id LEFT JOIN AVR_DIM_APM_SWG_HOST_NAME ON A.host_name_crc=AVR_DIM_APM_SWG_HOST_NAME.host_name_crc LEFT JOIN AVR_DIM_APM_SWG_URL ON A.url_crc=AVR_DIM_APM_SWG_URL.url_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_USER_INFO "\{AVR_STAT_APM_SWG_USER_INFO|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   AVR_DIM_APM_SWG_ACTION.action_str,  ssl_bypass, AVR_DIM_APM_SWG_USERNAME.username_str,  HEX(A.client_ip) as client_ip, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_USER_INFO_T A   LEFT JOIN AVR_DIM_APM_SWG_ACTION ON A.action_id=AVR_DIM_APM_SWG_ACTION.action_id LEFT JOIN AVR_DIM_APM_SWG_USERNAME ON A.username_crc=AVR_DIM_APM_SWG_USERNAME.username_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_URL "\{AVR_STAT_URL|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  '' as transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, AVR_DIM_URL.url_name, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_URL_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc LEFT JOIN AVR_DIM_URL ON A.url_crc=AVR_DIM_URL.url_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_RESPONSE_CODE "\{AVR_STAT_RESPONSE_CODE|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  '' as transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, AVR_DIM_URL.url_name, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.response_code, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_RESPONSE_CODE_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc LEFT JOIN AVR_DIM_URL ON A.url_crc=AVR_DIM_URL.url_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_CLIENT_IP "\{AVR_STAT_CLIENT_IP|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  '' as transaction_outcome_name, HEX( A.client_ip) as client_ip, HEX(AVR_DIM_CLIENT_SUBNET.subnet_addr) as subnet_addr, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_CLIENT_IP_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc LEFT JOIN AVR_DIM_CLIENT_SUBNET ON A.subnet_crc=AVR_DIM_CLIENT_SUBNET.subnet_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_POOL_MEMBER "\{AVR_STAT_POOL_MEMBER|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, '' as dosl7_attack_id,  '' as transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_POOL_MEMBER_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_ANOMALIES "\{AVR_STAT_ASM_ANOMALIES|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ASM_ANOMALIES.anomaly_type_name, A.new_attacks_count,  A.rejected_requests_count,  A.total_violations    from AVR_STAT_ASM_ANOMALIES_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ASM_ANOMALIES ON A.anomaly_type_id=AVR_DIM_ASM_ANOMALIES.anomaly_type_id  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_HTTP_ATTACK_DATA "\{AVR_STAT_ASM_HTTP_ATTACK_DATA|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, A.action_id,  A.severity_id,   A.protocol_id,  A.attack_types,  AVR_DIM_ASM_HTTP_VIRUS.virus_id,  AVR_DIM_ASM_HTTP_VIRUS.virus_name   from AVR_STAT_ASM_HTTP_ATTACK_DATA_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ASM_HTTP_VIRUS ON A.vip_crc=AVR_DIM_ASM_HTTP_VIRUS.vip_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_HTTP_VIOLATION "\{AVR_STAT_ASM_HTTP_VIOLATION|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ENFORCEMENT_ACTION.action_name, A.severity_id,    AVR_DIM_ASM_REPEV_PROTOCOL.protocol_name, A.attack_types,  AVR_DIM_ASM_HTTP_VIOLATION.violation_name, AVR_DIM_ASM_HTTP_VIRUS.virus_id, AVR_DIM_ASM_HTTP_VIRUS.virus_name   from AVR_STAT_ASM_HTTP_VIOLATION_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ENFORCEMENT_ACTION ON A.action_id=AVR_DIM_ENFORCEMENT_ACTION.action_type   LEFT JOIN AVR_DIM_ASM_REPEV_PROTOCOL ON A.protocol_id=AVR_DIM_ASM_REPEV_PROTOCOL.protocol_id  LEFT JOIN AVR_DIM_ASM_HTTP_VIOLATION ON A.violation_crc=AVR_DIM_ASM_HTTP_VIOLATION.violation_id LEFT JOIN AVR_DIM_ASM_HTTP_VIRUS ON A.vip_crc=AVR_DIM_ASM_HTTP_VIRUS.vip_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_NETWORK "\{AVR_STAT_ASM_NETWORK|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ENFORCEMENT_ACTION.action_name, A.total_request_size   from AVR_STAT_ASM_NETWORK_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ENFORCEMENT_ACTION ON A.action_id=AVR_DIM_ENFORCEMENT_ACTION.action_type  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_GEO_LOCATION "\{AVR_STAT_GEO_LOCATION|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, A.country_code,  A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16,  A.concurrent_sessions,  A.sessions   from AVR_STAT_GEO_LOCATION_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_METHOD "\{AVR_STAT_METHOD|4\} \{select A.aggr_period,  A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, AVR_DIM_METHOD.method_name, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16    from AVR_STAT_METHOD_T A    LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_METHOD ON A.method_crc=AVR_DIM_METHOD.method_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_USER_AGENT "\{AVR_STAT_USER_AGENT|4\} \{select A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, AVR_DIM_USER_AGENT.user_agent_name, A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16   from AVR_STAT_USER_AGENT_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id LEFT JOIN AVR_DIM_USER_AGENT ON A.user_agent_crc=AVR_DIM_USER_AGENT.user_agent_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_VIP "\{AVR_STAT_VIP|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_DOS_L7_PROFILE.profile_name, A.dosl7_attack_id,  AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_name, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  A.latency_hist_1,  A.latency_hist_2,  A.latency_hist_3,  A.latency_hist_4,  A.latency_hist_5,  A.latency_hist_6,  A.latency_hist_7,  A.latency_hist_8,  A.latency_hist_9,  A.latency_hist_10,  A.latency_hist_11,  A.latency_hist_12,  A.latency_hist_13,  A.latency_hist_14,  A.latency_hist_15,  A.latency_hist_16,  A.concurrent_sessions,  A.sessions   from AVR_STAT_VIP_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_DOS_L7_PROFILE ON A.dosl7_profile_crc=AVR_DIM_DOS_L7_PROFILE.dosl7_profile_crc  LEFT JOIN AVR_DIM_TRANSACTION_OUTCOME ON A.transaction_outcome_id=AVR_DIM_TRANSACTION_OUTCOME.transaction_outcome_id  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ENFORCED_ACL "\{AVR_STAT_ENFORCED_ACL|6\} \{select           aggr_period,     time_stamp,     hits_count,     AVR_DIM_APPLICATION.app_name,      AVR_DIM_ACL_RULE.rule_name,     AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_name,     AVR_DIM_ACL_CONTEXT_INFO.context_info_name,     AVR_DIM_FW_ACL_ACTIONS.action,     AVR_DIM_VLAN.vlan_name,     AVR_DIM_ACL_POLICY.policy_name,     HEX( source_ip ) as source_ip,     source_port,     HEX( dest_ip ) as dest_ip,     dest_port,     AVR_DIM_ACL_SA_TRANS.translate_reason_name,     AVR_DIM_ACL_TRANSLATE_TYPE.translate_type_name,     HEX( self_ip ) as self_ip,     HEX( server_ip ) as server_ip,     source_country_code,     dest_country_code     from AVR_STAT_ENFORCED_ACL_T A      LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc      LEFT JOIN AVR_DIM_ACL_RULE ON A.rule_crc=AVR_DIM_ACL_RULE.rule_crc     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO_TYPE ON A.context_info_type_id=AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_id     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO ON A.context_info_crc=AVR_DIM_ACL_CONTEXT_INFO.context_info_crc     LEFT JOIN AVR_DIM_FW_ACL_ACTIONS ON A.action_id=AVR_DIM_FW_ACL_ACTIONS.action_id     LEFT JOIN AVR_DIM_VLAN ON A.vlan_crc=AVR_DIM_VLAN.vlan_crc     LEFT JOIN AVR_DIM_ACL_POLICY ON A.policy_crc=AVR_DIM_ACL_POLICY.policy_crc       LEFT JOIN AVR_DIM_ACL_SA_TRANS ON A.translate_reason_crc=AVR_DIM_ACL_SA_TRANS.translate_reason_crc     LEFT JOIN AVR_DIM_ACL_TRANSLATE_TYPE ON A.translate_type_id=AVR_DIM_ACL_TRANSLATE_TYPE.translate_type_id where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_STAGING_ACL "\{AVR_STAT_STAGING_ACL|6\} \{select           aggr_period,     time_stamp,     hits_count,     AVR_DIM_APPLICATION.app_name,      AVR_DIM_ACL_RULE.rule_name,     AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_name,     AVR_DIM_ACL_CONTEXT_INFO.context_info_name,     AVR_DIM_FW_ACL_ACTIONS.action,     AVR_DIM_VLAN.vlan_name,     AVR_DIM_ACL_POLICY.policy_name,     HEX( source_ip ) as source_ip,     source_port,     HEX( dest_ip ) as dest_ip,     dest_port,               source_country_code,     dest_country_code     from AVR_STAT_STAGING_ACL_T A      LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc      LEFT JOIN AVR_DIM_ACL_RULE ON A.rule_crc=AVR_DIM_ACL_RULE.rule_crc     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO_TYPE ON A.context_info_type_id=AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_id     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO ON A.context_info_crc=AVR_DIM_ACL_CONTEXT_INFO.context_info_crc     LEFT JOIN AVR_DIM_FW_ACL_ACTIONS ON A.action_id=AVR_DIM_FW_ACL_ACTIONS.action_id     LEFT JOIN AVR_DIM_VLAN ON A.vlan_crc=AVR_DIM_VLAN.vlan_crc     LEFT JOIN AVR_DIM_ACL_POLICY ON A.policy_crc=AVR_DIM_ACL_POLICY.policy_crc where A.time_stamp IN (<tosendbuckets>)\}"
        }
    }
    set vrs [list "11.4.0" "11.4.1" "11.4.2" "11.5.0" "11.5.1" "11.5.2" "11.5.3" "11.5.4" "11.5.5" "11.5.6"]
    if {[lsearch -exact $vrs $::version] >= 0} {
        array set avrmapping {
            AVR_STAT_DNS_QUERY "\{AVR_STAT_DNS_QUERY|4\} \{ select     A.aggr_period,   A.time_stamp,    A.hits_count, AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name,  AVR_DIM_DNS_QUERY_TYPE.query_type_name, AVR_DIM_DNS_QUERY_NAME.query_name   from AVR_STAT_DNS_QUERY_T A  LEFT JOIN AVR_DIM_DNS_QUERY_TYPE ON A.query_type_id=AVR_DIM_DNS_QUERY_TYPE.query_type_id LEFT JOIN AVR_DIM_DNS_QUERY_NAME ON A.query_name_crc=AVR_DIM_DNS_QUERY_NAME.query_name_crc   LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc   where A.time_stamp IN (<tosendbuckets>)\}"
             AVR_STAT_DNS_CLIENT_IP "\{AVR_STAT_DNS_CLIENT_IP|4\} \{ select     A.aggr_period,   A.time_stamp,    A.hits_count, AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name,  AVR_DIM_DNS_QUERY_TYPE.query_type_name, HEX(A.client_ip) as client_ip   from AVR_STAT_DNS_CLIENT_IP_T A  LEFT JOIN AVR_DIM_DNS_QUERY_TYPE ON A.query_type_id=AVR_DIM_DNS_QUERY_TYPE.query_type_id   LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc   where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_BLOCKED "\{AVR_STAT_APM_SWG_BLOCKED|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   ssl_bypass, AVR_DIM_APM_SWG_USERNAME.username_str, AVR_DIM_APM_SWG_URL.url_str,  HEX(A.client_ip) as client_ip, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_BLOCKED_T A   LEFT JOIN AVR_DIM_APM_SWG_USERNAME ON A.username_crc=AVR_DIM_APM_SWG_USERNAME.username_crc LEFT JOIN AVR_DIM_APM_SWG_URL ON A.url_crc=AVR_DIM_APM_SWG_URL.url_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_URL_INFO "\{AVR_STAT_APM_SWG_URL_INFO|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   AVR_DIM_APM_SWG_ACTION.action_str,  ssl_bypass, AVR_DIM_APM_SWG_HOST_NAME.host_name_str, AVR_DIM_APM_SWG_URL.url_str, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_URL_INFO_T A   LEFT JOIN AVR_DIM_APM_SWG_ACTION ON A.action_id=AVR_DIM_APM_SWG_ACTION.action_id LEFT JOIN AVR_DIM_APM_SWG_HOST_NAME ON A.host_name_crc=AVR_DIM_APM_SWG_HOST_NAME.host_name_crc LEFT JOIN AVR_DIM_APM_SWG_URL ON A.url_crc=AVR_DIM_APM_SWG_URL.url_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_APM_SWG_USER_INFO "\{AVR_STAT_APM_SWG_USER_INFO|-2\} \{select    A.aggr_period,  A.time_stamp,   A.hits_count,   AVR_DIM_APM_SWG_ACTION.action_str,  ssl_bypass, AVR_DIM_APM_SWG_USERNAME.username_str,  HEX(A.client_ip) as client_ip, AVR_DIM_APM_SWG_CATEGORY.category_full_str, AVR_DIM_APM_SWG_RISK_CLASS.risk_class_str, AVR_DIM_APM_SWG_URL_FILTER.url_filter_full_str, AVR_DIM_APM_SWG_USER_GROUP.user_group_str, AVR_DIM_APM_SWG_APPLICATION.application_name_str, AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_str     from AVR_STAT_APM_SWG_USER_INFO_T A   LEFT JOIN AVR_DIM_APM_SWG_ACTION ON A.action_id=AVR_DIM_APM_SWG_ACTION.action_id LEFT JOIN AVR_DIM_APM_SWG_USERNAME ON A.username_crc=AVR_DIM_APM_SWG_USERNAME.username_crc LEFT JOIN AVR_DIM_APM_SWG_CATEGORY ON A.category_crc=AVR_DIM_APM_SWG_CATEGORY.category_crc  LEFT JOIN AVR_DIM_APM_SWG_RISK_CLASS ON A.risk_class_crc=AVR_DIM_APM_SWG_RISK_CLASS.risk_class_crc LEFT JOIN AVR_DIM_APM_SWG_URL_FILTER ON A.url_filter_crc=AVR_DIM_APM_SWG_URL_FILTER.url_filter_crc LEFT JOIN AVR_DIM_APM_SWG_USER_GROUP ON A.user_group_crc=AVR_DIM_APM_SWG_USER_GROUP.user_group_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION ON A.application_name_crc=AVR_DIM_APM_SWG_APPLICATION.application_name_crc LEFT JOIN AVR_DIM_APM_SWG_APPLICATION_FAMILY ON A.application_family_name_crc=AVR_DIM_APM_SWG_APPLICATION_FAMILY.application_family_name_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_URL "\{AVR_STAT_URL|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, '' as profile_name, '' as dosl7_attack_id,  '' as transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, AVR_DIM_URL.url_name, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  '' as latency_hist_1,  '' as latency_hist_2,  '' as latency_hist_3,  '' as latency_hist_4,  '' as latency_hist_5,  '' as latency_hist_6,  '' as latency_hist_7,  '' as latency_hist_8,  '' as latency_hist_9,  '' as latency_hist_10,  '' as latency_hist_11,  '' as latency_hist_12,  '' as latency_hist_13,  '' as latency_hist_14,  '' as latency_hist_15,  '' as latency_hist_16   from AVR_STAT_URL_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc LEFT JOIN AVR_DIM_URL ON A.url_crc=AVR_DIM_URL.url_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_RESPONSE_CODE "\{AVR_STAT_RESPONSE_CODE|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, '' as profile_name, '' as dosl7_attack_id,  '' as transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, AVR_DIM_URL.url_name, '' as max_tps,  '' as client_latency_hits,  '' as max_client_latency,  '' as client_latency,  '' as max_server_latency,  '' as server_latency, '' as max_request_throughput,  '' as total_request_size,  '' as max_response_throughput,  '' as total_response_size,  A.response_code,  '' as latency_hist_1,  '' as latency_hist_2,  '' as latency_hist_3,  '' as latency_hist_4,  '' as latency_hist_5,  '' as latency_hist_6,  '' as latency_hist_7,  '' as latency_hist_8,  '' as latency_hist_9,  '' as latency_hist_10,  '' as latency_hist_11,  '' as latency_hist_12,  '' as latency_hist_13,  '' as latency_hist_14,  '' as latency_hist_15,  '' as latency_hist_16   from AVR_STAT_RESPONSE_CODE_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc LEFT JOIN AVR_DIM_URL ON A.url_crc=AVR_DIM_URL.url_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_CLIENT_IP "\{AVR_STAT_CLIENT_IP|4\} \{select   A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, '' as profile_name, '' as dosl7_attack_id,  '' as transaction_outcome_name, HEX( A.client_ip) as client_ip, '' as subnet_addr, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size, '' as latency_hist_1,  '' as latency_hist_2,  '' as latency_hist_3,  '' as latency_hist_4,  '' as latency_hist_5,  '' as latency_hist_6,  '' as latency_hist_7,  '' as latency_hist_8,  '' as latency_hist_9,  '' as latency_hist_10,  '' as latency_hist_11,  '' as latency_hist_12,  '' as latency_hist_13,  '' as latency_hist_14,  '' as latency_hist_15,  '' as latency_hist_16   from AVR_STAT_CLIENT_IP_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_POOL_MEMBER "\{AVR_STAT_POOL_MEMBER|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, '' as profile_name, '' as dosl7_attack_id,  '' as transaction_outcome_name, HEX( AVR_DIM_POOL_MEMBER.pool_member_addr) as pool_member_addr, AVR_DIM_POOL_MEMBER.pool_member_port, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,    '' as latency_hist_1,  '' as latency_hist_2,  '' as latency_hist_3,  '' as latency_hist_4,  '' as latency_hist_5,  '' as latency_hist_6,  '' as latency_hist_7,  '' as latency_hist_8,  '' as latency_hist_9,  '' as latency_hist_10,  '' as latency_hist_11,  '' as latency_hist_12,  '' as latency_hist_13,  '' as latency_hist_14,  '' as latency_hist_15,  '' as latency_hist_16   from AVR_STAT_POOL_MEMBER_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_POOL_MEMBER ON A.pool_member_crc=AVR_DIM_POOL_MEMBER.pool_member_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_ANOMALIES "\{AVR_STAT_ASM_ANOMALIES|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ASM_ANOMALIES.anomaly_type_name, A.new_attacks_count,  A.rejected_requests_count,  A.total_violations    from AVR_STAT_ASM_ANOMALIES_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ASM_ANOMALIES ON A.anomaly_type_id=AVR_DIM_ASM_ANOMALIES.anomaly_type_id  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_HTTP_ATTACK_DATA "\{AVR_STAT_ASM_HTTP_ATTACK_DATA|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, A.action_id,  A.severity_id,   A.protocol_id,  A.attack_types,  AVR_DIM_ASM_HTTP_VIRUS.virus_id,  AVR_DIM_ASM_HTTP_VIRUS.virus_name   from AVR_STAT_ASM_HTTP_ATTACK_DATA_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ASM_HTTP_VIRUS ON A.vip_crc=AVR_DIM_ASM_HTTP_VIRUS.vip_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_HTTP_VIOLATION "\{AVR_STAT_ASM_HTTP_VIOLATION|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ENFORCEMENT_ACTION.action_name, A.severity_id,    AVR_DIM_ASM_REPEV_PROTOCOL.protocol_name, A.attack_types,  AVR_DIM_ASM_HTTP_VIOLATION.violation_name, AVR_DIM_ASM_HTTP_VIRUS.virus_id, AVR_DIM_ASM_HTTP_VIRUS.virus_name   from AVR_STAT_ASM_HTTP_VIOLATION_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ENFORCEMENT_ACTION ON A.action_id=AVR_DIM_ENFORCEMENT_ACTION.action_type   LEFT JOIN AVR_DIM_ASM_REPEV_PROTOCOL ON A.protocol_id=AVR_DIM_ASM_REPEV_PROTOCOL.protocol_id  LEFT JOIN AVR_DIM_ASM_HTTP_VIOLATION ON A.violation_crc=AVR_DIM_ASM_HTTP_VIOLATION.violation_id LEFT JOIN AVR_DIM_ASM_HTTP_VIRUS ON A.vip_crc=AVR_DIM_ASM_HTTP_VIRUS.vip_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ASM_NETWORK "\{AVR_STAT_ASM_NETWORK|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, AVR_DIM_ASM_POLICY.asm_policy_name, AVR_DIM_ENFORCEMENT_ACTION.action_name, A.total_request_size   from AVR_STAT_ASM_NETWORK_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_ASM_POLICY ON A.policy_crc=AVR_DIM_ASM_POLICY.asm_policy_crc and A.vip_crc=AVR_DIM_ASM_POLICY.vip_crc LEFT JOIN AVR_DIM_ENFORCEMENT_ACTION ON A.action_id=AVR_DIM_ENFORCEMENT_ACTION.action_type  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_GEO_LOCATION "\{AVR_STAT_GEO_LOCATION|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, '' as profile_name, '' as dosl7_attack_id,  '' as transaction_outcome_name, A.country_code,  A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  '' as latency_hist_1,  '' as latency_hist_2,  '' as latency_hist_3,  '' as latency_hist_4,  '' as latency_hist_5,  '' as latency_hist_6,  '' as latency_hist_7,  '' as latency_hist_8,  '' as latency_hist_9,  '' as latency_hist_10,  '' as latency_hist_11,  '' as latency_hist_12,  '' as latency_hist_13,  '' as latency_hist_14,  '' as latency_hist_15,  '' as latency_hist_16,  A.concurrent_sessions,  A.sessions   from AVR_STAT_GEO_LOCATION_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc   where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_METHOD "\{AVR_STAT_METHOD|4\} \{select A.aggr_period,  A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, '' as profile_name, '' as dosl7_attack_id,  '' as transaction_outcome_name, AVR_DIM_METHOD.method_name, '' as latency_hist_1,  '' as latency_hist_2,  '' as latency_hist_3,  '' as latency_hist_4,  '' as latency_hist_5,  '' as latency_hist_6,  '' as latency_hist_7,  '' as latency_hist_8,  '' as latency_hist_9,  '' as latency_hist_10,  '' as latency_hist_11,  '' as latency_hist_12,  '' as latency_hist_13,  '' as latency_hist_14,  '' as latency_hist_15,  '' as latency_hist_16   from AVR_STAT_METHOD_T A    LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_METHOD ON A.method_crc=AVR_DIM_METHOD.method_crc where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_USER_AGENT "\{AVR_STAT_USER_AGENT|4\} \{select A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, '' as profile_name, '' as dosl7_attack_id,  '' as transaction_outcome_name, AVR_DIM_USER_AGENT.user_agent_name, '' as latency_hist_1,  '' as latency_hist_2,  '' as latency_hist_3,  '' as latency_hist_4,  '' as latency_hist_5,  '' as latency_hist_6,  '' as latency_hist_7,  '' as latency_hist_8,  '' as latency_hist_9,  '' as latency_hist_10,  '' as latency_hist_11,  '' as latency_hist_12,  '' as latency_hist_13,  '' as latency_hist_14,  '' as latency_hist_15,  '' as latency_hist_16      from AVR_STAT_USER_AGENT_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc LEFT JOIN AVR_DIM_USER_AGENT ON A.user_agent_crc=AVR_DIM_USER_AGENT.user_agent_crc  where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_VIP "\{AVR_STAT_VIP|4\} \{select  A.aggr_period, A.time_stamp,  A.hits_count,  AVR_DIM_APPLICATION.app_name, AVR_DIM_VIP.vip_name, '' as profile_name, '' as dosl7_attack_id,  '' as transaction_outcome_name, A.max_tps,  A.client_latency_hits,  A.max_client_latency,  A.client_latency,  A.max_server_latency,  A.server_latency,  A.max_request_throughput,  A.total_request_size,  A.max_response_throughput,  A.total_response_size,  '' as latency_hist_1,  '' as latency_hist_2,  '' as latency_hist_3,  '' as latency_hist_4,  '' as latency_hist_5,  '' as latency_hist_6,  '' as latency_hist_7,  '' as latency_hist_8,  '' as latency_hist_9,  '' as latency_hist_10,  '' as latency_hist_11,  '' as latency_hist_12,  '' as latency_hist_13,  '' as latency_hist_14,  '' as latency_hist_15,  '' as latency_hist_16   ,  A.concurrent_sessions,  A.sessions   from AVR_STAT_VIP_T A  LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc LEFT JOIN AVR_DIM_VIP ON A.vip_crc=AVR_DIM_VIP.vip_crc   where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_ENFORCED_ACL "\{AVR_STAT_ENFORCED_ACL|6\} \{select           aggr_period,     time_stamp,     hits_count,     AVR_DIM_APPLICATION.app_name,      AVR_DIM_ACL_RULE.rule_name,     AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_name,     AVR_DIM_ACL_CONTEXT_INFO.context_info_name,     AVR_DIM_FW_ACL_ACTIONS.action,     AVR_DIM_VLAN.vlan_name,     AVR_DIM_ACL_POLICY.policy_name,     HEX( source_ip ) as source_ip,     source_port,     HEX( dest_ip ) as dest_ip,     dest_port,     AVR_DIM_ACL_SA_TRANS.translate_reason_name,     AVR_DIM_ACL_TRANSLATE_TYPE.translate_type_name,     HEX( self_ip ) as self_ip,     HEX( server_ip ) as server_ip,     source_country_code,     dest_country_code     from AVR_STAT_ENFORCED_ACL_T A      LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc      LEFT JOIN AVR_DIM_ACL_RULE ON A.rule_crc=AVR_DIM_ACL_RULE.rule_crc     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO_TYPE ON A.context_info_type_id=AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_id     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO ON A.context_info_crc=AVR_DIM_ACL_CONTEXT_INFO.context_info_crc     LEFT JOIN AVR_DIM_FW_ACL_ACTIONS ON A.action_id=AVR_DIM_FW_ACL_ACTIONS.action_id     LEFT JOIN AVR_DIM_VLAN ON A.vlan_crc=AVR_DIM_VLAN.vlan_crc     LEFT JOIN AVR_DIM_ACL_POLICY ON A.policy_crc=AVR_DIM_ACL_POLICY.policy_crc       LEFT JOIN AVR_DIM_ACL_SA_TRANS ON A.translate_reason_crc=AVR_DIM_ACL_SA_TRANS.translate_reason_crc     LEFT JOIN AVR_DIM_ACL_TRANSLATE_TYPE ON A.translate_type_id=AVR_DIM_ACL_TRANSLATE_TYPE.translate_type_id where A.time_stamp IN (<tosendbuckets>)\}"
            AVR_STAT_STAGING_ACL "\{AVR_STAT_STAGING_ACL|6\} \{select           aggr_period,     time_stamp,     hits_count,     AVR_DIM_APPLICATION.app_name,      AVR_DIM_ACL_RULE.rule_name,     AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_name,     AVR_DIM_ACL_CONTEXT_INFO.context_info_name,     AVR_DIM_FW_ACL_ACTIONS.action,     AVR_DIM_VLAN.vlan_name,     AVR_DIM_ACL_POLICY.policy_name,     HEX( source_ip ) as source_ip,     source_port,     HEX( dest_ip ) as dest_ip,     dest_port,               source_country_code,     dest_country_code     from AVR_STAT_STAGING_ACL_T A      LEFT JOIN AVR_DIM_APPLICATION ON A.app_crc=AVR_DIM_APPLICATION.app_crc      LEFT JOIN AVR_DIM_ACL_RULE ON A.rule_crc=AVR_DIM_ACL_RULE.rule_crc     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO_TYPE ON A.context_info_type_id=AVR_DIM_ACL_CONTEXT_INFO_TYPE.context_info_type_id     LEFT JOIN AVR_DIM_ACL_CONTEXT_INFO ON A.context_info_crc=AVR_DIM_ACL_CONTEXT_INFO.context_info_crc     LEFT JOIN AVR_DIM_FW_ACL_ACTIONS ON A.action_id=AVR_DIM_FW_ACL_ACTIONS.action_id     LEFT JOIN AVR_DIM_VLAN ON A.vlan_crc=AVR_DIM_VLAN.vlan_crc     LEFT JOIN AVR_DIM_ACL_POLICY ON A.policy_crc=AVR_DIM_ACL_POLICY.policy_crc where A.time_stamp IN (<tosendbuckets>)\}"
        }
    }



    set tmctlcommands ""
    foreach stat $::statistics__customcollectionconfig {
        set command ""
        catch {set command $tmctlmapping($stat)}
        if {$command ne ""} {
            append tmctlcommands "$stat $command "
        }
    }

    set tmctlcommands [string trimright $tmctlcommands " "]
    if {$tmctlcommands eq ""} {
        set tmctlcommands " "
    }

    set avrcommands ""
    foreach stat $::statistics__customcollectionconfig {
        set command ""
        catch {set command $avrmapping($stat)}
        if {$command ne ""} {
            append avrcommands "$command "
        }
    }

    set avrcommands [string trimright $avrcommands " "]
    if {$avrcommands eq ""} {
        set avrcommands " "
    }


    set ::splunkstats_datagroup    {
        source_metrics_to_ignore {
            data "proc_pid_stat.command_line memory_usage_stat.caches_used"
        }
        sessiondbkeys {
            data "session.access.profile session.assigned.resources.na session.assigned.webtop session.client.activex session.client.browscap_info session.client.cpu session.client.js session.client.platform session.client.plugin session.client.type session.client.version session.end session.inactivity_timeout session.logon.last.logonname session.logon.last.result session.logon.last.username session.server.listener.name session.server.network.name session.server.network.port session.server.network.protocol session.state session.stats.bytes.in session.stats.bytes.out session.stats.egress.compressed session.stats.egress.raw session.stats.ingress.compressed session.stats.ingress.raw session.stats.packets.in session.stats.packets.out session.user.agent session.user.clientip session.user.display_sessionid session.user.ip_reputation session.user.ipgeolocation.continent session.user.ipgeolocation.country_code session.user.ipgeolocation.country_name session.user.ipgeolocation.state session.user.starttime session.policy.result session.user.sessiontype session.ui.lang session.assigned.clientip session.check_software.last.hd.state session.check_software.last.av.state"
        }
    }
    if {$::basic__format eq "F5 Risk Engine"} {

        set ::splunkstats_datagroup    {
            source_metrics_to_ignore {
                data "proc_pid_stat.command_line memory_usage_stat.caches_used"
            }
            sessiondbkeys {
                data " "
            }
        }

    }
    append ::splunkstats_datagroup "tmctl_commands { data \"$tmctlcommands\"}"
    append ::splunkstats_datagroup "avr_commands { data \"$avrcommands\"}"









    ########SplunkStats DataGroup End ########


    ########iHealth Script Start ########
    #yeah we could do some substr stuff here but to keep things simple we will do an append
    set ::icall_ihealth "    set username \"${::ihealth__ihealthuser}\"\r\n    set password \"[regsub -all {[$\x22\x5b\x5c\x5d]} ${::ihealth__ihealthpassword} {\\\\&}]\"\r\n    set starttime \"${::ihealth__time}\"\r\n    set schedule \"${::ihealth__schedule}\"\r\n    set dayofweek \"${::ihealth__dayofweek}\"\r\n    set dayofmonth \"${::ihealth__dayofmonth}\"\r\n    set proxy \"${::ihealth__proxy}\"\r\n    set proxyip \"${::ihealth__proxyip}\"\r\n    set proxyport \"${::ihealth__proxyport}\"\r\n    set proxyuser \"${::ihealth__proxyuser}\"\r\n    set proxypassword \"[string map [list "\x24" "\x5c\x24"] ${::ihealth__proxypassword}]\"\r\nset appname ${::app}\r\nset url ${::statistics__splunkdestinationprotocol}://${::statistics__splunkdestinationip}:${::statistics__splunkdestinationport}/services/collector/event\r\nset hostheader $::statistics__splunkdestinationhostheader\r\n    set apikey \"Splunk $::statistics__splunkapikey\"\r\nset appname ${::app}\r\nset facility \"$::basic__facility\"\r\n"
    append ::icall_ihealth    {

        proc fix_tmsh_esc {v} {
            if {([string range $v 0 0] eq {"}) && ([string range $v end end] eq {"})} {
                set v [string range $v 1 end-1]
            }
            set v [string map [list "\x5c\x5c" "_" "\x5c" "" "\x22" "_"] $v]
            return [regsub -all {[\x00-\x08\x0b\x0c\x0e-\x1f\xff]} $v {!}]
        } ; #fix_tmsh_esc
    
        proc get_obj_name {obj} {
            return [expr {[catch {eval tmsh::get_name {$obj}} v] ? "" : [fix_tmsh_esc $v]}]
        } ; #get_obj_name
    
        proc get_fld_value {obj field} {
            return [expr {[eval tmsh::get_field_value {$obj} {$field} v] ? [fix_tmsh_esc $v] : ""}]
        } ; #get_fld_value


        #figure out if we need to run based on DoM or DoW 112734737
        if {($schedule eq "Daily") ||
            (($schedule eq "Weekly") && ($dayofweek eq [clock format [clock seconds] -format %A])) ||
            (($schedule eq "Monthly") && ($dayofmonth eq [clock format [clock seconds] -format %d]))} {

            set deviceinfo [tmsh::get_config sys global-settings hostname]
            foreach {object} $deviceinfo {
                set hostname [get_fld_value $object hostname]
                break
            }

            set deviceinfo ""
            set ::version ""
            catch {set deviceinfo [tmsh::show sys version]}
            regexp {.*Version\s*(\S*)\s*} $deviceinfo junk ::version

            set qkview_file "/shared/tmp/qkview_${hostname}_${appname}_[clock seconds].tar.qkview"
            set cookie_file "/shared/tmp/qkview_${hostname}_${appname}_[clock seconds].cookie"

            if {($::version ne "13.1.1") && ($::version ne "13.1.0") &&
                ($::version ne "13.0.0") && ($::version ne "12.1.2") &&
                ($::version ne "12.1.1") && ($::version ne "12.1.0") &&
                ($::version ne "12.0.0") && ($::version ne "11.6.0") &&
                ($::version ne "11.6.1")} {
                catch {exec /usr/bin/qkview -C -f $qkview_file > /dev/null}
            } else {
                catch {exec /usr/bin/qkview -C -f ../..$qkview_file > /dev/null}
            }


            if {[catch {exec /bin/ls $qkview_file}]} {
                tmsh::log "F5 Analytics: Failed to pull qkview, file:$qkview_file"
            } else {
                set curl_response "fail"

                catch {set curl_response [exec /usr/bin/curl -k <ihealthproxyinfo> --connect-timeout 10 --max-time 50 -H "Content-type: application/json" --user-agent "F5 Analytics Auto Upload" --cookie-jar $cookie_file -o - --data-ascii "{\"user_id\": \"$username\", \"user_secret\": \"$password\"}" https://api.f5.com/auth/pub/sso/login/ihealth-api -sw "%{http_code}\n"]}
                tmsh::log "F5 Analytics: Received $curl_response when logging into iHealth for file: $qkview_file"

                set curl_response "fail"
                catch {set curl_response [exec /usr/bin/curl -k <ihealthproxyinfo> --connect-timeout 10 --max-time 250 -H "Accept: application/vnd.f5.ihealth.api.v1.0+json" --user-agent "F5 Analytics Auto Upload" --cookie $cookie_file --cookie-jar $cookie_file -F qkview=@$qkview_file -F "visible_in_gui=True" -i https://ihealth-api.f5.com/qkview-analyzer/api/qkviews -o - -sw "%{http_code}\n"]}
                tmsh::log "F5 Analytics: Received $curl_response when uploading $qkview_file to iHealth"

                catch {exec /bin/rm -f $qkview_file}
                catch {exec /bin/rm -f $cookie_file}

                regexp {Location: *(\S*)\s} $curl_response junk qkview_location

                if {![catch {open "/shared/tmp/f5_analytics-${appname}-ihealthpickuplocation" "w" "0644"} fp]} {
                    catch {puts $fp $qkview_location}
                }
                catch {close $fp}
            }
        }

    }
    ########iHealth Script End ########

    ########Agent Manager Reg Script Start ########
    #yeah we could do some substr stuff here but to keep things simple we will do an append
    set ::icall_agentmanagerreg     ""
    append ::icall_agentmanagerreg     "    set iappversion \"${iappversion}\"\r\n"
    append ::icall_agentmanagerreg     "    set url \"${::statistics__splunkdestinationprotocol}://${::statistics__splunkdestinationip}:${::statistics__splunkdestinationport}/mgmt/ap/v1/tenants/${::basic__systemtenant}/sources\"\r\n"
    append ::icall_agentmanagerreg     "    set hostnameoverride \"${::basic__hostnameoverride}\"\r\n"
    append ::icall_agentmanagerreg     "    set systemtenant \"${::basic__systemtenant}\"\r\n"
    append ::icall_agentmanagerreg     "    set hostheader \"${::statistics__splunkdestinationhostheader}\"\r\n"
    append ::icall_agentmanagerreg     "    set apikey \"${datareceiverauth}\"\r\n"
    append ::icall_agentmanagerreg     "    set appname ${::app}\r\n"

    append ::icall_agentmanagerreg    {

        proc fix_tmsh_esc {v} {
            if {([string range $v 0 0] eq {"}) && ([string range $v end end] eq {"})} {
                set v [string range $v 1 end-1]
            }
            set v [string map [list "\x5c\x5c" "_" "\x5c" "" "\x22" "_"] $v]
            return [regsub -all {[\x00-\x08\x0b\x0c\x0e-\x1f\xff]} $v {!}]
        } ; #fix_tmsh_esc
    
        proc get_obj_name {obj} {
            return [expr {[catch {eval tmsh::get_name {$obj}} v] ? "" : [fix_tmsh_esc $v]}]
        } ; #get_obj_name
    
        proc get_fld_value {obj field} {
            return [expr {[eval tmsh::get_field_value {$obj} {$field} v] ? [fix_tmsh_esc $v] : ""}]
        } ; #get_fld_value

        set date [clock seconds]
        set ::version ""
        catch {set deviceinfo [tmsh::show sys version]}
        regexp {.*Version\s*(\S*)\s*} $deviceinfo junk ::version

        #hostname override logic 114310721
        if {$hostnameoverride ne ""} {
            set hostname $hostnameoverride
        } else {
            if {![catch {tmsh::get_config sys global-settings hostname} deviceinfo]} {
                foreach {object} $deviceinfo {
                    set hostname [get_fld_value $object hostname]
                    break
                }
            }
        } else {
            set hostname "unknown"
        }

        set device_base_mac ""
        if {![catch {tmsh::get_status sys hardware} deviceinfo]} {
            foreach {object} $deviceinfo {
                set device_base_mac [get_fld_value $object "base-mac"]
                break
            }
        }
        if {$device_base_mac ne ""} {
            set parts [list]
            foreach {macpart} [split $device_base_mac ":"] {
                lappend parts [string range $macpart [expr {[string range $macpart 0 0] eq "0"}] end]
            }
            set device_base_mac [join $parts ":"]
        }

        set mgmtip ""
        if {![catch {tmsh::get_config sys management-ip} deviceinfo]} {
            foreach {object} $deviceinfo {
                set mgmtip [get_obj_name $object]
                if {$mgmtip ne ""} {
                    set mgmtip [lindex [split $mgmtip "/"] 0]
                }
            }
        }


        set deviceinfo [tmsh::get_config net self]
        set addresses ""
        set floatingaddresses ""
        foreach object $deviceinfo {
            set address ""
            regexp {traffic-group[ |\n]*(\S*)} $object junk trafficgroup

            if {$trafficgroup contains "local"} {
                regexp {address[ |\n]*([0-9|.]*)} $object junk address
                # correct for IPv6 as the first address returned 114436217
                if {$address contains "."} {
                    append addresses "\"$address\","
                }
            } else {
                regexp {address[ |\n]*([0-9|.]*)} $object junk address
                # correct for IPv6 as the first address returned 114436217
                if {$address contains "."} {
                    append floatingaddresses "\"$address\","
                }
            }

        }

        set addresses [string trimright $addresses ","]
        set floatingaddresses [string trimright $floatingaddresses ","]


        set postdata ""
        append postdata "{"
        append postdata "  \"sourceInfo\" : {"
        append postdata "    \"tenantId\" : \"$systemtenant\","
        append postdata "    \"sourceId\" : \"$hostname\","
        append postdata "    \"type\" : \"bigip\","
        append postdata "    \"version\" : \"$::version\","
        append postdata "    \"mgmtIpAddress\" : \"$mgmtip\","
        append postdata "    \"selfIpAddresses\" : \[$addresses\],"
        append postdata "    \"floatingIpAddresses\" : \[$floatingaddresses\],"
        append postdata "    \"deviceBaseMac\" : \"$device_base_mac\""
        append postdata "  },"
        append postdata "  \"agentInfo\" : {"
        append postdata "    \"type\" : \"iApp\","
        append postdata "    \"version\" : \"$iappversion\""
        append postdata "  }"
        append postdata "}"


        set curl_response "Fail"
        catch {set curl_response [exec /usr/bin/curl --connect-timeout 10 --max-time 50 -k $url <statsproxyinfo> -H "Host: $hostheader" -H "Content-Type: application/json" -H "$apikey" -X POST -d $postdata -o /shared/tmp/${appname}-agentmanagerregout -0 -sw "%{http_code}\n"]}
        tmsh::log "Agent Manager Registration Response for $appname $date $curl_response"
    }
    ########Agent Manager Reg Script End ########


    ########Splunk HEC tcp log iRule Start ########
    set ::splunk_hec_forwarder_tcp_irule    {
        when RULE_INIT {
            # SOL14544 workaround
            upvar #0 tcl_platform static::tcl_platform
        } ; #end of event RULE_INIT

        when CLIENT_ACCEPTED {
            set buf "\n"
            TCP::collect
        } ; #end of event CLIENT_ACCEPTED

        when CLIENT_DATA {
            set source "bigip.log"
            if {[string length $buf] == 0} { set buf "\n"}

            ##if we want to strip binary data from the message
            #set clean [list]
            #binary scan [TCP::payload] c* chars
            #foreach {c} $chars {
            #    if {($c & 0x80) || ($c == 127) ||
            #        (($c < 32) && ($c != 9) && ($c != 10) && ($c != 13))} {
            #        continue
            #    }
            #    lappend clean $c
            #}
            #append buf [binary format c* $clean]

            ##else just append the full payload to the buffer
            append buf [TCP::payload]


            TCP::payload replace 0 [TCP::payload length] ""
            TCP::collect
            #Note: do NOT call TCP::release here, because that will reset
            #the TCP connection since we don't have a pool.  If we just
            #keep calling TCP:::collect alone we can go on indefinitely
            while {[set dex [string first "\n" $buf]] >= 0} {
                if {[set d2x [string first "\n" $buf [expr {$dex + 1}]]] < 0} {
                    #unsure buf contains a complete message yet
                    break
                }

                #pull first complete message from buf
                set cefmsg [string range $buf [expr {$dex + 1}] [expr {$d2x - 1}]]

                if {[string first "event_source=bigip.adm," $cefmsg] >= 0} {
                    set source "bigip.adm"
                    set cefmsg [string range $cefmsg 23 [string length $cefmsg]]
                }

                if {[string first "event_source=bigip.risk.log," $cefmsg] >= 0} {
                    set source "bigip.risk.log"
                    set cefmsg [string range $cefmsg 28 [string length $cefmsg]]
                }

                if {[set asm [string first "ASM:unit" $cefmsg]] >= 0} {
                    #set source "bigip.asm"
                    set cefmsg [string range $cefmsg $asm [string length $cefmsg]]
                }

                set buf [string range $buf [expr {$d2x + 1}] end]

                set hslpool [HSL::open -proto TCP -pool "<hslpool>"]
                regsub -all "=\"" $cefmsg "\":\"" msg
                regsub -all "\"," $msg "\",\"" msg
                set msg "<bofdata><bordata>\{\"time\":[clock seconds]<index>,\"host\":\"<hostname>\",\"source\":\"$source\",\"sourcetype\":\"f5:bigip:log:json\",<eventformat_start>\"bigip_version\":\"$static::tcl_platform(osVersion)\",\"device_base_mac\":\"<device_base_mac>\",\"devicegroup\":\"<devicegroup>\",\"facility\":\"<facility>\",\"${msg}<eventformat_end>\}<eordata><eofdata>"

                set fullPOST "POST <datareceiverurl> HTTP/1.1\r\n"
                append fullPOST "Host: <hechost>\r\n"
                append fullPOST "Accept: */*\r\nUser-Agent: BigIP\r\n"
                append fullPOST "Content-Type: application/json\r\n"
                if {"<datareceiverauth>" ne ""} {
                    append fullPOST "<datareceiverauth>\r\n"
                }
                append fullPOST "Content-Length: [string length $msg]\r\n\r\n"
                append fullPOST $msg

                catch {HSL::send $hslpool $fullPOST}
            }

            #any trailing partial message stays in buf until next packet
            #arrives or incoming TCP connection is closed
        } ; #end of event CLIENT_DATA

        when CLIENT_CLOSED {
            #deal with final message in buf
            if {[set dex [string first "\n" $buf]] >= 1} {

                if {[string first "event_source=bigip.risk.log," $buf] >= 0} {
                    set source "bigip.risk.log"
                    set buf [string range $buf 28 [string length $buf]]
                }

                if {[set asm [string first "ASM:unit" $buf]] >= 0} {
                    #set source "bigip.asm"
                    set buf [string range $buf $asm [string length $buf]]
                }

                set hslpool [HSL::open -proto TCP -pool "<hslpool>"]
                regsub -all "=\"" $buf "\":\"" msg
                regsub -all "\"," $msg "\",\"" msg
                set msg "<bofdata><bordata>\{\"time\":[clock seconds]<index>,\"host\":\"<hostname>\",\"source\":\"bigip.log\",\"sourcetype\":\"f5:bigip:log:json\",<eventformat_start>\"bigip_version\":\"$static::tcl_platform(osVersion)\",\"device_base_mac\":\"<device_base_mac>\",\"devicegroup\":\"<devicegroup>\",\"facility\":\"<facility>\",\"${msg}<eventformat_end>\}<eordata><eofdata>"


                set fullPOST "POST <datareceiverurl> HTTP/1.1\r\n"
                append fullPOST "Host: <hechost>\r\n"
                append fullPOST "Accept: */*\r\nUser-Agent: BigIP\r\n"
                append fullPOST "Content-Type: application/json\r\n"
                if {"<datareceiverauth>" ne ""} {
                    append fullPOST "<datareceiverauth>\r\n"
                }
                append fullPOST "Content-Length: [string length $msg]\r\n\r\n"
                append fullPOST $msg

                catch {HSL::send $hslpool $fullPOST}
            }
        } ; #end of event CLIENT_CLOSED
    }
    ########Splunk HEC tcp log iRule END ########
    regsub -all "\\\\" $::splunk_hec_forwarder_tcp_irule "\\\\\\\\" ::splunk_hec_forwarder_tcp_irule
    regsub -all {\$} $::splunk_hec_forwarder_tcp_irule "\\\\$" ::splunk_hec_forwarder_tcp_irule

    ########Splunk HEC adm log iRule Start ########
    set ::splunk_hec_forwarder_adm_irule    {
        when RULE_INIT {
            # SOL14544 workaround
            upvar #0 tcl_platform static::tcl_platform
        } ; #end of event RULE_INIT

        when CLIENT_ACCEPTED {
            set buf ""
            TCP::collect
        } ; #end of event CLIENT_ACCEPTED

        when CLIENT_DATA {
            set source "bigip.adm"
            append buf [TCP::payload]


            TCP::payload replace 0 [TCP::payload length] ""
            TCP::collect
            #Note: do NOT call TCP::release here, because that will reset
            #the TCP connection since we don't have a pool.  If we just
            #keep calling TCP:::collect alone we can go on indefinitely
            while {[set dex [string first "asyncMsg" $buf]] >= 0} {
                if {[set d2x [string first "\}\"\}\}\}\}\]" [string range $buf $dex end]]] < 0} {
                    #unsure buf contains a complete message yet
                    break
                }
                set d2x [expr {$d2x + $dex - 5}]


                #pull first complete message from buf
                set cefmsg [string range $buf [expr {$dex}] [expr {$d2x}]]
                set time [clock seconds]

                set junk ""
                set groupid ""
                set stats ""

                set statpos [expr {[string first "stats\\\": \[" $cefmsg] + 10}]

                regexp {\\"group_id\\": \\"(.*)\\",.*\\"stats\\": \[(.*)} [string range $cefmsg 0 $statpos] junk groupid
                unset junk

                set stats [string range $cefmsg $statpos end]


                regsub -all {\\\", \\\"} $stats {\"|\"} stats
                regsub -all " " $stats "" stats

                set stats [split $stats "|"]

                set msg ""
                foreach stat $stats {
                    set vs ""
                    set metricname ""
                    set metricval ""
                    set junk ""
                    regexp {vs\.(.*)\.(sig\..*|anomaly\..*|base\..*|info\..*|threshold\..*|):\[(.*)\]} $stat junk vs metricname metricval
                    unset junk
                    if {($vs ne "") && ($metricname ne "") && ($metricval ne "")} {
                        set metricvals [split $metricval ","]
                        set v 0
                        set metricval ""
                        foreach val $metricvals {
                            append metricval ",\"metric_v$v\":\"$val\""
                            incr v
                        }
                        append msg "<bofdata><bordata>\{\"time\":$time<index>,\"host\":\"<hostname>\",\"source\":\"$source\",\"sourcetype\":\"f5:bigip:log:json\",<eventformat_start>\"bigip_version\":\"$static::tcl_platform(osVersion)\",\"device_base_mac\":\"<device_base_mac>\",\"devicegroup\":\"<devicegroup>\",\"facility\":\"<facility>\",\"groupid\":\"$groupid\",\"virtual_name\":\"$vs\",\"metric_name\":\"$metricname\"$metricval<eventformat_end>\}<eordata><eofdata>\n"
                    }
                }

                set buf "[string range $buf [expr {$d2x + 13}] end]"

                set hslpool [HSL::open -proto TCP -pool "<hslpool>"]
                if {$msg ne ""} {
                    set fullPOST "POST <datareceiverurl> HTTP/1.1\r\n"
                    append fullPOST "Host: <hechost>\r\n"
                    append fullPOST "Accept: */*\r\nUser-Agent: BigIP\r\n"
                    append fullPOST "Content-Type: application/json\r\n"
                    if {"<datareceiverauth>" ne ""} {
                        append fullPOST "<datareceiverauth>\r\n"
                    }
                    append fullPOST "Content-Length: [string length $msg]\r\n\r\n"
                    append fullPOST $msg

                    catch {HSL::send $hslpool $fullPOST}
                }
            }

            #any trailing partial message stays in buf until next packet
            #arrives or incoming TCP connection is closed
        } ; #end of event CLIENT_DATA

        when CLIENT_CLOSED {
            #deal with final message in buf
            if {[set dex [string first "asyncMsg" $buf]] >= 1} {

                set hslpool [HSL::open -proto TCP -pool "<hslpool>"]

                set time [clock seconds]

                set junk ""
                set groupid ""
                set stats ""
                set junk ""
                regexp {\\"group_id\\": \\"(.*)\\",.*\\"stats\\": \[(.*)} $cefmsg junk groupid stats
                unset junk

                regsub -all {\\\", \\\"} $stats {\"|\"} stats
                regsub -all " " $stats "" stats

                set stats [split $stats "|"]

                set msg ""
                foreach stat $stats {
                    set vs ""
                    set metricname ""
                    set metricval ""
                    set junk ""
                    regexp {vs\.(.*)\.(sig\..*|anomaly\..*|base\..*|info\..*|threshold\..*|):\[(.*)\]} $stat junk vs metricname metricval
                    unset junk
                    if {($vs ne "") && ($metricname ne "") && ($metricval ne "")} {
                        set metricvals [split $metricval ","]
                        set v 0
                        set metricval ""
                        foreach val $metricvals {
                            append metricval ",\"metric_v$v\":\"$val\""
                            incr v
                        }
                        append msg "<bofdata><bordata>\{\"time\":$time<index>,\"host\":\"<hostname>\",\"source\":\"$source\",\"sourcetype\":\"f5:bigip:log:json\",<eventformat_start>\"bigip_version\":\"$static::tcl_platform(osVersion)\",\"device_base_mac\":\"<device_base_mac>\",\"devicegroup\":\"<devicegroup>\",\"facility\":\"<facility>\",\"groupid\":\"$groupid\",\"virtual_name\":\"$vs\",\"metric_name\":\"$metricname\"$metricval<eventformat_end>\}<eordata><eofdata>\n"
                    }
                }
                if {$msg ne ""} {
                    set fullPOST "POST <datareceiverurl> HTTP/1.1\r\n"
                    append fullPOST "Host: <hechost>\r\n"
                    append fullPOST "Accept: */*\r\nUser-Agent: BigIP\r\n"
                    append fullPOST "Content-Type: application/json\r\n"
                    if {"<datareceiverauth>" ne ""} {
                        append fullPOST "<datareceiverauth>\r\n"
                    }
                    append fullPOST "Content-Length: [string length $msg]\r\n\r\n"
                    append fullPOST $msg

                    catch {HSL::send $hslpool $fullPOST}
                }
            }
        } ; #end of event CLIENT_CLOSED
    }
    ########Splunk HEC adm log iRule END ########
    regsub -all "\\\\" $::splunk_hec_forwarder_adm_irule "\\\\\\\\" ::splunk_hec_forwarder_adm_irule
    regsub -all {\$} $::splunk_hec_forwarder_adm_irule "\\\\$" ::splunk_hec_forwarder_adm_irule

    ########Splunk HEC syslog log iRule Start ########
    set ::splunk_hec_forwarder_udp_syslog_irule    {
        when RULE_INIT {
            # SOL14544 workaround
            upvar #0 tcl_platform static::tcl_platform
        } ; #end of event RULE_INIT


        when CLIENT_DATA {
            ### !!!!WARNING!!!! Do not log in the rule or it will loop and your system will go down"""
            set hslpool [HSL::open -proto TCP -pool "<hslpool>"]
            regsub -all "\"" [UDP::payload] "\\\"" msg
            regsub -all "\n" $msg "" msg

            set msg "<bofdata><bordata>\{\"time\":[clock seconds]<index>,\"host\":\"<hostname>\",\"source\":\"bigip.syslog\",\"sourcetype\":\"f5:bigip:syslog:json\",<eventformat_start>\"bigip_version\":\"$static::tcl_platform(osVersion)\",\"device_base_mac\":\"<device_base_mac>\",\"devicegroup\":\"<devicegroup>\",\"facility\":\"<facility>\",\"syslog_message\":\"${msg}\"<eventformat_end>\}<eordata><eofdata>"

            set fullPOST "POST <datareceiverurl> HTTP/1.1\r\n"
            append fullPOST "Host: <hechost>\r\n"
            append fullPOST "Accept: */*\r\nUser-Agent: BigIP\r\n"
            append fullPOST "Content-Type: application/json\r\n"
            if {"<datareceiverauth>" ne ""} {
                append fullPOST "<datareceiverauth>\r\n"
            }
            append fullPOST "Content-Length: [string length $msg]\r\n\r\n"
            append fullPOST $msg

            catch {HSL::send $hslpool $fullPOST}

        } ; #end of event CLIENT_DATA

    }
    ########Splunk HEC syslog log iRule END ########
    regsub -all "\\\\" $::splunk_hec_forwarder_udp_syslog_irule "\\\\\\\\" ::splunk_hec_forwarder_udp_syslog_irule
    regsub -all {\$} $::splunk_hec_forwarder_udp_syslog_irule "\\\\$" ::splunk_hec_forwarder_udp_syslog_irule


    ########Splunk HEC snmptrap iRule Start ########
    set ::splunk_hec_forwarder_udp_snmptrap_irule    {
        when RULE_INIT {
            # SOL14544 workaround
            upvar #0 tcl_platform static::tcl_platform
            # array with the implicit tags definitions
            array set static::tags {
                 02 { INTEGER          forward int}
                 04 { OCTETSTRING      forward string}
                 05 { NULL         skip {}}
                 06 { {OBJECT IDENTIFIER}  forward oid}
                 30 { SEQUENCE         count {}}
                 40 { NetworkAddress       forward address}
                 41 { Counter32        forward {}}
                 43 { TimeTicks        time {}}
                 a7 { SNMPv2-Trap      skip {}}
            }
        } ; #end of event RULE_INIT

        when CLIENT_DATA {
            binary scan [UDP::payload] H* raw

            set pos 0
            set seq 0
            set pair 0

            while {$pos < [string length $raw]} {
                set tag [string range $raw $pos [expr {$pos + 1}]]
                if {![catch {set tagInfo $static::tags($tag)}]} {
                    set type [lindex $tagInfo 0]
                    set action [lindex $tagInfo 1]
                    set decode [lindex $tagInfo 2]

                    #let's figure out the length, we need to chomp more data
                    set pos [expr {$pos + 2}]
                    set tag [string range $raw $pos [expr $pos + 1]]
                    set pos [expr {$pos + 2}]
                    set length [scan $tag %x]
                    if {$length > 127} {
                        set tag [string range $raw $pos [expr {$pos + (($length - 128) * 2) - 1}]]
                        set pos [expr {$pos + (($length - 128) * 2)}]
                        set length [scan $tag %x]
                    }
                    set data [string range $raw $pos [expr {$pos + ($length * 2) - 1}]]
                    if {$action eq "count"} { incr seq }
                    if {($action eq "forward") && ($seq > 3) && ($data ne "2b06010201010300")} {
                        incr pair
                        switch $decode {
                            oid     {
                                    set datapos 2
                                    set newdata "1.3"
                                    set getlast ""
                                    while {$datapos < [string length $data]} {
                                        set newvalue ""
                                        set chomp [string range $data $datapos [expr {$datapos + 1}]]
                                        set value [scan $chomp %x]
                                        while {$value > 127} {
                                            binary scan [format %c [expr {$value - 128}]] B* binaryfmt
                                            append newvalue [string range $binaryfmt 1 end]
                                            set datapos [expr {$datapos + 2}]
                                            set chomp [string range $data $datapos [expr {$datapos + 1}]]
                                            set value [scan $chomp %x]
                                            set getlast 1
                                        }
                                        if {$getlast == 1} {
                                            binary scan [format %c $value] B* binaryfmt
                                            append newvalue [string range $binaryfmt 1 end]
                                            set value 0
                                            foreach i [split $newvalue {}] {
                                                set value [expr {$value * 2 + $i}]
                                            }
                                            set getlast ""
                                        }
                                        append newdata ".$value"
                                        set datapos [expr {$datapos + 2}]
                                    }
                                    set data $newdata
                                }
                            string     {
                                    set data [binary format H* $data]
                                    regsub -all "\"" $data "\\\"" data
                                }
                            int     {set data [scan $data %x]}
                        }
                        if {$pair % 2} {
                            append msg "\"$data\":"
                        } else {
                            append msg "\"$data\","
                        }
                    }
                    if {($action ne "skip") && ($action ne "count")} {
                        set pos [expr {$pos + ($length * 2)}]
                    }
                } else {
                    incr pos 2
                }
            }
            set msg [string trimright $msg ","]
            set hslpool [HSL::open -proto TCP -pool "<hslpool>"]
            set msg "<bofdata><bordata>\{\"time\":[clock seconds]<index>,\"host\":\"<hostname>\",\"source\":\"bigip.snmptrap\",\"sourcetype\":\"f5:bigip:snmp:json\",<eventformat_start>\"bigip_version\":\"$static::tcl_platform(osVersion)\",\"device_base_mac\":\"<device_base_mac>\",\"devicegroup\":\"<devicegroup>\",\"facility\":\"<facility>\",${msg}<eventformat_end>\}<eordata><eofdata>"

            set fullPOST "POST <datareceiverurl> HTTP/1.1\r\n"
            append fullPOST "Host: <hechost>\r\n"
            append fullPOST "Accept: */*\r\nUser-Agent: BigIP\r\n"
            append fullPOST "Content-Type: application/json\r\n"
            if {"<datareceiverauth>" ne ""} {
                append fullPOST "<datareceiverauth>\r\n"
            }
            append fullPOST "Content-Length: [string length $msg]\r\n\r\n"
            append fullPOST $msg

            catch {HSL::send $hslpool $fullPOST}
        } ; #end of event CLIENT_DATA
    }
    ########Splunk HEC snmptrap iRule END ########
    regsub -all "\\\\" $::splunk_hec_forwarder_udp_snmptrap_irule "\\\\\\\\" ::splunk_hec_forwarder_udp_snmptrap_irule
    regsub -all {\$} $::splunk_hec_forwarder_udp_snmptrap_irule "\\\\$" ::splunk_hec_forwarder_udp_snmptrap_irule

    ########Splunk session table iRule Start ########
    set ::splunk_session_table_irule    {
        when HTTP_REQUEST {
            #we could do some fancy stuff with passing what table to pull but we want to lock it down for security reasons
            set output ""
            set table "AVR_STAT_SSLI_DOMAIN"
            foreach key [table keys -subtable $table] {
                set value [table lookup -notouch -subtable $table $key]
                if {$value > -1} {
                    #account for first incr setting the value to 0 not 1
                    incr value
                    append output "${table}|${value}|${key}\n"
                    table incr -notouch -subtable $table $key [expr {0 - $value}]
                }
            }
            HTTP::respond 200 content $output
        }
    }
    ########Splunk session table iRule END ########
    regsub -all "\\\\" $::splunk_session_table_irule "\\\\\\\\" ::splunk_session_table_irule
    regsub -all {\$} $::splunk_session_table_irule "\\\\$" ::splunk_session_table_irule

    ##########################################################################################################################################################################################################################################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################
    ############################################################################################################################################################# START START  Risk Engine Team Code  START START ############################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################

    ########Risk Engine Log iRule Start ########
    set ::risk_engine_log_irule    {
        when RULE_INIT {
            # SOL14544 workaround
            upvar #0 tcl_platform static::tcl_platform
        }
        when HTTP_REQUEST {
            # DevCentral specific - Start (closed by default)
            #if {[string tolower [HTTP::path]] starts_with "/monitors/"} {return}
            # DevCentral specific - End

            set http_request_time [clock clicks -milliseconds]
            if {[class match [string tolower [HTTP::path]] contains "<extdatagroup>"]} {
                return
            }

            set xhr false
            if {[HTTP::header "X-Requested-With" ] equals "XMLHttpRequest"} {
                set xhr true
            }

            # alert_guid will be filled assuming integration with WebSafe was properly done and cookie name was set to "kubdum" (or the iRule was synchronized according to the integration settings).
            set alert_guid ""
            if {[HTTP::cookie exists "kubdum"]} {
                set alert_guid [HTTP::cookie value "kubdum"]
            }

            set deviceCookieExists "0"
            if {[HTTP::cookie exists "dcid"]} {
                set dcid [HTTP::cookie value "dcid"]
                set deviceCookieExists "1"
            } else {
                set dcid "$http_request_time-[expr { int(100000000 * rand()) }]"
            }

            set pvid "$http_request_time-[expr { int(100000000 * rand()) }]"

            set RE {[][{};#\\\$\r\n\t\"\u0080-\uffff]}
            set substitution {[format \\\\u%04x [scan "\\&" %c]]}

            set client_addr [IP::client_addr]

            set pr_dcid [subst [string map {\n {\\u000a}} [regsub -all $RE $dcid $substitution]]]
            set pr_xff [subst [string map {\n {\\u000a}} [regsub -all $RE [HTTP::header X-Forwarded-For] $substitution]]]
            set pr_path [subst [string map {\n {\\u000a}} [regsub -all $RE [URI::decode [HTTP::path]] $substitution]]]
            set pr_query [subst [string map {\n {\\u000a}} [regsub -all $RE [URI::decode [HTTP::query]] $substitution]]]
            set pr_ua [subst [string map {\n {\\u000a}} [regsub -all $RE [HTTP::header User-Agent] $substitution]]]
            set pr_ref [subst [string map {\n {\\u000a}} [regsub -all $RE [URI::decode [HTTP::header Referer]] $substitution]]]
            set pr_content_type [subst [string map {\n {\\u000a}} [regsub -all $RE [HTTP::header Content-Type] $substitution]]]
            set pr_accept_language [subst [string map {\n {\\u000a}} [regsub -all $RE [HTTP::header Accept-Language] $substitution]]]
            set pr_accept_header [subst [string map {\n {\\u000a}} [regsub -all $RE [HTTP::header Accept] $substitution]]]
            set pr_http_method [subst [string map {\n {\\u000a}} [regsub -all $RE [HTTP::method] $substitution]]]
            set pr_host [subst [string map {\n {\\u000a}} [regsub -all $RE [HTTP::host] $substitution]]]
            set pr_virtual_name [subst [string map {\n {\\u000a}} [regsub -all $RE [virtual name] $substitution]]]

            set current_geolocation ""
            if {[catch { set current_geolocation [whereis $client_addr] } ]} {
                set current_geolocation "Not Available"
            }

            set ip_reputation ""
            if {[catch { set ip_reputation [IP::reputation $client_addr] } ]} {
                set ip_reputation "Not Available"
            }

            set current_xff_geolocation ""
            set xff_reputation ""
            if {[HTTP::header exists X-Forwarded-For]}
            {
                if {[catch { set current_xff_geolocation [whereis $pr_xff] } ]} {
                    set current_xff_geolocation "Not Available"
                }

                if {[catch { set xff_reputation [IP::reputation $pr_xff] } ]} {
                    set xff_reputation "Not Available"
                }
            }

            set user_data_ext "\{\}"

            set msg "<bofdata><bordata>\{\"time\":$http_request_time,\"host\":\"<hostname>\",\"source\":\"bigip.bbbbbbbbbbb.log.pv\",\"sourcetype\":\"f5:bigip:log:json\",<eventformat_start>\"device_base_mac\":\"<device_base_mac>\",\"devicegroup\":\"<devicegroup>\",\"facility\":\"<facility>\",\"event_type\":\"PV\",\"ver\":1.1,\"VS\":\"$pr_virtual_name\",\"pvid\":\"$pvid\",\"client_addr\":\"$client_addr\",\"DCID\":\"$pr_dcid\",\"xff\":\"$pr_xff\",\"user-agent\":\"$pr_ua\",\"referer\":\"$pr_ref\",\"http_host\":\"$pr_host\",\"path\":\"$pr_path\",\"query\":\"$pr_query\",\"geolocation\":\"$current_geolocation\",\"xff_geolocation\":\"$current_xff_geolocation\",\"http_method\":\"$pr_http_method\",\"xhr\":\"$xhr\",\"header_accept\":\"$pr_accept_header\",\"accept_language\":\"$pr_accept_language\",\"content_type\":\"$pr_content_type\",\"alert_guid\":\"$alert_guid\",\"ip_reputation\":\"$ip_reputation\",\"xff_reputation\":\"$xff_reputation\"<eventformat_end>\}<eordata><eofdata>\n"

            set fullPOST "POST <datareceiverurl> HTTP/1.1\r\n"
            append fullPOST "Host: <hechost>\r\n"
            append fullPOST "Accept: */*\r\nUser-Agent: BigIP\r\n"
            append fullPOST "Content-Type: application/json\r\n"
            if {"<datareceiverauth>" ne ""} {
                append fullPOST "<datareceiverauth>\r\n"
            }
            append fullPOST "Content-Length: [string length $msg]\r\n\r\n"
            append fullPOST $msg

            catch {HSL::send [HSL::open <pool> ] $<datatosend>}
        }


        when HTTP_RESPONSE {
            if {[info exists deviceCookieExists] && ($deviceCookieExists eq "0")} {
                HTTP::cookie insert name "dcid" value $dcid
                HTTP::cookie expires "dcid" 7776000 relative
                unset deviceCookieExists
            }

            if {[info exists pvid] && ($pvid ne "")} {
                HTTP::cookie insert name "pvid" value $pvid
                HTTP::cookie expires "pvid" 300 relative
            }
        }
    }
    ########Risk Engine Log iRule END ########
    regsub -all "\\\\" $::risk_engine_log_irule "\\\\\\\\" ::risk_engine_log_irule
    regsub -all {\$} $::risk_engine_log_irule "\\\\$" ::risk_engine_log_irule

    ########Risk Engine Login iRule Start ########
    set ::risk_engine_login_irule    {
        when RULE_INIT {
            # SOL14544 workaround
            upvar #0 tcl_platform static::tcl_platform
        }
        when HTTP_REQUEST {
            set loginrequest 0

            ##lookup class data and set input data
            if {[set risk_matchstring "[class match -value "[virtual name]|[string tolower [HTTP::path]]" equals <datagroup>]"] ne ""} {
                set risk_matchstring [split $risk_matchstring "|"]
                set risk_login_method [lindex $risk_matchstring 0]
                set risk_login_form_username [lindex $risk_matchstring 1]
                set risk_login_validation [lindex $risk_matchstring 2]
                set risk_login_validation_string [lindex $risk_matchstring 3]
                set risk_login_validation_value [lindex $risk_matchstring 4]


                #"HTML - Form", "HTML - Basic Auth", "HTML - Digest"

                    if {($risk_login_method equals "HTML - Form") &&
                                            ([HTTP::method] equals "POST")} {
                        set loginrequest 1
                        HTTP::collect [HTTP::header Content-Length]
                    }
            }
        }

        when HTTP_REQUEST_DATA {
            if {[info exists loginrequest] && $loginrequest} {
                set RE {[][{};#\\\$\r\n\t\"\u0080-\uffff]}
                set substitution {[format \\\\u%04x [scan "\\&" %c]]}

                set http_request_time [clock clicks -milliseconds]
                set pr_path [subst [string map {\n {\\u000a}} [regsub -all $RE [URI::decode [HTTP::path]] $substitution]]]

                set username ""
                if {$risk_login_method equals "HTML - Form"} {
                    set body         "?[HTTP::payload]"
                    set username    [string trim [URI::decode [URI::query $body $risk_login_form_username]]]
                    unset body

                }

                set laid "la_$http_request_time-[expr { int(1000000 * rand()) }]"

                set login_request_data ""
                set pvid ""
                set pr_pvid ""

                if {[HTTP::cookie exists "pvid"] && ([HTTP::cookie value "pvid"] ne "")} {
                    set pvid [HTTP::cookie value "pvid"]
                    set pr_pvid [subst [string map {\n {\\u000a}} [regsub -all $RE $pvid $substitution]]]
                }

                set deviceCookieExists "0"
                if {[HTTP::cookie exists "dcid"]} {
                    set dcid [HTTP::cookie value "dcid"]
                    set deviceCookieExists "1"
                } else {
                    set dcid "$http_request_time-[expr { int(100000000 * rand()) }]"
                }

                set client_addr [IP::client_addr]

                set pr_dcid [subst [string map {\n {\\u000a}} [regsub -all $RE $dcid $substitution]]]
                set pr_username [subst [string map {\n {\\u000a}} [regsub -all $RE $username $substitution]]]
                set pr_xff [subst [string map {\n {\\u000a}} [regsub -all $RE [HTTP::header X-Forwarded-For] $substitution]]]
                set pr_ua [subst [string map {\n {\\u000a}} [regsub -all $RE [HTTP::header User-Agent] $substitution]]]
                set pr_ref [subst [string map {\n {\\u000a}} [regsub -all $RE [URI::decode [HTTP::header Referer]] $substitution]]]
                set pr_virtual_name [subst [string map {\n {\\u000a}} [regsub -all $RE [virtual name] $substitution]]]
                set pr_path [subst [string map {\n {\\u000a}} [regsub -all $RE [URI::decode [HTTP::path]] $substitution]]]
                set pr_query [subst [string map {\n {\\u000a}} [regsub -all $RE [URI::decode [HTTP::query]] $substitution]]]
                set pr_host [subst [string map {\n {\\u000a}} [regsub -all $RE [HTTP::host] $substitution]]]

            set current_geolocation ""
            if {[catch { set current_geolocation [whereis $client_addr] } ]} {
                set current_geolocation "Not Available"
            }

            set ip_reputation ""
            if {[catch { set ip_reputation [IP::reputation $client_addr] } ]} {
                set ip_reputation "Not Available"
            }

            set current_xff_geolocation ""
            set xff_reputation ""
            if {[HTTP::header exists X-Forwarded-For]}
            {
                if {[catch { set current_xff_geolocation [whereis $pr_xff] } ]} {
                    set current_xff_geolocation "Not Available"
                }

                if {[catch { set xff_reputation [IP::reputation $pr_xff] } ]} {
                    set xff_reputation "Not Available"
                }
            }

            set user_data_ext "\{\}"

                set login_request_data ", \"pvid\":\"$pr_pvid\",\"client_addr\":\"$client_addr\",\"DCID\":\"$pr_dcid\",\"xff\":\"$pr_xff\",\"user-agent\":\"$pr_ua\",\"path\":\"$pr_path\",\"referer\":\"$pr_ref\",\"http_host\":\"$pr_host\",\"query\":\"$pr_query\",\"geolocation\":\"$current_geolocation\",\"xff_geolocation\":\"$current_xff_geolocation\",\"ip_reputation\":\"$ip_reputation\",\"xff_reputation\":\"$xff_reputation\""

                HTTP::release
            }
        }

        when HTTP_RESPONSE {
          if {[info exists laid] && ($laid ne "")} {

            if {[info exists deviceCookieExists] && ($deviceCookieExists eq "0")} {
              HTTP::cookie insert name "dcid" value $dcid
              HTTP::cookie expires "dcid" 7776000 relative
              unset deviceCookieExists
            }

            set login_result "NA"


            if {[info exists risk_login_validation] &&
                    ($risk_login_validation eq "Cookie Name") &&
                        [info exists risk_login_validation_string] &&
                            ($risk_login_validation_string ne "")} {
                if {[HTTP::cookie exists $risk_login_validation_string]} {
                    set login_result "PASS"
                } else {
                    set login_result "FAIL"
                }
            }

            if {[info exists risk_login_validation] &&
                    ($risk_login_validation eq "Cookie Name-Value") &&
                        [info exists risk_login_validation_string] &&
                            ($risk_login_validation_string ne "")} {
                if {[HTTP::cookie value $risk_login_validation_string] eq $risk_login_validation_value} {
                    set login_result "PASS"
                } else {
                    set login_result "FAIL"
                }
            }

            if {[info exists risk_login_validation] &&
                    ($risk_login_validation eq "Response Code") &&
                        [info exists risk_login_validation_string] &&
                            ($risk_login_validation_string ne "")} {
                if {[HTTP::status] == $risk_login_validation_string} {
                    set login_result "PASS"
                } else {
                    set login_result "FAIL"
                }
            }

            if {[info exists risk_login_validation] &&
                    ($risk_login_validation eq "Redirect Path") &&
                        [info exists risk_login_validation_string] &&
                            ($risk_login_validation_string ne "")} {
                if {[HTTP::header location] eq $risk_login_validation_string} {
                    set login_result "PASS"
                } else {
                    set login_result "FAIL"
                }
            }

            set msg "<bofdata><bordata>\{\"time\":$http_request_time,\"host\":\"<hostname>\",\"source\":\"bigip.risk.log.login.result\",\"sourcetype\":\"f5:bigip:log:json\",<eventformat_start>\"device_base_mac\":\"<device_base_mac>\",\"devicegroup\":\"<devicegroup>\",\"facility\":\"<facility>\",\"event_type\":\"LoginResult\",\"ver\":1.1,\"VS\":\"$pr_virtual_name\",\"laid\":\"$laid\",\"username\":\"$pr_username\",\"login_result\":\"$login_result\" $login_request_data<eventformat_end>\}<eordata><eofdata>\n"

            set fullPOST "POST <datareceiverurl> HTTP/1.1\r\n"
            append fullPOST "Host: <hechost>\r\n"
            append fullPOST "Accept: */*\r\nUser-Agent: BigIP\r\n"
            append fullPOST "Content-Type: application/json\r\n"
            if {"<datareceiverauth>" ne ""} {
                append fullPOST "<datareceiverauth>\r\n"
            }
            append fullPOST "Content-Length: [string length $msg]\r\n\r\n"
            append fullPOST $msg

            catch {HSL::send [HSL::open <pool> ] $<datatosend>}
            unset laid
          }
        }
    }
    ########Risk Engine Log iRule END ########
    regsub -all "\\\\" $::risk_engine_login_irule "\\\\\\\\" ::risk_engine_login_irule
    regsub -all {\$} $::risk_engine_login_irule "\\\\$" ::risk_engine_login_irule


    ##########################################################################################################################################################################################################################################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################
    ############################################################################################################################################################ END END END  Risk Engine Team Code  END END END #############################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################
    ##########################################################################################################################################################################################################################################################################################################################################################################


    ########run local iapp START ########
    set ::icall_run_iapp    {
        set info [tmsh::get_config sys application service /Common/<appname>-local.app/<appname>-local]
        set junk ""
        set lastupdated 0
        set lastdeployedvirtual ""
        set lastdeployed 0

        regexp {localmode__lastupdated[ |\n]*\{[ |\n]*value *(\d*)} $info junk lastupdated
        regexp {localmode__lastupdatedvirtual[ |\n]*\{[ |\n]*value *(\S*)} $info junk lastdeployedvirtual

        catch {set info [tmsh::get_config ltm virtual $lastdeployedvirtual]}
        regexp {lastdeployed:(\d*)} $info junk lastdeployed

        if {$lastdeployed < $lastupdated} {
            #iapp_conf modify sys application service /Common/<appname>-local.app/<appname>-local \{ execute-action definition \};#11.5.x support
            catch {exec /usr/bin/tmsh -c " modify sys application service /Common/<appname>-local.app/<appname>-local \{ execute-action definition \} "}
        }
    }
    ########run local iapp END ########

    proc format_poolmembers {input} {
        set poolmembers ""
        foreach item $input {
            set member [split $item ":"]
            #check to see if this is an ip
            if {[regexp {^((([2][5][0-5]|([2][0-4]|[1][0-9]|[0-9])?[0-9])\.){3})([2][5][0-5]|([2][0-4]|[1][0-9]|[0-9])?[0-9])$} [lindex $member 0]]} {
                append poolmembers "$item \{ address [lindex $member 0] \}"
            } else {
                #must be FQDN - let tmsh do validation
                if {($::version ne "13.1.1") && ($::version ne "13.1.0") &&
                    ($::version ne "13.0.0") && ($::version ne "12.1.2") &&
                    ($::version ne "12.1.1") && ($::version ne "12.1.0") &&
                    ($::version ne "12.0.0")} {
                    puts "Sorry FQDNs are not supported in this version"
                    error "Sorry FQDNs are not supported in this version"
                }
                append poolmembers "splunk-$item \{ fqdn \{ autopopulate enabled name [lindex $member 0] \} \}"

            }
        }
        return $poolmembers
    }

    proc tmsh_exe {command} {
        #this proc gives us the ability to do commands outside the context of the iApp:)
        puts $command
        catch {exec /usr/bin/tmsh -c $command}
    }

    proc tmsh_create { component arguments } {
        regsub -all {\"} $arguments "\\\"" arguments
        regsub -all {\[} $arguments "\\\[" arguments
        regsub -all {\]} $arguments "\\\]" arguments
        puts "$component $arguments"
        tmsh::run_proc f5.app_utils:do_tmsh_create "\"$component\"" "\"$arguments\""
    }

    proc tmsh_modify { component arguments } {
        regsub -all {\"} $arguments "\\\"" arguments
        regsub -all {\[} $arguments "\\\[" arguments
        regsub -all {\]} $arguments "\\\]" arguments
        puts "$component $arguments"
        tmsh::run_proc f5.app_utils:do_tmsh_modify "\"$component\"" "\"$arguments\""
    }

    proc listformat { input } {
        set listofitems [list]
        set workinglist [list]

        #let's get our output into a list by line
        regsub -all " |{|\\}" $input "" input
        set workinglist [split $input "\n"]
        foreach item $workinglist {
            if {[string first / $item] == 0} {
                lappend listofitems $item
            }
        }
        return $listofitems
    }

    ###start of logic

    set iappvars "intro__localmode \{ value \"Yes\" \} localmode__uniqueid \{ value \"$::uniqueid\"\} localmode__lastupdated \{ value \"${::time}\" \} localmode__orginalapp \{ value \"${::app}\" \} basic__logging \{ value \"$::basic__logging\" \} basic__syslog \{ value \"$::basic__syslog\" \} basic__format \{ value \"$::basic__format\" \} basic__appiqformat \{ value \"$::basic__appiqformat\" \} basic__systemtenant \{ value \\\"$::basic__systemtenant\\\" \} basic__alerts \{ value \"$::basic__alerts\" \} basic__hostnameoverride \{ value \\\"$::basic__hostnameoverride\\\" \} basic__devicegroupoverride \{ value \\\"$::basic__devicegroupoverride\\\" \} basic__facility \{ value \\\"$::basic__facility\\\" \} rbac__indexprefix \{ value \\\"$::rbac__indexprefix\\\" \} rbac__indexprefixstring \{ value \\\"$::rbac__indexprefixstring\\\" \} rbac__systemindex \{ value \\\"$::rbac__systemindex\\\" \} rbac__systemindexstring \{ value \\\"$::rbac__systemindexstring\\\" \} rbac__defaultindex \{ value \\\"$::rbac__defaultindex\\\" \} rbac__defaultindexstring \{ value \\\"$::rbac__defaultindexstring\\\" \} rbac__logindex \{ value \\\"$::rbac__logindex\\\" \} rbac__logindexstring \{ value \\\"$::rbac__logindexstring\\\" \} rbac__sharedindex \{ value \\\"$::rbac__sharedindex\\\" \} rbac__sharedindexstring \{ value \\\"$::rbac__sharedindexstring\\\" \} basic__rbac \{ value \\\"$::basic__rbac\\\" \} "
    set createiapp "No"
    set syslogconfigtype "NONE"
    set alertconfigtype "NONE"
    set logpublisher ""
    set application_mapping ""

    #stats
    if {($::basic__stats eq "Yes") && ($::intro__localmode eq "No")} {
        #tmsh::log "FINEME $::statistics__pushconfig"

        if {($::statistics__pushconfig eq "Yes") && ($::basic__format ne "F5 BIG-IQ")} {
            ###Application Mapping Logic
            #tmsh::log "FINEME Phase2"
            if {($::applicationmapping__mode eq "Define") ||
                    ($::applicationmapping__mode eq "Use Existing with Addtional")} {
                set nonpriority 0
                set mappingconfig ""

                if {$::applicationmapping__mode eq "Use Existing with Addtional"} {
                    catch {set mappingconfig [exec /usr/bin/base64 -d -i << $::applicationmapping__mapping]}
                }

                array set mapping_datasrc {
                    "Virtual Name" virtual_name
                    "Virtual IP" ip
                    "Virtual Port" port
                    "Virtual Protocol" protocol
                    "Virtual Description" description
                    "Partition" partition
                    "iApp Name" appservice
                    "Wideip Name" wideip_name
                }

                foreach {row} [scan_APL_table ::applicationmapping__mappings {priority type datasource regex mappingaction appendprefix directmapping}] {
                    foreach {mapping_priority mapping_type datasource mapping_regex mapping_mappingaction mapping_appendprefix mapping_directmapping} $row {
                        set mapping_datasource $mapping_datasrc($datasource)
                    }

                    if {$mapping_priority eq ""} {
                        set mapping_priority [expr {$nonpriority + 10000000000}]
                    }

                    append mappingconfig "{$mapping_priority} {$mapping_type~$mapping_datasource~$mapping_regex~$mapping_mappingaction~$mapping_directmapping~$mapping_appendprefix} "
                    incr nonpriority
                }
                set application_mapping "application_mapping {\ndata \"$mappingconfig\"\n}"
            }
            if {$::applicationmapping__mode eq "Use Existing"} {
                catch {set mappingconfig [exec /usr/bin/base64 -d -i << $::applicationmapping__mapping]}
                set application_mapping "application_mapping {\ndata \"$mappingconfig\"\n}"
            }

            #tmsh::log "FINEME $application_mapping"

        }
        set existing_splunkstats "non exist"
        #we can uncomment the line below to not update the data group each time. this would be used if we wanted to update the list of metrics per customer.
        #catch {set existing_splunkstats [tmsh::get_config ltm data-group internal /Common/${::app}-send_stats ]}

        if {$existing_splunkstats eq "non exist"} {
            #iapp_conf create ltm data-group internal /Common/${::app}-send_stats \{ records replace-all-with \{$application_mapping$::splunkstats_datagroup \} type string \};#11.5.x support
            tmsh_create "ltm data-group internal" "/Common/${::app}-send_stats \{ records replace-all-with \{ $application_mapping$::splunkstats_datagroup  \} type string \}"
        } else {
            #iapp_conf create ltm data-group internal /Common/${::app}-send_stats type string ;#11.5.x support
            tmsh_create "ltm data-group internal" "/Common/${::app}-send_stats type string"

        }



        #deal with proxy configuration 112654373
        set statsproxystring ""
        if {$::statistics__proxy ne "No"} {
            set statsproxystring " --proxy ${::statistics__proxyip}:${::statistics__proxyport} "
            if {($::statistics__proxyuser ne "") && ($::statistics__proxypassword ne "")} {
                append statsproxystring "--proxy-user ${::statistics__proxyuser}:${::statistics__proxypassword} "
            }

        }
        set ihealthproxystring ""
        if {$::ihealth__proxy ne "No"} {
            set ihealthproxystring " --proxy ${::ihealth__proxyip}:${::ihealth__proxyport} "
            if {($::ihealth__proxyuser ne "") && ($::ihealth__proxypassword ne "")} {
                append ihealthproxystring "--proxy-user ${::ihealth__proxyuser}:${::ihealth__proxypassword} "
            }

        }

        set map [list "<ihealthproxyinfo>" "${ihealthproxystring}" "<statsproxyinfo>" "${statsproxystring}"]
        set ::icall_splunkstats [string map $map $::icall_splunkstats]

        iapp_conf create sys icall script /Common/${::app}-send_stats \{ definition \{$::icall_splunkstats\} description none events none \} ;#11.5.x support

        #deal with random offset
        if {$::statistics__randomstart eq "Yes"} {
            #pick a random time between the two numbers
            set start_second [expr {int(rand() * $::statistics__pushinterval)}]
            set randomstart "[clock format $::time -format "%Y-%m-%d:%H:%M"]:${start_second}"
            tmsh_create "sys icall handler periodic" "/Common/${::app}-send_stats \{  interval $::statistics__pushinterval first-occurrence $randomstart script /Common/${::app}-send_stats \}"
        } else {
            tmsh_create "sys icall handler periodic" "/Common/${::app}-send_stats \{  interval $::statistics__pushinterval script /Common/${::app}-send_stats \}"
        }




        if {($::statistics__pushconfig eq "Yes") &&
                ($::applicationmapping__mode ne "Use Existing") &&
                    ($::basic__format ne "F5 BIG-IQ")} {
            catch {set mappingconfig [exec /usr/bin/base64 -w 0 << $mappingconfig]}
            if {($::version eq "13.1.1") || ($::version eq "13.1.0") ||
                ($::version eq "13.0.0") || ($::version eq "12.1.2") ||
                ($::version eq "12.1.1") || ($::version eq "12.1.0") ||
                ($::version eq "12.0.0")} {
                iapp_conf modify sys application service /Common/${::app}.app/${::app} variables modify \{ applicationmapping__exportmapping  \{ value "$mappingconfig" \} \}
            } else {
                #deal with pre 12.0 iapp callback 112280367
                set command "\"modify sys application service /Common/${::app}.app/${::app} variables modify \{ applicationmapping__exportmapping  \{ value \"$mappingconfig\" \} \}\""
                catch {exec /usr/bin/nohup /bin/bash -c "sleep 30; /usr/bin/tmsh -c $command " &}
            }
        }


        ##SSLi Stats
        if {$::statistics__pushsslistats eq "Yes"} {
            set deviceinfo [tmsh::get_config net self /Common/*]
            set address ""
            foreach object $deviceinfo {
                regexp {traffic-group[ |\n]*(\S*)} $object junk trafficgroup

                if {$trafficgroup contains "local"} {
                    regexp {address[ |\n]*([0-9|.]*)} $object junk address
                    # correct for IPv6 as the first address returned 114436217
                    if {$address contains "."} {
                        break
                    }
                }

            }
            catch {tmsh_exe "create sys management-route /Common/session_table-stats network 255.255.255.253/32 gateway $address"}

            tmsh_create "ltm rule" "/Common/ir-${::app}-session_table-stats \{ $::splunk_session_table_irule \}"
            iapp_conf create ltm virtual /Common/${::app}-session_table-stats \{ destination 255.255.255.253:[expr {$::uniqueid + 5}] ip-protocol tcp mask 255.255.255.255 profiles replace-all-with \{ http \{ \} tcp \{ \} \} rules \{  /Common/ir-${::app}-session_table-stats \} source 0.0.0.0/0\}

        }
    } ; #stats


    #agent manager registration iCall
    if {($::basic__format eq "F5 Analytics") && ($::intro__localmode eq "No")} {
        #deal with proxy configuration 112654373
        set statsproxystring ""
        if {$::statistics__proxy ne "No"} {
            set statsproxystring " --proxy ${::statistics__proxyip}:${::statistics__proxyport} "
            if {($::statistics__proxyuser ne "") && ($::statistics__proxypassword ne "")} {
                append statsproxystring "--proxy-user ${::statistics__proxyuser}:${::statistics__proxypassword} "
            }

        }
        set ihealthproxystring ""
        if {$::ihealth__proxy ne "No"} {
            set ihealthproxystring " --proxy ${::ihealth__proxyip}:${::ihealth__proxyport} "
            if {($::ihealth__proxyuser ne "") && ($::ihealth__proxypassword ne "")} {
                append ihealthproxystring "--proxy-user ${::ihealth__proxyuser}:${::ihealth__proxypassword} "
            }

        }
        set map [list "<ihealthproxyinfo>" "${ihealthproxystring}" "<statsproxyinfo>" "${statsproxystring}"]
        set ::icall_agentmanagerreg [string map $map $::icall_agentmanagerreg]
        set regstarttime "[clock format $::time -format "%Y-%m-%d:%H:%M:%S"]"

        iapp_conf create sys icall script /Common/${::app}-agentmanager_reg \{ definition \{$::icall_agentmanagerreg\} description none events none \};#11.5.x support
        tmsh_create "sys icall handler periodic" "/Common/${::app}-agentmanager_reg \{  interval 3600 first-occurrence $regstarttime script /Common/${::app}-agentmanager_reg \}"
    } ; #agent manager registration iCall


    #ihealth
    if {($::basic__ihealth eq "Yes") &&
            ($::ihealth__ihealthpassword ne "") &&
                ($::intro__localmode eq "No")} {
        #deal with proxy configuration 112654373
        set ihealthproxystring ""
        if {$::ihealth__proxy ne "No"} {
            set ihealthproxystring " --proxy ${::ihealth__proxyip}:${::ihealth__proxyport} "
            if {($::ihealth__proxyuser ne "") && ($::ihealth__proxypassword ne "")} {
                append ihealthproxystring "--proxy-user ${::ihealth__proxyuser}:${::ihealth__proxypassword} "
            }

        }

        set map [list "<ihealthproxyinfo>" "${ihealthproxystring}"]
        set ::icall_ihealth [string map $map $::icall_ihealth]

        iapp_conf create sys icall script /Common/${::app}-send_ihealth \{ definition \{$::icall_ihealth\} description none events none \}

        regexp {(.*):(.*)} $::ihealth__time junk start_hour start_minute

        #deal with padded 0
        scan $start_minute %d start_minute

        #if start time is earlier change start date to tomorrow

        set current_hour [clock format $time -format "%H"]
        #deal with padded 0
        scan $current_hour %d current_hour
        set current_min [clock format $time -format "%M"]
        scan $current_min %d current_min

        set starttime $time

        if {(($start_hour * 60) + $start_minute) < (($current_hour * 60) + $current_min)} {
            set starttime [expr {$time + 86400}]
        }

        set starttime "[clock format $starttime -format "%Y-%m-%d"]:${start_hour}:${start_minute}:00"

        tmsh_create "sys icall handler periodic" "/Common/${::app}-send_ihealth \{  interval 86400 first-occurrence  $starttime script /Common/${::app}-send_ihealth \}"
    } ; #ihealth

    #logging
    if {$::basic__logging eq "Yes"} {

        if {[catch {set ::logging__useexistingsplunk $::logging__useexistingsplunk}]}{set ::logging__useexistingsplunk "No"}
        if {[catch {set ::logging__useexistingapikey $::logging__useexistingapikey}]}{set ::logging__useexistingapikey "No"}
        if {[catch {set ::logging__splunkdestinationprotocol $::logging__splunkdestinationprotocol}]}{set ::logging__splunkdestinationprotocol ""}

        if {[catch {set ::logging__sendrisklogins $::logging__sendrisklogins}]}{set ::logging__sendrisklogins "No"}
        if {[catch {set ::logging__sendriskdata $::logging__sendriskdata}]}{set ::logging__sendriskdata "No"}
        if {[catch {set ::logging__sendadm $::logging__sendadm}]}{set ::logging__sendadm "No"}
        if {[catch {set ::logging__virtual $::logging__virtual}]}{set ::logging__virtual ""}

        if {[catch {set logging_dest $::logging__splunkdestinationip}]}{set logging_dest ""}
        if {[catch {set logging_port $::logging__splunkdestinationport}]}{set logging_port ""}
        if {[catch {set ::logging__splunkdestinationhostheader $::logging__splunkdestinationhostheader}]}{set ::logging__splunkdestinationhostheader ""}
        if {[catch {set ::logging__splunkdestinationip $::logging__splunkdestinationip}]}{set ::logging__splunkdestinationip ""}
        if {$::logging__splunkdestinationhostheader eq ""}{set ::logging__splunkdestinationhostheader $::logging__splunkdestinationip}
        if {$::logging__splunkdestinationprotocol eq "HTTP Event Collector - HTTP"} {set ::logging__splunkdestinationprotocol "HTTP"}
        if {$::logging__splunkdestinationprotocol eq "HTTP Event Collector - HTTPS"} {set ::logging__splunkdestinationprotocol "HTTPS"}
        if {[catch {set ::logging__snatpool $::logging__snatpool}]}{set ::logging__snatpool "Auto-Map"}

        if {![info exists ::logging__splunkapikey]} { set ::logging__splunkapikey "" }
        if {$::logging__useexistingsplunk eq "Yes"} {
            set ::logging__splunkdestinationip $::statistics__splunkdestinationip
            set ::logging__splunkdestinationhostheader $::statistics__splunkdestinationhostheader
            set ::logging__splunkdestinationport $::statistics__splunkdestinationport
            set ::logging__splunkdestinationprotocol $::statistics__splunkdestinationprotocol
            set ::logging__splunkapikey $::statistics__splunkapikey
        }
        if {($::logging__useexistingapikey eq "Yes") && !($::logging_useexistingsplunk eq "Yes")} {
            set ::logging__splunkapikey $::statistics__splunkapikey
        }
        if {$::logging__splunkdestinationprotocol eq "HTTPS" || $::logging__splunkdestinationprotocol eq "HTTP"} {
            switch -- $::basic__format {
                "Splunk" {
                    set datareceiverurl "/services/collector/event"
                    set datareceiverauth "Authorization: Splunk $::logging__splunkapikey"
                }
                "Sumo Logic" {
                    set datareceiverurl "/receiver/v1/http/$::basic__systemtenant"
                    set datareceiverauth ""
                }
                "F5 Analytics" {
                    set datareceiverurl "/mgmt/ap/v1/tenants/$::basic__systemtenant/sources/$hostnamemapping/raw-data"
                    set datareceiverauth "Postman-Token: $::logging__splunkapikey"
                }
                "F5 Risk Engine" {
                    set datareceiverurl "/"
                    set datareceiverauth "HealthStats: $::logging__splunkapikey"
                }
                "F5 Risk Engine - Full" {
                    set datareceiverurl "/"
                    set datareceiverauth "HealthStats: $::logging__splunkapikey"
                }
            }


            if {$::intro__localmode eq "No"} {
                append iappvars " logging__splunkdestinationip  \{ value \"$::logging__splunkdestinationip\" \} logging__splunkdestinationhostheader  \{ value \"$::logging__splunkdestinationhostheader\" \} logging__splunkdestinationport \{ value \"$::logging__splunkdestinationport\" \} logging__splunkdestinationprotocol  \{ value \"$::logging__splunkdestinationprotocol\" \} logging__splunkapikey  \{ value \\\"$::logging__splunkapikey\\\" \} logging__snatpool  \{ value \"$::logging__snatpool\" \} logging__sendriskdata  \{ value \"$::logging__sendriskdata\" \} logging__sendadm  \{ value \"$::logging__sendadm\" \} "
                set iapp_updated_virtual " localmode__lastupdatedvirtual  \{ value \"/Common/${::app}-hec-forwarder-tcp-log-stage1\" \} "
                set createiapp Yes

                if {$::logging__sendriskdata eq "Yes"} {
                    set map "
                      <pool> \"-proto TCP -pool /Common/${::app}-hec-forwarder-tcp-log-stage1\"
                      <datatosend> fullPOST
                      <hechost> \"$::logging__splunkdestinationhostheader\"
                      <datareceiverurl> \"$datareceiverurl\"
                      <datareceiverauth> \"$datareceiverauth\"
                      <hslpool> /Common/${::app}-hec-forwarder-tcp-log-stage1
                      <hostname> \"$hostnamemapping\"
                      <eventformat_start> \"$eventformat_start\"
                      <eventformat_end> \"$eventformat_end\"
                      <bofdata> \"$bofdata\"
                      <eofdata> \"$eofdata\"
                      <bordata> \"$bordata\"
                      <eordata> \"$eordata\"
                      <facility> \"$::basic__facility\"
                      <devicegroup> \"$devicegroup\"
                      <device_base_mac> \"$device_base_mac\"
                      <extdatagroup> \"/Common/${::app}-risk_engine-exclude-ext\"

                    "
                    set ::risk_engine_log_irule [string map $map $::risk_engine_log_irule]


                    iapp_conf create ltm data-group internal /Common/${::app}-risk_engine-exclude-ext records replace-all-with \{ .bmp \{ \} .css \{ \} .eot \{ \} .flv \{ \} .gif \{ \} .ico \{ \} .jpeg \{ \} .jpg \{ \} .js \{ \} .m4v \{ \} .mp4 \{ \} .mpv \{ \} .ogv \{ \} .otf \{ \} .png \{ \} .svg \{ \} .swf \{ \} .ttf \{ \} .webm \{ \} .woff \{ \} \} type string


                    tmsh_create "ltm rule" "/Common/ir-${::app}-risk_engine-log \{ $::risk_engine_log_irule \}"

                }


                if {$::logging__sendrisklogins eq "Yes"} {
                    set map "
                      <pool> \"-proto TCP -pool /Common/${::app}-hec-forwarder-tcp-log-stage1\"
                      <datatosend> fullPOST
                      <hechost> \"$::logging__splunkdestinationhostheader\"
                      <datareceiverurl> \"$datareceiverurl\"
                      <datareceiverauth> \"$datareceiverauth\"
                      <hslpool> /Common/${::app}-hec-forwarder-tcp-log-stage1
                      <hostname> \"$hostnamemapping\"
                      <eventformat_start> \"$eventformat_start\"
                      <eventformat_end> \"$eventformat_end\"
                      <bofdata> \"$bofdata\"
                      <eofdata> \"$eofdata\"
                      <bordata> \"$bordata\"
                      <eordata> \"$eordata\"
                      <datagroup> \"/Common/${::app}-risk_engine-loginmapping\"
                      <facility> \"$::basic__facility\"
                      <devicegroup> \"$devicegroup\"
                      <device_base_mac> \"$device_base_mac\"
                      <extdatagroup> \"/Common/${::app}-risk_engine-exclude-ext\"
                    "
                    set ::risk_engine_login_irule [string map $map $::risk_engine_login_irule]
                    tmsh_create "ltm rule" "/Common/ir-${::app}-risk_engine-login \{ $::risk_engine_login_irule \}"

                }



            } else {



                set map "
                  <hechost> \"$::logging__splunkdestinationhostheader\"
                  <datareceiverurl> \"$datareceiverurl\"
                  <datareceiverauth> \"$datareceiverauth\"
                  <hslpool> /Common/${::app}-hec-forwarder-tcp-log-stage1
                  <hostname> \"$hostnamemapping\"
                  <eventformat_start> \"$eventformat_start\"
                  <eventformat_end> \"$eventformat_end\"
                  <bofdata> \"$bofdata\"
                  <eofdata> \"$eofdata\"
                  <bordata> \"$bordata\"
                  <eordata> \"$eordata\"
                  <index> \"$rbac_log_index_irule\"
                  <facility> \"$::basic__facility\"
                  <devicegroup> \"$devicegroup\"
                  <device_base_mac> \"$device_base_mac\"
                "
                set ::splunk_hec_forwarder_tcp_irule [string map $map $::splunk_hec_forwarder_tcp_irule]
                set ::splunk_hec_forwarder_adm_irule [string map $map $::splunk_hec_forwarder_adm_irule]

                #iapp_conf create ltm rule /Common/ir-${::app}-hec-forwarder-tcp-log \{ $::splunk_hec_forwarder_tcp_irule \};#11.5.x support
                tmsh_create "ltm rule" "/Common/ir-${::app}-hec-forwarder-tcp-log \{ $::splunk_hec_forwarder_tcp_irule \}"




                if {$::logging__sendadm eq "Yes"} {
                    tmsh_create "ltm rule" "/Common/ir-${::app}-hec-forwarder-adm-log \{ $::splunk_hec_forwarder_adm_irule \}"
                }


                #iapp_conf create ltm pool /Common/${::app}-hec-forwarder-tcp-log-stage2 \{ members replace-all-with \{ [format_poolmembers "$::logging__splunkdestinationip:$::logging__splunkdestinationport"] \} \};#11.5.x support
                tmsh_create "ltm pool" "/Common/${::app}-hec-forwarder-tcp-log-stage2 \{ members replace-all-with \{ [format_poolmembers "$::logging__splunkdestinationip:$::logging__splunkdestinationport"] \} \}"
                #iapp_conf create ltm pool /Common/${::app}-hec-forwarder-tcp-log-stage1 \{ members replace-all-with  \{ 255.255.255.254:[expr {$::uniqueid + 40001}] \{ address 255.255.255.254 \} \} \};#11.5.x support
                tmsh_create "ltm pool" "/Common/${::app}-hec-forwarder-tcp-log-stage1 \{ members replace-all-with  \{ 255.255.255.254:[expr {$::uniqueid + 40001}] \{ address 255.255.255.254 \} \} \}"
                #iapp_conf create ltm pool /Common/${::app}-hec-forwarder-tcp-log-stage0 \{ members replace-all-with  \{ 255.255.255.254:[expr {$::uniqueid + 1}] \{ address 255.255.255.254 \} \} \};#11.5.x support
                tmsh_create "ltm pool" "/Common/${::app}-hec-forwarder-tcp-log-stage0 \{ members replace-all-with  \{ 255.255.255.254:[expr {$::uniqueid + 1}] \{ address 255.255.255.254 \} \} \}"

                #iapp_conf create sys log-config destination remote-high-speed-log /Common/${::app}-hec-forwarder-tcp-log \{ pool-name /Common/${::app}-hec-forwarder-tcp-log-stage0 \} ;#11.5.x support
                tmsh_create "sys log-config destination remote-high-speed-log" "/Common/${::app}-hec-forwarder-tcp-log \{ pool-name /Common/${::app}-hec-forwarder-tcp-log-stage0 \}"
                #iapp_conf create sys log-config destination splunk /Common/${::app}-hec-forwarder-tcp-log-splunkformat \{ forward-to /Common/${::app}-hec-forwarder-tcp-log \} ;#11.5.x support
                tmsh_create "sys log-config destination splunk" "/Common/${::app}-hec-forwarder-tcp-log-splunkformat \{ forward-to /Common/${::app}-hec-forwarder-tcp-log \}"

                tmsh_create "ltm profile" "request-log pr-${::app}-logging \{ defaults-from request-log  log-response-by-default yes log-response-logging-errors disabled response-log-error-pool none response-log-error-protocol mds-udp response-log-error-template none response-log-pool /Common/${::app}-hec-forwarder-tcp-log-stage0 response-log-protocol mds-tcp response-log-template \"$::request_logging_string\" response-logging enabled\}"


                if {$::basic__format ne "F5 Risk Engine"} {
                    set logpublisher "/Common/${::app}-hec-forwarder-tcp-log-splunkformat \{ \}"
                }


                catch {tmsh_exe "create ltm virtual-address /Common/255.255.255.254 app-service none traffic-group /Common/traffic-group-local-only"}
                iapp_conf create ltm virtual /Common/${::app}-hec-forwarder-tcp-log-stage1 \{ destination 255.255.255.254:[expr {$::uniqueid + 1}] description "lastdeployed:${::time}" ip-protocol tcp mask 255.255.255.255 profiles replace-all-with \{ tcp \{ \} \} rules \{  /Common/ir-${::app}-hec-forwarder-tcp-log \} source 0.0.0.0/0 source-address-translation \{ type automap \}\} ;#11.5.x support
                if {$::logging__sendadm eq "Yes"} {
                    iapp_conf create ltm virtual /Common/${::app}-hec-forwarder-tcp-adm-stage1 \{ destination 255.255.255.254:[expr {$::uniqueid + 11}] description "lastdeployed:${::time}" ip-protocol tcp mask 255.255.255.255 profiles replace-all-with \{ tcp \{ \} \} rules \{  /Common/ir-${::app}-hec-forwarder-adm-log \} source 0.0.0.0/0 source-address-translation \{ type automap \}\} ;#11.5.x support
                    catch {tmsh_exe "modify sys db adm.cloud.host value 255.255.255.254:1011"}
                }

                if {$::logging__snatpool eq "Auto-Map"} {
                    set natconfig "source-address-translation \{ type automap \}"
                } else {
                    set natconfig "source-address-translation \{ type snat pool $::logging__snatpool \}"
                }

                if {$::logging__splunkdestinationprotocol eq "HTTPS"} {
                    iapp_conf create ltm virtual /Common/${::app}-hec-forwarder-tcp-log-stage2 \{ destination 255.255.255.254:[expr {$::uniqueid + 40001}] description "lastdeployed:${::time}" ip-protocol tcp mask 255.255.255.255 pool /Common/${::app}-hec-forwarder-tcp-log-stage2 profiles  replace-all-with \{ serverssl-insecure-compatible \{ context serverside \} tcp \{ \} \} source 0.0.0.0/0 $natconfig\}          ;#11.5.x support
                } else {
                    iapp_conf create ltm virtual /Common/${::app}-hec-forwarder-tcp-log-stage2 \{ destination 255.255.255.254:[expr {$::uniqueid + 40001}] description "lastdeployed:${::time}" ip-protocol tcp mask 255.255.255.255 pool /Common/${::app}-hec-forwarder-tcp-log-stage2 profiles  replace-all-with \{ tcp \{ \} \} source 0.0.0.0/0 $natconfig\}          ;#11.5.x support
                }

            }


        } else {
            if {$::intro__localmode eq "No"} {
                if {$::logging__splunkdestinationprotocol eq "TCP"} {
                    #iapp_conf create ltm pool /Common/${::app}-tcp-log \{ members replace-all-with \{ [format_poolmembers "$logging_dest:$logging_port"] \} \};#11.5.x support
                    tmsh_create "ltm pool" "/Common/${::app}-tcp-log \{ members replace-all-with \{ [format_poolmembers "$logging_dest:$logging_port"] \} \}"

                    tmsh_create "ltm profile" "request-log pr-${::app}-logging \{ defaults-from request-log  log-response-by-default yes log-response-logging-errors disabled response-log-error-pool none response-log-error-protocol mds-udp response-log-error-template none response-log-pool /Common/${::app}-tcp-log response-log-protocol mds-tcp response-log-template \"$::request_logging_string\" response-logging enabled\}"

                    #iapp_conf create sys log-config destination remote-high-speed-log /Common/${::app}-tcp-log \{ pool-name /Common/${::app}-tcp-log \};#11.5.x support
                    tmsh_create "sys log-config destination remote-high-speed-log" "/Common/${::app}-tcp-log \{ pool-name /Common/${::app}-tcp-log \}"
                    #iapp_conf create sys log-config destination splunk /Common/${::app}-tcp-log-splunkformat \{ forward-to /Common/${::app}-tcp-log \};#11.5.x support
                    tmsh_create "sys log-config destination splunk" "/Common/${::app}-tcp-log-splunkformat \{ forward-to /Common/${::app}-tcp-log \}"
                    if {$::basic__format ne "F5 Risk Engine"} {
                        set logpublisher "/Common/${::app}-tcp-log-splunkformat \{ \}"
                    }


                    if {$::logging__sendriskdata eq "Yes"} {
                        set map "
                          <pool> \"-proto TCP -pool /Common/${::app}-tcp-log\"
                          <datatosend> msg
                          <hechost> \"$::logging__splunkdestinationhostheader\"
                          <datareceiverurl> \"$datareceiverurl\"
                          <datareceiverauth> \"$datareceiverauth\"
                          <hslpool> /Common/${::app}-hec-forwarder-tcp-log-stage1
                          <hostname> \"$hostnamemapping\"
                          <eventformat_start> \"$eventformat_start\"
                          <eventformat_end> \"$eventformat_end\"
                          <bofdata> \"$bofdata\"
                          <eofdata> \"$eofdata\"
                          <bordata> \"$bordata\"
                          <eordata> \"$eordata\"
                          <index> \"$rbac_log_index_irule\"
                          <facility> \"$::basic__facility\"
                          <devicegroup> \"$devicegroup\"
                          <device_base_mac> \"$device_base_mac\"
                          <extdatagroup> \"/Common/${::app}-risk_engine-exclude-ext\"

                        "
                        set ::risk_engine_log_irule [string map $map $::risk_engine_log_irule]

                        iapp_conf create ltm data-group internal /Common/${::app}-risk_engine-exclude-ext records replace-all-with \{ .bmp \{ \} .css \{ \} .eot \{ \} .flv \{ \} .gif \{ \} .ico \{ \} .jpeg \{ \} .jpg \{ \} .js \{ \} .m4v \{ \} .mp4 \{ \} .mpv \{ \} .ogv \{ \} .otf \{ \} .png \{ \} .svg \{ \} .swf \{ \} .ttf \{ \} .webm \{ \} .woff \{ \} \} type string

                        tmsh_create "ltm rule" "/Common/ir-${::app}-risk_engine-log \{ $::risk_engine_log_irule \}"
                    }

                    if {$::logging__sendrisklogins eq "Yes"} {
                        set map "
                          <pool> \"-proto TCP -pool /Common/${::app}-tcp-log\"
                          <datatosend> msg
                          <hechost> \"$::logging__splunkdestinationhostheader\"
                          <datareceiverurl> \"$datareceiverurl\"
                          <datareceiverauth> \"$datareceiverauth\"
                          <hslpool> /Common/${::app}-hec-forwarder-tcp-log-stage1
                          <hostname> \"$hostnamemapping\"
                          <eventformat_start> \"$eventformat_start\"
                          <eventformat_end> \"$eventformat_end\"
                          <bofdata> \"$bofdata\"
                          <eofdata> \"$eofdata\"
                          <bordata> \"$bordata\"
                          <eordata> \"$eordata\"
                          <index> \"$rbac_log_index_irule\"
                          <datagroup> \"/Common/${::app}-risk_engine-loginmapping\"
                          <facility> \"$::basic__facility\"
                          <devicegroup> \"$devicegroup\"
                          <device_base_mac> \"$device_base_mac\"
                          <extdatagroup> \"/Common/${::app}-risk_engine-exclude-ext\"

                        "
                        set ::risk_engine_login_irule [string map $map $::risk_engine_login_irule]
                        tmsh_create "ltm rule" "/Common/ir-${::app}-risk_engine-login \{ $::risk_engine_login_irule \}"
                    }


                } else {
                    #iapp_conf create ltm pool /Common/${::app}-udp-log \{ members replace-all-with \{ [format_poolmembers "$logging_dest:$logging_port"] \} \};#11.5.x support
                    tmsh_create "ltm pool" "/Common/${::app}-udp-log \{ members replace-all-with \{ [format_poolmembers "$logging_dest:$logging_port"] \} \}"

                    #iapp_conf create sys log-config destination remote-high-speed-log /Common/${::app}-udp-log \{ protocol udp pool-name /Common/${::app}-udp-log \} ;#11.5.x support
                    tmsh_create "sys log-config destination remote-high-speed-log" "/Common/${::app}-udp-log \{ protocol udp pool-name /Common/${::app}-udp-log \}"
                    #iapp_conf create sys log-config destination splunk /Common/${::app}-udp-log-splunkformat \{ forward-to /Common/${::app}-udp-log \};#11.5.x support
                    tmsh_create "sys log-config destination splunk" "/Common/${::app}-udp-log-splunkformat \{ forward-to /Common/${::app}-udp-log \}"

                    tmsh_create "ltm profile" "request-log pr-${::app}-logging \{ defaults-from request-log  log-response-by-default yes log-response-logging-errors disabled response-log-error-pool none response-log-error-protocol mds-udp response-log-error-template none response-log-pool /Common/${::app}-udp-log response-log-protocol mds-udp response-log-template \"$::request_logging_string\" response-logging enabled\}"

                    if {$::basic__format ne "F5 Risk Engine"} {
                        set logpublisher "/Common/${::app}-udp-log-splunkformat \{ \}"
                    }

                    if {$::logging__sendriskdata eq "Yes"} {
                        set map "
                          <pool> \"-proto UDP -pool /Common/${::app}-udp-log\"
                          <datatosend> msg
                          <hechost> \"$::logging__splunkdestinationhostheader\"
                          <datareceiverurl> \"$datareceiverurl\"
                          <datareceiverauth> \"$datareceiverauth\"
                          <hslpool> /Common/${::app}-hec-forwarder-tcp-log-stage1
                          <hostname> \"$hostnamemapping\"
                          <eventformat_start> \"$eventformat_start\"
                          <eventformat_end> \"$eventformat_end\"
                          <bofdata> \"$bofdata\"
                          <eofdata> \"$eofdata\"
                          <bordata> \"$bordata\"
                          <eordata> \"$eordata\"
                          <index> \"$rbac_log_index_irule\"
                          <facility> \"$::basic__facility\"
                          <devicegroup> \"$devicegroup\"
                          <device_base_mac> \"$device_base_mac\"
                          <extdatagroup> \"/Common/${::app}-risk_engine-exclude-ext\"

                        "
                        set ::risk_engine_log_irule [string map $map $::risk_engine_log_irule]
                        tmsh_create "ltm rule" "/Common/ir-${::app}-risk_engine-log \{ $::risk_engine_log_irule \}"
                    }

                    if {$::logging__sendrisklogins eq "Yes"} {
                        set map "
                          <pool> \"-proto UDP -pool /Common/${::app}-udp-log\"
                          <datatosend> msg
                          <hechost> \"$::logging__splunkdestinationhostheader\"
                          <datareceiverurl> \"$datareceiverurl\"
                          <datareceiverauth> \"$datareceiverauth\"
                          <hslpool> /Common/${::app}-hec-forwarder-tcp-log-stage1
                          <hostname> \"$hostnamemapping\"
                          <eventformat_start> \"$eventformat_start\"
                          <eventformat_end> \"$eventformat_end\"
                          <bofdata> \"$bofdata\"
                          <eofdata> \"$eofdata\"
                          <bordata> \"$bordata\"
                          <eordata> \"$eordata\"
                          <index> \"$rbac_log_index_irule\"
                          <datagroup> \"/Common/${::app}-risk_engine-loginmapping\"
                          <facility> \"$::basic__facility\"
                          <devicegroup> \"$devicegroup\"
                          <device_base_mac> \"$device_base_mac\"

                        "
                        set ::risk_engine_login_irule [string map $map $::risk_engine_login_irule]
                        tmsh_create "ltm rule" "/Common/ir-${::app}-risk_engine-login \{ $::risk_engine_login_irule \}"
                    }
                }
            }
        }


        if {( ($::logging__sendriskdata eq "Yes") ||
              ($::logging__sendrisklogins eq "Yes") ) &&
            ($::intro__localmode eq "No")} {
            set virtualstomodify {}
            set virtualstomodify_log {}
            set virtualstomodify_login {}
            set riskengine_logins ""
            set spacer ""

            if {$::logging__sendriskdata eq "Yes"} {
                foreach virtual $::logging__virtual {
                    lappend virtualstomodify_log $virtual
                    lappend virtualstomodify $virtual
                }
            }

            if {$::logging__sendrisklogins eq "Yes"} {

                foreach {row} [scan_APL_table ::logging__risklogindata {virtual risklogin loginmethod usernamefield validationmethod validation validationvalue}] {
                    foreach {r_virtual r_risklogin r_loginmethod r_usernamefield r_validationmethod r_validation r_validationvalue} $row { break }

                    if {$r_virtual eq "<ALL-FROM-ABOVE>"} {
                        foreach virtual $::logging__virtual {
                            lappend virtualstomodify_login $virtual
                            lappend virtualstomodify $virtual
                            append riskengine_logins "${spacer}\"$virtual|[string tolower ${r_risklogin}]\" \{ data \"${r_loginmethod}|${r_usernamefield}|${r_validationmethod}|${r_validation}|${r_validationvalue}\" \}"
                            set spacer "\x20"
                        }
                    } else {
                        lappend virtualstomodify_login $r_virtual
                        lappend virtualstomodify $r_virtual
                        append riskengine_logins "\"${r_virtual}|[string tolower $r_risklogin]\" \{ data \"${r_loginmethod}|${r_usernamefield}|{$r_validationmethod}|${r_validation}|{$r_validationvalue}\" \}"
                    }
                }
            }


            #get the last run of virtual servers - catch if this is the first time run
            set historicalvirtualstomodify_log [list]
            catch {set historicalvirtualstomodify_log [listformat [tmsh::get_config ltm data-group internal /Common/${::app}-risk_engine-log]]}
            set historicalvirtualstomodify_login [list]
            catch {set historicalvirtualstomodify_login [listformat [tmsh::get_config ltm data-group internal /Common/${::app}-risk_engine-login]]}

            foreach {virtual} $historicalvirtualstomodify_log {
                lappend virtualstomodify $virtual
            }

            foreach {virtual} $historicalvirtualstomodify_login {
                lappend virtualstomodify $virtual
            }


            set virtualstomodify [lsort -unique $virtualstomodify]
            set virtualstomodify_log [lsort -unique $virtualstomodify_log]
            set virtualstomodify_login [lsort -unique $virtualstomodify_login]

            foreach virtual $virtualstomodify {
                if {[catch {set currentvirtualirules [listformat [tmsh::get_config ltm virtual $virtual rules]]}]} {
                    continue
                }
                #otherwise

                #figure out what we need to do
                set modify 0

                set addlog [lsearch -exact $virtualstomodify_log $virtual] ; incr addlog
                set addlogin [lsearch -exact $virtualstomodify_login $virtual] ; incr addlogin
                # TODO:  if $::app contains regexp special characters several
                # lines here may not work properly.  It shouldn't.  Perhaps
                # we should make this code bulletproof though...

                set haslog [lsearch -regexp $currentvirtualirules "ir-${::app}-risk_engine-log\x24"] ; incr haslog
                set haslogin [lsearch -regexp $currentvirtualirules "ir-${::app}-risk_engine-login\x24"] ; incr haslogin

                if {$addlog} {
                    if {!$haslog} {
                        lappend currentvirtualirules "/Common/ir-${::app}-risk_engine-log"
                        set modify 1
                    }
                } else {
                    if {$haslog} {
                        set newvirtualirules {}
                        set modify 1
                        foreach irule $currentvirtualirules {
                            #figure out if it is a patch rule and remove
                            if {![regexp "ir-${::app}-risk_engine-log\x24" $irule]} {
                                lappend newvirtualirules $irule
                            }
                        }
                        set currentvirtualirules $newvirtualirules
                    }
                }
                if {$addlogin} {
                    if {!$haslogin} {
                        set currentvirtualirules "$currentvirtualirules /Common/ir-${::app}-risk_engine-login"
                        set modify 1
                    }
                } else {
                    if {$haslogin} {
                        set newvirtualirules {}
                        set modify 1
                        foreach irule $currentvirtualirules {
                            #figure out if it is a patch rule and remove
                            if {![regexp "ir-${::app}-risk_engine-login\x24" $irule]} {
                                lappend newvirtualirules $irule
                            }
                        }
                        set currentvirtualirules $newvirtualirules
                    }
                }

                if {$modify} {
                    iapp_conf modify ltm virtual $virtual rules \{ $currentvirtualirules \}
                }
            }

            #store loginmappings
            if {$riskengine_logins ne ""} {
                iapp_conf create ltm data-group internal /Common/${::app}-risk_engine-loginmapping records replace-all-with \{ $riskengine_logins \} type string
            }

            #store the list of virtuals that were patched on this pass so we can remove the irule from a virtual server removed from the patched list on the next run
            if {$virtualstomodify_log ne ""} {
                iapp_conf create ltm data-group internal /Common/${::app}-risk_engine-log records replace-all-with \{ $virtualstomodify_log \} type string
            }
            if {$virtualstomodify_login ne ""} {
                iapp_conf create ltm data-group internal /Common/${::app}-risk_engine-login records replace-all-with \{ $virtualstomodify_login \} type string
            }
        }

    } ; #logging

    #syslog
    if {$::basic__syslog eq "Yes"} {
        if {[catch {set ::syslog__useexistingsplunk $::syslog__useexistingsplunk}]}{set ::syslog__useexistingsplunk "No"}
        if {[catch {set ::syslog__useexistingapikey $::syslog__useexistingapikey}]}{set ::syslog__useexistingapikey "No"}
        if {[catch {set ::syslog__splunkdestinationprotocol $::syslog__splunkdestinationprotocol}]}{set ::syslog__splunkdestinationprotocol ""}
        if {[catch {set syslog_dest $::syslog__splunkdestinationip}]}{set syslog_dest ""}
        if {[catch {set syslog_port $::syslog__splunkdestinationport}]}{set syslog_port ""}
        if {[catch {set ::syslog__splunkdestinationhostheader $::syslog__splunkdestinationhostheader}]}{set ::syslog__splunkdestinationhostheader ""}
        if {[catch {set ::syslog__splunkdestinationip $::syslog__splunkdestinationip}]}{set ::syslog__splunkdestinationip ""}
        if {$::syslog__splunkdestinationhostheader eq ""}{set ::syslog__splunkdestinationhostheader $::syslog__splunkdestinationip}
        if {$::syslog__splunkdestinationprotocol eq "HTTP Event Collector - HTTP"} {set ::syslog__splunkdestinationprotocol "HTTP"}
        if {$::syslog__splunkdestinationprotocol eq "HTTP Event Collector - HTTPS"} {set ::syslog__splunkdestinationprotocol "HTTPS"}
        if {[catch {set ::syslog__snatpool $::syslog__snatpool}]}{set ::syslog__snatpool "Auto-Map"}

        set ::syslog__splunkapikey ""
        if {$::syslog__useexistingsplunk eq "Yes"} {
            set ::syslog__splunkdestinationip $::statistics__splunkdestinationip
            set ::syslog__splunkdestinationhostheader $::statistics__splunkdestinationhostheader
            set ::syslog__splunkdestinationport $::statistics__splunkdestinationport
            set ::syslog__splunkdestinationprotocol $::statistics__splunkdestinationprotocol
            set ::syslog__splunkapikey $::statistics__splunkapikey
        }
        if {$::syslog__useexistingapikey eq "Yes"} {
            set ::syslog__splunkapikey $::statistics__splunkapikey
        }
        if {$::syslog__splunkdestinationprotocol eq "HTTPS" || $::syslog__splunkdestinationprotocol eq "HTTP"} {
            if {$::intro__localmode eq "No"} {
                append iappvars " syslog__splunkdestinationip  \{ value \"$::syslog__splunkdestinationip\" \}  syslog__splunkdestinationhostheader  \{ value \"$::syslog__splunkdestinationhostheader\" \} syslog__splunkdestinationport  \{ value \"$::syslog__splunkdestinationport\" \} syslog__splunkdestinationprotocol  \{ value \"$::syslog__splunkdestinationprotocol\" \} syslog__splunkapikey  \{ value \\\"$::syslog__splunkapikey\\\" \} syslog__snatpool  \{ value \"$::syslog__snatpool\" \} "
                set iapp_updated_virtual " localmode__lastupdatedvirtual  \{ value \"/Common/${::app}-hec-forwarder-syslog-stage1\" \} "
                set createiapp Yes
                set syslogconfigtype "HEC"
                set syslogconfig " /Common/${::app}-syslog \{ host 255.255.255.254 remote-port [expr {$::uniqueid + 2}]\} "

            } else {
                switch -- $::basic__format {
                    "Splunk" {
                        set datareceiverurl "/services/collector/event"
                        set datareceiverauth "Authorization: Splunk $::syslog__splunkapikey"
                    }
                    "Sumo Logic" {
                        set datareceiverurl "/receiver/v1/http/$::basic__systemtenant"
                        set datareceiverauth ""
                    }
                    "F5 Analytics" {
                        set datareceiverurl "/mgmt/ap/v1/tenants/$::basic__systemtenant/sources/$hostnamemapping/raw-data"
                        set datareceiverauth "Postman-Token: $::syslog__splunkapikey"
                    }
                    "F5 Risk Engine" {
                        set datareceiverurl "/"
                        set datareceiverauth "HealthStats: $::syslog__splunkapikey"
                    }
                    "F5 Risk Engine - Full" {
                        set datareceiverurl "/"
                        set datareceiverauth "HealthStats: $::syslog__splunkapikey"
                    }
                }


                set map "
                  <hechost> \"$::syslog__splunkdestinationhostheader\"
                  <datareceiverurl> \"$datareceiverurl\"
                  <datareceiverauth> \"$datareceiverauth\"
                  <hslpool> /Common/${::app}-hec-forwarder-syslog-stage1
                  <hostname> \"$hostnamemapping\"
                  <eventformat_start> \"$eventformat_start\"
                  <eventformat_end> \"$eventformat_end\"
                  <bofdata> \"$bofdata\"
                  <eofdata> \"$eofdata\"
                  <bordata> \"$bordata\"
                  <eordata> \"$eordata\"
                  <index> \"$rbac_log_index_irule\"
                  <facility> \"$::basic__facility\"
                  <devicegroup> \"$devicegroup\"
                  <device_base_mac> \"$device_base_mac\"

                "

                set ::splunk_hec_forwarder_udp_syslog_irule [string map $map $::splunk_hec_forwarder_udp_syslog_irule]
                #iapp_conf create ltm rule /Common/ir-${::app}-hec-forwarder-udp-syslog \{ $::splunk_hec_forwarder_udp_syslog_irule \}    ;#11.5.x support
                tmsh_create "ltm rule" "/Common/ir-${::app}-hec-forwarder-udp-syslog \{ $::splunk_hec_forwarder_udp_syslog_irule \}"


                iapp_conf create ltm pool /Common/${::app}-hec-forwarder-syslog-stage2 \{ members replace-all-with \{ [format_poolmembers "$::syslog__splunkdestinationip:$::syslog__splunkdestinationport"] \} \}
                iapp_conf create ltm pool /Common/${::app}-hec-forwarder-syslog-stage1 \{ members replace-all-with  \{ 255.255.255.254:[expr {$::uniqueid + 40002}] \{ address 255.255.255.254 \} \} \}

                catch {tmsh_exe "create ltm virtual-address /Common/255.255.255.254 app-service none traffic-group /Common/traffic-group-local-only"}
                iapp_conf create ltm virtual /Common/${::app}-hec-forwarder-syslog-stage1 \{ destination 255.255.255.254:[expr {$::uniqueid + 2}] description "lastdeployed:${::time}" ip-protocol udp mask 255.255.255.255 profiles  replace-all-with \{ udp \{ \} \} rules \{ /Common/ir-${::app}-hec-forwarder-udp-syslog \} source 0.0.0.0/0 \}
                if {$::syslog__snatpool eq "Auto-Map"} {
                    set natconfig "source-address-translation \{ type automap \}"
                } else {
                    set natconfig "source-address-translation \{ type snat pool $::syslog__snatpool \}"
                }
                if {$::syslog__splunkdestinationprotocol eq "HTTPS"} {
                    iapp_conf create ltm virtual /Common/${::app}-hec-forwarder-syslog-stage2 \{ destination 255.255.255.254:[expr {$::uniqueid + 40002}] description "lastdeployed:${::time}" ip-protocol tcp mask 255.255.255.255 pool /Common/${::app}-hec-forwarder-syslog-stage2 profiles  replace-all-with \{ serverssl-insecure-compatible \{ context serverside \} tcp \{ \} \} source 0.0.0.0/0 $natconfig\}
                } else {
                    iapp_conf create ltm virtual /Common/${::app}-hec-forwarder-syslog-stage2 \{ destination 255.255.255.254:[expr {$::uniqueid + 40002}] description "lastdeployed:${::time}" ip-protocol tcp mask 255.255.255.255 pool /Common/${::app}-hec-forwarder-syslog-stage2 profiles  replace-all-with \{  tcp \{ \} \} source 0.0.0.0/0 $natconfig\}
                }
            }

        } else {
            if {$::intro__localmode eq "No"} {
                set syslogconfigtype "UDP"
                set syslogconfig " /Common/${::app}-syslog \{ host $syslog_dest remote-port $syslog_port\} "
            }
        }
    } ; #syslog

    #alerts
    if {$::basic__alerts eq "Yes"} {
        if {[catch {set ::alerts__useexistingsplunk $::alerts__useexistingsplunk}]}{set ::alerts__useexistingsplunk "No"}
        if {[catch {set ::alerts__useexistingapikey $::alerts__useexistingapikey}]}{set ::alerts__useexistingapikey "No"}
        if {[catch {set ::alerts__splunkdestinationprotocol $::alerts__splunkdestinationprotocol}]}{set ::alerts__splunkdestinationprotocol ""}
        if {[catch {set ::alerts__splunkdestinationhostheader $::alerts__splunkdestinationhostheader}]}{set ::alerts__splunkdestinationhostheader ""}
        if {[catch {set ::alerts__splunkdestinationip $::alerts__splunkdestinationip}]}{set ::alerts__splunkdestinationip ""}
        if {$::alerts__splunkdestinationhostheader eq ""}{set ::alerts__splunkdestinationhostheader $::alerts__splunkdestinationip}
        if {$::alerts__splunkdestinationprotocol eq "HTTP Event Collector - HTTP"} {set ::alerts__splunkdestinationprotocol "HTTP"}
        if {$::alerts__splunkdestinationprotocol eq "HTTP Event Collector - HTTPS"} {set ::alerts__splunkdestinationprotocol "HTTPS"}
        if {[catch {set ::alerts__snatpool $::alerts__snatpool}]}{set ::alerts__snatpool "Auto-Map"}

        set ::alerts__splunkapikey ""
        if {$::alerts__useexistingsplunk eq "Yes"} {
            set ::alerts__splunkdestinationip $::statistics__splunkdestinationip
            set ::alerts__splunkdestinationhostheader $::statistics__splunkdestinationhostheader
            set ::alerts__splunkdestinationport $::statistics__splunkdestinationport
            set ::alerts__splunkdestinationprotocol $::statistics__splunkdestinationprotocol
            set ::alerts__splunkapikey $::statistics__splunkapikey
        }
        if {$::alerts__useexistingapikey eq "Yes"} {
            set ::alerts__splunkapikey $::statistics__splunkapikey
        }
        if {$::alerts__splunkdestinationprotocol eq "HTTPS" || $::alerts__splunkdestinationprotocol eq "HTTP"} {
            if {$::intro__localmode eq "No"} {
                append iappvars " alerts__splunkdestinationip  \{ value \"$::alerts__splunkdestinationip\" \}  alerts__splunkdestinationhostheader  \{ value \"$::alerts__splunkdestinationhostheader\" \} alerts__splunkdestinationport  \{ value \"$::alerts__splunkdestinationport\" \} alerts__splunkdestinationprotocol  \{ value \"$::alerts__splunkdestinationprotocol\" \} alerts__splunkapikey  \{ value \\\"$::alerts__splunkapikey\\\" \} alerts__snatpool  \{ value \"$::alerts__snatpool\" \} "
                set iapp_updated_virtual " localmode__lastupdatedvirtual  \{ value \"/Common/${::app}-hec-forwarder-snmptrap-stage1\" \} "
                set createiapp Yes
                set alertconfig " /Common/${::app}-snmp \{ community splunk version 2c host 255.255.255.254 port [expr {$::uniqueid + 3}] \} "
                set alertconfigtype "HEC"
            } else {
                switch -- $::basic__format {
                    "Splunk" {
                        set datareceiverurl "/services/collector/event"
                        set datareceiverauth "Authorization: Splunk $::alerts__splunkapikey"
                    }
                    "Sumo Logic" {
                        set datareceiverurl "/receiver/v1/http/$::basic__systemtenant"
                        set datareceiverauth ""
                    }
                    "F5 Analytics" {
                        set datareceiverurl "/mgmt/ap/v1/tenants/$::basic__systemtenant/sources/$hostnamemapping/raw-data"
                        set datareceiverauth "Postman-Token: $::alerts__splunkapikey"
                    }
                    "F5 Risk Engine" {
                        set datareceiverurl "/"
                        set datareceiverauth "HealthStats: $::alerts__splunkapikey"
                    }
                    "F5 Risk Engine - Full" {
                        set datareceiverurl "/"
                        set datareceiverauth "HealthStats: $::alerts__splunkapikey"
                    }
                }


                set map "
                  <hechost> $::alerts__splunkdestinationhostheader
                  <datareceiverurl> \"$datareceiverurl\"
                  <datareceiverauth> \"$datareceiverauth\"
                  <hslpool> /Common/${::app}-hec-forwarder-snmptrap-stage1
                  <hostname> \"$hostnamemapping\"
                  <eventformat_start> \"$eventformat_start\"
                  <eventformat_end> \"$eventformat_end\"
                  <bofdata> \"$bofdata\"
                  <eofdata> \"$eofdata\"
                  <bordata> \"$bordata\"
                  <eordata> \"$eordata\"
                  <index> \"$rbac_log_index_irule\"
                  <facility> \"$::basic__facility\"
                  <devicegroup> \"$devicegroup\"
                  <device_base_mac> \"$device_base_mac\"

                "
                set ::splunk_hec_forwarder_udp_snmptrap_irule [string map $map $::splunk_hec_forwarder_udp_snmptrap_irule]
                iapp_conf create ltm rule /Common/ir-${::app}-hec-forwarder-udp-snmptrap \{ $::splunk_hec_forwarder_udp_snmptrap_irule \};#11.5.x support
                tmsh_create "ltm rule" "/Common/ir-${::app}-hec-forwarder-udp-snmptrap \{ $::splunk_hec_forwarder_udp_snmptrap_irule \}"

                iapp_conf create ltm pool /Common/${::app}-hec-forwarder-snmptrap-stage2 \{ members replace-all-with \{ [format_poolmembers "$::alerts__splunkdestinationip:$::alerts__splunkdestinationport"] \} \}
                iapp_conf create ltm pool /Common/${::app}-hec-forwarder-snmptrap-stage1 \{ members replace-all-with  \{ 255.255.255.254:[expr {$::uniqueid + 40003}] \{ address 255.255.255.254 \} \} \}


                catch {tmsh_exe "create ltm virtual-address /Common/255.255.255.254 app-service none traffic-group /Common/traffic-group-local-only"}
                iapp_conf create ltm virtual /Common/${::app}-hec-forwarder-snmptrap-stage1 \{ destination 255.255.255.254:[expr {$::uniqueid + 3}] description "lastdeployed:${::time}" ip-protocol udp mask 255.255.255.255 profiles  replace-all-with \{ udp \{ \} \} rules \{ /Common/ir-${::app}-hec-forwarder-udp-snmptrap \} source 0.0.0.0/0 \}
                if {$::alerts__snatpool eq "Auto-Map"} {
                    set natconfig "source-address-translation \{ type automap \}"
                } else {
                    set natconfig "source-address-translation \{ type snat pool $::alerts__snatpool \}"
                }
                if {$::alerts__splunkdestinationprotocol eq "HTTPS"} {
                    iapp_conf create ltm virtual /Common/${::app}-hec-forwarder-snmptrap-stage2 \{ destination 255.255.255.254:[expr {$::uniqueid + 40003}] description "lastdeployed:${::time}" ip-protocol tcp mask 255.255.255.255 pool /Common/${::app}-hec-forwarder-snmptrap-stage2 profiles  replace-all-with \{ serverssl-insecure-compatible \{ context serverside \} tcp \{ \} \} source 0.0.0.0/0 $natconfig\}
                } else {
                    iapp_conf create ltm virtual /Common/${::app}-hec-forwarder-snmptrap-stage2 \{ destination 255.255.255.254:[expr {$::uniqueid + 40003}] description "lastdeployed:${::time}" ip-protocol tcp mask 255.255.255.255 pool /Common/${::app}-hec-forwarder-snmptrap-stage2 profiles  replace-all-with \{ tcp \{ \} \} source 0.0.0.0/0 $natconfig\}
                }

            }
        } else {
            if {$::intro__localmode eq "No"} {
                set alertconfigtype "UDP"
                set alertconfig " /Common/${::app}-snmp \{ community $::alerts__splunkdestinationcommunity version 2c host $::alerts__splunkdestinationip port $::alerts__splunkdestinationport \} "
            }
        }
    } ; #alerts


    #create local iapp
    if {$createiapp eq "Yes"} {

        set existing_iapp "non exist"
        catch {set existing_iapp [tmsh::get_config sys application service /Common/${::app}-local.app/${::app}-local]}
        if {$existing_iapp eq "non exist"} {
            #iapp_conf create sys application service /Common/${::app}-local \{ template f5.analytics.v3.7.1rc2 traffic-group traffic-group-local-only variables replace-all-with \{ $iapp_updated_virtual $iappvars \} \};#issue with 11.6 and back - think it has to do with transactions
            tmsh_exe "create sys application service /Common/${::app}-local \{ template f5.analytics.v3.7.1rc2 traffic-group traffic-group-local-only variables replace-all-with \{ $iapp_updated_virtual $iappvars \} \}"
        } else {
            #iapp_conf modify sys application service /Common/${::app}-local.app/${::app}-local \{ template f5.analytics.v3.7.1rc2 traffic-group traffic-group-local-only execute-action definition variables replace-all-with \{ $iapp_updated_virtual $iappvars \} \};#issue with 11.6 and back - think it has to do with transactions
            tmsh_exe "modify sys application service /Common/${::app}-local.app/${::app}-local \{ template f5.analytics.v3.7.1rc2 traffic-group traffic-group-local-only execute-action definition variables replace-all-with \{ $iapp_updated_virtual $iappvars \} \}"
        }

        set map "
          <appname> ${::app}
        "
        set ::icall_run_iapp [string map $map $::icall_run_iapp]
        iapp_conf create sys icall script /Common/${::app}-local_run_iapp \{ definition \{$::icall_run_iapp\} description none events none \}
        iapp_conf create sys icall handler periodic /Common/${::app}-local_run_iapp \{  interval 300 script /Common/${::app}-local_run_iapp \}
    } ; #create local iapp


    if {($::basic__format ne "F5 Risk Engine") &&
                ($::basic__format ne "F5 BIG-IQ") &&
                        ($::basic__logging eq "Yes")} {

        set deviceinfo "non exist"
        if {[catch {tmsh::get_config sys log-config publisher /Common/logging-publisher-f5_analytics} deviceinfo] ||
            ($deviceinfo eq "non exist")} {

            if {$logpublisher ne ""} {
                iapp_conf "create sys log-config publisher /Common/logging-publisher-f5_analytics app-service none destinations replace-all-with \x7b ${logpublisher} \x7d"
            } else {
                iapp_conf "create sys log-config publisher /Common/logging-publisher-f5_analytics app-service none destinations none"
            }
        } else {
            set others [list]
            if {![tmsh::get_field_value [lindex $deviceinfo 0] destinations dlist]} {
                set dlist [list]
            }
            foreach {dest} $dlist {
                if {($dest ne "") && ![regexp "${::app}-.*(tc|ud)p-log" $dest]} {
                    lappend others "${dest} \x7b \x7d"
                }
            }

            if {($logpublisher ne "") || [llength $others]} {
                iapp_conf "modify sys log-config publisher /Common/logging-publisher-f5_analytics \x7b destinations replace-all-with \x7b ${logpublisher} [join $others] \x7d \x7d"
            }
        }

        if {($::basic__appiqformat eq "Yes") && ($logpublisher ne "")} {

#TODO may have to remove /Common/logging-publisher-APP-IQ sometime!

            catch {tmsh_exe "create sys log-config publisher /Common/logging-publisher-APP-IQ"}
            iapp_conf modify sys log-config publisher /Common/logging-publisher-APP-IQ \{ destinations replace-all-with \{ $logpublisher \} \}
            iapp_conf modify analytics global-settings external-logging-publisher /Common/logging-publisher-APP-IQ
            iapp_conf modify analytics global-settings use-hsl enabled
            iapp_conf modify analytics global-settings use-offbox enabled
        }
        if {($::basic__appiqformat eq "Yes") && ($::intro__localmode eq "No")} {
            iapp_conf modify analytics global-settings avrd-interval $::basic__avrinterval
        }
    } elseif {![catch {tmsh::get_config /sys log-config publisher /Common/logging-publisher-f5_analytics} obj] &&
              [tmsh::get_field_value [lindex $obj 0] destinations dlist] &&
              [llength $dlist]} {
        set ours [list]
        set theirs 0
        foreach {field} $dlist {
            foreach {f dest x} $field {
                if {[regexp "${::app}-.*(tc|ud)p-log" $dest]} {
                    lappend ours $dest
                } else {
                    incr theirs
                }
            }
        }
        if {!$theirs} {
            catch {tmsh::delete "/sys log-config publisher /Common/logging-publisher-f5_analytics"}
        } elseif {[llength $ours]} {
            catch {tmsh::modify "/sys log-config publisher /Common/logging-publisher-f5_analytics \x7b destinations delete \x7b [join $ours] \x7d \x7d"}
        }
    }

    #other local things
    if {$::intro__localmode eq "Yes"} {
        set deviceinfo [tmsh::get_config net self /Common/*]
        set address ""
        foreach object $deviceinfo {
            regexp {traffic-group[ |\n]*(\S*)} $object junk trafficgroup

            if {$trafficgroup contains "local"} {
                regexp {address[ |\n]*([0-9|.]*)} $object junk address
                # correct for IPv6 as the first address returned 114436217
                if {$address contains "."} {
                    break
                }
            }

        }
        catch {tmsh_exe "create sys management-route /Common/splunk-hec-forward network 255.255.255.254/32 gateway $address"}
    } else {
    #other non local things
        if {$createiapp ne "Yes"} {
            catch {iapp_conf delete sys application service /Common/${::app}-local.app/${::app}-local}
        }

        #syslog setup
        set deviceinfo [tmsh::get_config sys syslog]
        switch $syslogconfigtype {
            NONE    {
                    if {$deviceinfo contains "${::app}-syslog"} {
                        tmsh_exe "modify sys syslog \{remote-servers delete \{ /Common/${::app}-syslog \} \}"
                    }
                }
            UDP    {
                    if {$deviceinfo contains "${::app}-syslog"} {
                        tmsh_exe "modify sys syslog \{remote-servers modify \{ $syslogconfig \} \}"
                    } else {
                        tmsh_exe "modify sys syslog \{remote-servers add \{ $syslogconfig \} \}"
                    }
                }
            HEC    {
                    if {$deviceinfo contains "${::app}-syslog"} {
                        tmsh_exe "modify sys syslog \{remote-servers modify \{ $syslogconfig \} \}"
                    } else {
                        tmsh_exe "modify sys syslog \{remote-servers add \{ $syslogconfig \} \}"
                    }
                }
        }


        #alert setup
        set deviceinfo ""
        #set deviceinfo [tmsh::get_config sys snmp] ;#had to remove and switch to tmsh_exe b/c of version 11.6 errors
        set deviceinfo [tmsh_exe "list sys snmp"]
        switch $alertconfigtype {
            NONE    {
                    if {$deviceinfo contains "${::app}-snmp"} {
                        tmsh_exe "modify sys snmp \{traps delete \{ /Common/${::app}-snmp \} \}"
                    }
                }
            UDP    {
                    if {$deviceinfo contains "${::app}-snmp"} {
                        tmsh_exe "modify sys snmp \{traps modify \{ $alertconfig \} \}"
                    } else {
                        tmsh_exe "modify sys snmp \{traps add \{ $alertconfig \} \}"
                    }
                }
            HEC    {
                    if {$deviceinfo contains "${::app}-snmp"} {
                        tmsh_exe "modify sys snmp \{traps modify \{ $alertconfig \} \}"
                    } else {
                        tmsh_exe "modify sys snmp \{traps add \{ $alertconfig \} \}"
                    }
                }
        }

    } ; #non local / local things

catch {iapp_template end}
            }
            presentation {
section intro {
    
        message early_release "This template has not yet been fully tested at F5.  It has limited support.  When testing is complete it will be moved to downloads.f5.com"
    

    message hello "This iApp lets you configure your BIG-IP to provide performance and activity data to a consumer such as F5 BIG-IQ, F5 AppIQ, the F5 Splunk Dashboard visualization tool, or Sumo Logic Analytics tool."
    message hello1 "Before using this iApp, we strongly recommend you read the accompanying Deployment Guide, available at http://f5.com/pdf/deployment-guides/f5-analytics.pdf."
    message hello2 "The options for using this iApp to collect BIG-IP APM statistics are only available if you are using BIG-IP version 12.0 or later."

    optional ( hello == "NEVER_SHOW_THIS" ) {
        choice analytics_provisioned tcl { tmsh::run_proc f5.app_utils:get_provisioned avr }
        choice localmode default "No" {"Yes"  , "No"}
        choice is_offbox_capable tcl { tmsh::run_proc f5.app_utils:get_bigip_version_is_equal_or_later 13.0.0 }
        choice okaysessiondump tcl { tmsh::run_proc f5.app_utils:get_bigip_version_is_equal_or_later 12.0.0 }
    }
    optional ( localmode == "No" ) {
        message check_for_updates "Check that you are using the most recent version of this iApp template before continuing."

        choice help display "xxlarge" {
            "Yes, show inline help" => "show"  ,
            "No, do not show inline help" => "hide"
        }
        optional (help == "show") {
            message help_help "This template offers extensive inline assistance, notes, and configuration tips. We strongly recommend reading the inline help presented in the template until you are familiar with the functions and implications of the deployment options. Important notes and warnings are always shown no matter which selection you make."
        }
        choice advanced display "xxlarge" default "hide" {
            "Yes, show advanced options" => "show"  ,
            "No, do not show advanced options" => "hide"
        }
        optional (help == "show") {
            message advanced_advanced "By default, this template offers only the most relevant and important options for configuration. Additional configuration options are available for more complex environments. Enabling this setting will expose these options and allow you to configure them."
        }
    }
    optional ( localmode == "Yes" ) {
        message localmodemessage "This application service is part of a different deployment, to modify please use the original deployment."
    }


}

optional ( intro.localmode == "No" ) {
    section basic {
        choice format display "large" default "Splunk" {"Splunk"  , "Sumo Logic"  , "F5 Analytics"  , "F5 Risk Engine"  , "F5 BIG-IQ"}
        optional ( intro.help == "show" ) {
            message format_help "Choose which data format you want the system to use to send data. "
        }
        optional ( intro.is_offbox_capable == "true" && intro.analytics_provisioned == "provisioned" && basic.format == "F5 Analytics" && intro.advanced == "show") {
            choice appiqformat display "medium" default "Yes" {"Yes"  , "No"}
            optional ( intro.advanced == "show" && basic.appiqformat == "Yes" ) {
                string avrinterval display "medium" default "300" validator "NonNegativeNumber"
            }
        }
        optional ( intro.advanced == "show" ) {
            optional ( basic.format != "F5 BIG-IQ" ) {
                string uniqueid display "small" default "1000" required
                optional ( intro.help == "show" ) {
                    message uniqueid_help "Type an identifier for this instance of the iApp such as 1000, 2000, 3000, and so on. This number should increment by 1000 for each Analytics iApp deployment, starting with 1000."
                }
            }
            choice debug display "medium" default "Yes" {"Yes"  , "No"}
            optional ( intro.help == "show" ) {
                message debug_help "Choose whether you want to log stats responses.  If you select Yes, a BIG-IP log message is written after every time a statistics update message is sent to a data consumer."
            }
        }
        choice stats display "medium" default "Yes" {"Yes"  , "No"}
        optional ( intro.help == "show" ) {
            message stats_help "By default, most reporting is built from basic statistical information collected from this device. To ensure the proper function of most reports, we do not typically recommend disabling this option. The items that are collected and sent to a data consumer can be configured when Advanced mode is enabled.  If you select No, the system does not collect system statistics, but you can still use the other components of this iApp, such as logging and High Speed Logging streams."
        }
        optional ( basic.format != "F5 BIG-IQ" ) {
            choice logging display "medium" default "Yes" {"Yes"  , "No"}
            optional ( intro.help == "show" ) {
                message logging_help "Choose whether you want to enable module High Speed Logging (HSL) to allow for BIG-IP module log collection. If you select Yes, the iApp creates a log publisher you can reference from a BIG-IP module."
            }
            choice syslog display "medium" default "Yes" {"Yes"  , "No"}
            optional ( intro.help == "show" ) {
                message syslog_help "Choose whether you want to enable local system logging. If you select Yes, the iApp creates a process to forward local logfiles (such as /var/log/ltm and /var/log/apm) from this device to be analyzed."
            }
            choice alerts display "medium" default "Yes" {"Yes"  , "No"}
            optional ( intro.help == "show" ) {
                message alerts_help "Choose whether you want to enable SNMP alert logging.  If you select Yes, the iApp creates a process to forward SNMP alert information from this device to be analyzed."
            }
            choice ihealth display "medium" default "Yes" {"Yes"  , "No"}
            optional ( intro.help == "show" ) {
                message ihealth_help "Choose whether you want to enable iHealth snaphot information. iHealth is an F5 cloud service that assesses the health and safety of the system configuration. If you select Yes, the iApp creates a process to periodically generate a system snapshot, process it with iHealth, and forward any items of note to be displayed alongside device and/or application reporting. You need a valid F5 Support ID to configure this option."
            }

            optional ( intro.hello == "NEVER_SHOW_THIS" ) {
                choice silverline display "medium" default "No" {"Yes"  , "No"}
                optional ( intro.help == "show" ) {
                    message silverline_help "Silverline is an F5 cloud service that provides a number of security protections in front of your BIG-IP infrastructure. If selected, this item will create a process to periodically send statistical data from Silverline. You need a valid Silverline management ID for this to function. You should only configure ONE instance of this data collection in your environment using this template."
                }
            }
            string facility display "large"
            optional ( intro.help == "show" ) {
                message facility_help "Type a name for the facility in which this BIG-IP is located (such as 'Main Data Center', 'AWS', or 'NYC'). This field is for identification purposes only."
            }
        }

        optional ( basic.format == "F5 Analytics" || basic.format == "Sumo Logic" ) {
            string systemtenant required display "large"
            optional ( intro.help == "show" ) {
                message systemtenant_help "F5 Analytics Tenant"
            }
        }


        optional ( basic.format != "F5 BIG-IQ" ) {
            string tenantdefault display "large"
            optional ( intro.help == "show" ) {
                message tenantdefault_help "Type a name for the default tenant. A tenant is a group of objects that are related to each other by environment or organization. For example, an Enterprise customer could use the Tenant mapping to describe items that belong to 'Production', 'Testing', or 'Development' environments, while a Hosting customer could use it to distinguish objects that belong to specific hosted customers. This default tenant name is assigned to all objects which do not have a specific Application Mapping configuration (which you configure later in this iApp). If all the configured items on this BIG-IP belong to a single tenant, you can name it here so that you do not need to specify a Tenant Name mapping in the Application Mapping section."
            }
        }
        string devicegroupoverride display "large"
        optional ( intro.help == "show" ) {
            message devicegroupoverride_help "This option allows you to override the default device group name commonly Sync-Failover to the actual cluster name you would like to see within the dashboards. No changes are made to the actual device group configuration. Use this option if you see all of your BIG-IPs under one device group within the dashboards."
        }
        optional ( basic.format != "F5 BIG-IQ" ) {
            optional ( intro.advanced == "show" ) {
                string hostnameoverride display "large"
                optional ( intro.help == "show" ) {
                    message hostnameoverride_help "If you would like your Device Group name or BIG-IP Device hostname to be displayed in your reporting differently from how it is presently configured, you can change it here. A hostname can only be overridden on a Standalone system - this setting will be ignored on BIG-IP devices configured for High Availability."
                }

                choice callbacktype display "large" default "Use Management" {"Static"  , "Use Management"}
                optional ( basic.callbacktype == "Static" ) {
                    string callbackurl display "xxlarge"
                }
                optional ( intro.help == "show" ) {
                    message callbacktype_help "Some items displayed in generated reports contain links that direct you back to your BIG-IP for additional information. You can choose whether to use the Management IP to build these links, or you can instead enter a base URL (e.g., https://mybigipmgmt.customer.com) to use in building these links."
                }
            }
            optional ( basic.format == "Splunk" ) {
                choice rbac display "medium" default "No" {"Yes"  , "No"}
                optional ( intro.help == "show" ) {
                    message rbac_help "Choose whether you want to enable Role Based Access Controls. If you select Yes, a new section appears."
                }
            }
        }
    }
    optional ( basic.rbac == "Yes" ) {
        section rbac {
            choice indexprefix display "medium" default "Yes" {"Yes"  , "No"}
            optional ( intro.help == "show" ) {
                message indexprefix_help "Choose whether or not you want the system to prepend an identifier to all indexes. This is recommended as it ensures data coming from F5 is identified in the data consumer. However if you are trying to align to existing indexes, you may want to select No."
            }
            optional ( rbac.indexprefix == "Yes" ) {
                string indexprefixstring required default "f5-" display "xlarge"
            }
            optional ( intro.help == "show" ) {
                message indexprefixstring_help "Type the identifier you want the system to prepend to all indexes."
            }
            choice systemindex display "xlarge" default "Use Default Tenant" {"Use Default Tenant"  , "Specify"}
            optional ( intro.help == "show" ) {
                message systemindex_help "Choose whether you want to use the default tenant or specify an Index name for system level statistics."
            }
            optional ( rbac.systemindex == "Specify" ) {
                string systemindexstring required default "system_stats" display "xlarge"
                optional ( intro.help == "show" ) {
                    message systemindexstring_help "Type the index name for system level statistics."
                }
            }

            choice defaultindex display "xlarge" default "Use Default Tenant" {"Use Default Tenant"  , "Specify"}
            optional ( intro.help == "show" ) {
                message defaultindex_help "Choose whether you want to use the default tenant or specify an Index name when a tenant is not mapped for statistics."
            }
            optional ( rbac.defaultindex == "Specify" ) {
                string defaultindexstring required default "unknown_stats" display "xlarge"
                optional ( intro.help == "show" ) {
                    message defaultindexstring_help "Type the index name to use when a tenant is not mapped for statistics."
                }
            }
            choice sharedindex display "xlarge" default "Use Default Tenant" {"Use Default Tenant"  , "Specify"}
            optional ( intro.help == "show" ) {
                message sharedindex_help "Choose whether you want to use the default tenant or specify an Index name for shared statistics."
            }
            optional ( rbac.sharedindex == "Specify" ) {
                string sharedindexstring required default "shared_stats" display "xlarge"
                optional ( intro.help == "show" ) {
                    message sharedindexstring_help "Type the index name to use for shared statistics."
                }
            }
            choice logindex display "xlarge" default "Use Default Tenant" {"Use Default Tenant"  , "Specify"}
            optional ( intro.help == "show" ) {
                message logindex_help "Choose whether you want to use the default tenant or specify an Index name for event data."
            }
            optional ( rbac.logindex == "Specify" ) {
                string logindexstring required default "events" display "xlarge"
                optional ( intro.help == "show" ) {
                    message logindexstring_help "Type the index name to use for event data."
                }
            }
        }
    }
    optional ( basic.stats == "Yes" ) {
        section statistics {
            optional ( basic.format != "F5 BIG-IQ" ) {
                string splunkdestinationip display "xlarge" required validator "IpOrFqdn"
                optional ( intro.help == "show" ) {
                    message splunkdestinationip_help "Type the IP address or FQDN of the data consumer (such as Splunk) to which you want to send data."
                }
                optional ( intro.advanced == "show" ) {
                    string splunkdestinationhostheader display "xlarge"
                }
                optional ( intro.help == "show" ) {
                    message splunkdestinationhostheader_help "You can optionally provide an HTTP host header to be used inside of the communication. Providing a hostname ensures that proxies and other security devices intercepting this traffic, including the HTTP Event Collector if using Splunk, understand the communication."
                }
                string splunkdestinationport required validator "PortNumber" display "small"
                optional ( intro.help == "show" ) {
                    message splunkdestinationport_help "Type the port number you want to use to send data to the data consumer. For example, if using Splunk (including Splunk Cloud), this is 8088."
                }
                choice splunkdestinationprotocol display "medium" default "HTTPS" {"HTTP"  , "HTTPS"}
                optional ( intro.help == "show" ) {
                    message splunkdestinationprotocol_help "Select the Protocol to use for transmission."
                }
                optional ( basic.format != "Sumo Logic" ) {
                    string splunkapikey display "xxlarge" required

                    optional ( intro.help == "show" ) {
                        message splunk_help "Specify the API key to use when authenticating. If using Splunk specifically, you also need to have enabled Splunk API access and obtained your Splunk instance's API Key. To do this, log into your Splunk instance as administrator and enable API Access in global settings. Your API key is found in Settings -> Data Input -> HTTP Event Collector."
                    }
                }
            }
            string pushinterval display "small" required default "60" validator "NonNegativeNumber"
             optional ( intro.help == "show" ) {
                message pushinterval_help "By default, device information is collected every 60 seconds. For some larger configurations, you may need to increase the interval to avoid impact to your device."
            }
            optional ( intro.advanced == "show" ) {
                choice randomstart display "medium" default "No" {"Yes"  , "No"}
            }
            optional ( intro.help == "show" ) {
                message randomstart_help "Choose whether you want to randomize the start time within the push interval you specified. For example, if you chose a 60 second interval, and want to randomize the start time, instead of starting the push at 0 seconds, then 60 seconds, then 120 seconds, the system may start the push at 15 seconds, then 75 seconds, then 120 seconds, and so on."
            }

            optional ( basic.format != "F5 BIG-IQ" ) {
                choice proxy display "medium" default "No" {"Yes"  , "No"}
                optional ( intro.help == "show" ) {
                    message proxy_help "Choose whether you are using an HTTP Proxy.  Select Yes if your environment uses a Web proxy to access the Internet."
                }
                optional ( statistics.proxy == "Yes" ) {
                    string proxyip display "xlarge" required validator "IpOrFqdn"
                    string proxyport required validator "PortNumber" display "small"
                    string proxyuser display "xlarge"
                    password proxypassword display "xlarge"
                }

            }
            optional ( intro.advanced == "show" ) {
                choice pushstate display "medium" default "Yes" {"Yes"  , "No"}
                optional ( intro.help == "show" ) {
                    message pushstate_help "Choose whether you want to push device state statistics. Device state information includes statistics such as active/standby, serial number, module status, iApp version and so on. Note that if you select No to this or the following questions, it may cause certain reports for this device not to function correctly within your dashboard."
                }
                choice pushtmstats display "medium" default "Yes" {"Yes"  , "No"}
                optional ( intro.help == "show" ) {
                    message pushtmstats_help "Choose whether you want to push device statistics. Device statistics include tmstat data such as interface, CPU, virtual statistics, profile statistics, DoS L3 statistics, and so on."
                }
                choice pushistats display "medium" default "Yes" {"Yes"  , "No"}
                optional ( intro.help == "show" ) {
                    message pushistats_help "Choose whether you want to push iStat statistics. iStats are custom statistics created within iRules and other scripting (SSL Intercept uses these statistics as well)."
                }
                choice pushsslistats display "medium" default "No" {"Yes"  , "No"}
                optional ( intro.help == "show" ) {
                        message pushsslistats_help "Choose whether you want to push SSL Orchestrator (including SSL Intercept) statistics."
                }
                choice pushavr display "medium" default "Yes" {"Yes"  , "No"}
                optional ( intro.help == "show" ) {
                    message pushavr_help "Choose whether you want to push AVR-sampled data. AVR data includes items such as client/server latency, hit rates, transfer sizes, ASM violations, DNS request, SWG activity by URL, ClientIP, Method, FQDNs and so on. The configuration of which dimensions/tables are set is performed within the Analytics profile."
                }
                optional ( intro.okaysessiondump == "true" ) {
                    choice pushsessiondb display "medium" default "Yes" {"Yes"  , "No"}
                    optional ( intro.help == "show" ) {
                        message pushsessiondb_help "Choose whether you want to push SessionDB statistics for BIG-IP APM. SessionDB statistics are a collection of APM session information and users. Only a set list of core session.x variables are captured as statistics."
                    }
                    optional ( pushsessiondb == "Yes" ) {
                        choice customsessiondb display "medium" default "No" {"Yes"  , "No"}
                        optional ( intro.help == "show" ) {
                            message customsessiondb_help "Choose whether you want to include custom SessionDB variables that you specify. This allows you to specify an additional five session.x variables, such as session.ldap.last.attr.myvar. Note you must have data for these variables in your APM policy or iRule(s) for this to function properly."
                        }
                        optional ( customsessiondb == "Yes" ) {
                            string customsessiondb1 display "xlarge"
                            string customsessiondb2 display "xlarge"
                            string customsessiondb3 display "xlarge"
                            string customsessiondb4 display "xlarge"
                            string customsessiondb5 display "xlarge"
                        }
                    }
                }
                optional ( basic.format != "F5 BIG-IQ" ) {
                    choice pushconfig display "medium" default "Yes" {"Yes"  , "No"}
                    optional ( intro.help == "show" ) {
                        message pushconfig_help "By default the configuration map is pushed, however, you can choose to disable it by selecting No. The configuration map is a collection of the device configuration and mapping of the configuration into Tenants, Apps, AppComponents, and AppDependencies."
                    }
                    choice certexpiration display "medium" default "Yes" {"Yes"  , "No"}
                    optional ( intro.help == "show" ) {
                        message tuning_help "Choose whether you want to push certificate expiration information. This extracts certificate expiration dates for SSL certificates."
                    }
                }
                choice customcollection display "medium" default "No" {"Yes"  , "No"}
                optional ( intro.help == "show" ) {
                    message customcollection_help "Choose whether you want to manually manage statistic collection. If you choose to manually manage statistic collection, you must manually choose the statistics you want collected in the next question."
                }
                optional ( statistics.customcollection == "Yes" ) {
                    multichoice customcollectionconfig display "xxlarge" default {"mcp_request_stat"  , "mcp_transaction_stat"  , "monitor_instance_stat"  , "monitor_stat"  , "disk_info_stat"  , "tmmdns_server_stat"  , "profile_dns_stat"  , "gtm_wideip_stat"  , "dns_cache_resolver_stat"  , "tmmdns_zone_stat"  , "dnsexpress_zone_stat"  , "gtm_dc_stat"  , "tmm_stat"  , "memory_usage_stat"  , "profile_udp_stat"  , "interface_stat"  , "virtual_server_conn_stat"  , "rule_stat"  , "kvm_vcpu_stat"  , "kvm_vm_stat"  , "vcmp_global_stat"  , "vcmp_stat"  , "asm_cpu_util_stats"  , "cpu_info_stat"  , "dos_stat"  , "dosl7_plugin_stats"  , "proc_pid_stat"  , "dosl7d_stat"  , "flow_eviction_policy_stat"  , "host_info_stat"  , "ifc_stats"  , "ip_intelligence_stat"  , "ip_stat"  , "iprepd_stat"  , "pool_member_stat"  , "pool_stat"  , "profile_bigproto_stat"  , "profile_clientssl_stat"  , "profile_connpool_stat"  , "profile_ftp_stat"  , "profile_http_stat"  , "profile_httpcompression_stat"  , "profile_serverssl_stat"  , "profile_tcp_stat"  , "profile_webacceleration_stat"  , "virtual_server_cpu_stat"  , "virtual_server_stat"  , "AVR_STAT_DNS_QUERY"  , "AVR_STAT_DNS_CLIENT_IP"  , "AVR_STAT_APM_SWG_BLOCKED"  , "AVR_STAT_APM_SWG_URL_INFO"  , "AVR_STAT_APM_SWG_USER_INFO"  , "AVR_STAT_URL"  , "AVR_STAT_POOL_MEMBER"  , "AVR_STAT_ASM_ANOMALIES"  , "AVR_STAT_ASM_HTTP_ATTACK_DATA"  , "AVR_STAT_ASM_HTTP_VIOLATION"  , "AVR_STAT_ASM_NETWORK"  , "AVR_STAT_GEO_LOCATION"  , "AVR_STAT_METHOD"  , "AVR_STAT_USER_AGENT"  , "AVR_STAT_VIP"  , "AVR_STAT_ENFORCED_ACL"  , "AVR_STAT_STAGING_ACL"  , "AVR_STAT_RESPONSE_CODE"  , "AVR_STAT_CLIENT_IP"  , "AVR_STAT_TCP"} {"mcp_request_stat"  , "mcp_transaction_stat"  , "monitor_instance_stat"  , "monitor_stat"  , "disk_info_stat"  , "tmmdns_server_stat"  , "profile_dns_stat"  , "gtm_wideip_stat"  , "dns_cache_resolver_stat"  , "tmmdns_zone_stat"  , "dnsexpress_zone_stat"  , "gtm_dc_stat"  , "tmm_stat"  , "memory_usage_stat"  , "profile_udp_stat"  , "interface_stat"  , "virtual_server_conn_stat"  , "rule_stat"  , "kvm_vcpu_stat"  , "kvm_vm_stat"  , "vcmp_global_stat"  , "vcmp_stat"  , "asm_cpu_util_stats"  , "cpu_info_stat"  , "dos_stat"  , "dosl7_plugin_stats"  , "proc_pid_stat"  , "dosl7d_stat"  , "flow_eviction_policy_stat"  , "host_info_stat"  , "ifc_stats"  , "ip_intelligence_stat"  , "ip_stat"  , "iprepd_stat"  , "pool_member_stat"  , "pool_stat"  , "profile_bigproto_stat"  , "profile_clientssl_stat"  , "profile_connpool_stat"  , "profile_ftp_stat"  , "profile_http_stat"  , "profile_httpcompression_stat"  , "profile_serverssl_stat"  , "profile_tcp_stat"  , "profile_webacceleration_stat"  , "virtual_server_cpu_stat"  , "virtual_server_stat"  , "AVR_STAT_DNS_QUERY"  , "AVR_STAT_DNS_CLIENT_IP"  , "AVR_STAT_APM_SWG_BLOCKED"  , "AVR_STAT_APM_SWG_URL_INFO"  , "AVR_STAT_APM_SWG_USER_INFO"  , "AVR_STAT_URL"  , "AVR_STAT_POOL_MEMBER"  , "AVR_STAT_ASM_ANOMALIES"  , "AVR_STAT_ASM_HTTP_ATTACK_DATA"  , "AVR_STAT_ASM_HTTP_VIOLATION"  , "AVR_STAT_ASM_NETWORK"  , "AVR_STAT_GEO_LOCATION"  , "AVR_STAT_METHOD"  , "AVR_STAT_USER_AGENT"  , "AVR_STAT_VIP"  , "AVR_STAT_ENFORCED_ACL"  , "AVR_STAT_STAGING_ACL"  , "AVR_STAT_RESPONSE_CODE"  , "AVR_STAT_CLIENT_IP"  , "AVR_STAT_TCP"}

                }
            }
        }
    }
    optional ( ( basic.logging == "Yes" && basic.format != "F5 BIG-IQ" ) || basic.appiqformat == "Yes" ) {
        section logging {
            optional ( basic.stats == "Yes" ) {
                choice useexistingsplunk display "medium" default "Yes" {"Yes"  , "No"}
            }
            optional ( intro.help == "show" ) {
                message useexistingsplunk_help "For each data source section, you can customize the destination or the event data, or you can use the same destination as you specified in the Analytics System configuration. Select Yes to use the same configuration, or No to customize."
            }
            optional ( logging.useexistingsplunk == "No"  || basic.stats == "No" ) {
                string splunkdestinationip display "xlarge" required validator "IpOrFqdn"
                string splunkdestinationport required validator "PortNumber" display "small"
                choice splunkdestinationprotocol display "xlarge" default "TCP" {"TCP"  , "UDP"  ,"HTTP Event Collector - HTTP"  , "HTTP Event Collector - HTTPS"}
                optional ( logging.splunkdestinationprotocol == "HTTP Event Collector - HTTP" || logging.splunkdestinationprotocol == "HTTP Event Collector - HTTPS") {
                    string splunkdestinationhostheader display "xlarge"
                    optional ( intro.hello == "NEVER_SHOW_THIS" ) {
                        choice proxy display "large" default "No" {"Yes"  , "No"  , "From Main Configuration"}
                    }
                    optional ( logging.proxy == "Yes" ) {
                        message proxynote "Caution sending high speed log messages via a proxy could cause issues with the proxy"
                        string proxyip display "xlarge" required validator "IpOrFqdn"
                        string proxyport required validator "PortNumber" display "small"
                        string proxyuser display "xlarge"
                        password proxypassword display "xlarge"
                    }
                    optional ( intro.help == "show" ) {
                        message proxy_help "You can optionally provide a HTTP host header to be used inside the communication. This is useful for BIG-IP versions prior to 11.6 where FQDNs are not supported. Providing a host header ensures that proxies and other security devices intercepting this traffic, including the HTTP Event Collector, understand the communication."
                    }
                    optional ( basic.stats == "Yes" && basic.format != "Sumo Logic") {
                        choice useexistingapikey display "medium" default "Yes" {"Yes"  , "No"}
                    }
                    optional ( intro.help == "show" ) {
                        message useexistingapikey_help "Choose whether you want to use the same API key you specified in the Analytics System Configuration section, or if you want to specify a new API key here."
                    }
                    optional ( logging.useexistingapikey == "No"  || basic.stats == "No" ) {
                        string splunkapikey display "xxlarge" required
                    }
                }
            }
            optional ( intro.advanced == "show" ) {
                optional ( logging.splunkdestinationprotocol == "HTTP Event Collector - HTTP" || logging.splunkdestinationprotocol == "HTTP Event Collector - HTTPS") {
                    choice snatpool display "xlarge" default "Auto-Map" tcl {
                        
                        return "Auto-Map\n[tmsh::run_proc f5.iapp.1.5.3.cli:iapp_get_items ltm snatpool]"
                    }
                    optional ( intro.help == "show" ) {
                        message snatpool_help "Choose whether you want to use SNAT auto map or if you have configured a SNAT pool to perform source network address translation. When data is transmitted from the iApp, the source IP of the traffic is set to an IP address the BIG-IP owns. By default this will be the floating Self IP address with the most direct route to the external server, or if none, a non-floating Self IP (for details see F5 Solution Article K7336). If you create a SNAT Pool manually outside the iApp you can specify exactly which source IP address(es) to use for connections to the external server."
                    }
                }
            }
            optional ( logging.splunkdestinationprotocol == "HTTP Event Collector - HTTP" || logging.splunkdestinationprotocol == "HTTP Event Collector - HTTPS" || logging.useexistingsplunk == "Yes") {
                choice sendadm display "medium" default "No" {"Yes"  , "No"}
                optional ( intro.help == "show" ) {
                    message sendadm_help "Choose whether you want to send Behavioral anti-DDOS statistics. Select Yes if you are using F5's DDoS mitigation based on behavior analysis and want to collect these stats."
                }
            }
            choice sendriskdata display "medium" default "No" {"Yes"  , "No"}
            optional ( logging.sendriskdata == "Yes" ) {
                multichoice virtual display "xxlarge" tcl {
                    
                    return "[tmsh::run_proc f5.iapp.1.5.3.cli:iapp_get_items ltm virtual]"
                }
            }
            choice sendrisklogins display "medium" default "No" {"Yes"  , "No"}
            optional ( logging.sendrisklogins == "Yes" ) {
                table risklogindata {
                    choice virtual display "xlarge" tcl {
                        
                        return "<ALL-FROM-ABOVE>\n[tmsh::run_proc f5.iapp.1.5.3.cli:iapp_get_items ltm virtual]"
                    }
                    string risklogin display "large"
                    choice loginmethod display "large" default "HTML - Form" {"HTML - Form"  , "HTML - Basic Auth"  , "HTML - Digest"}
                    string usernamefield display "large"
                    choice validationmethod display "large" default "Cookie Name" {"Cookie Name"  , "Cookie Name-Value"  , "Response Code"  , "Redirect Path"}
                    string validation display "large"
                    string validationvalue display "large"
                }
            }
        }
    }

    optional ( basic.syslog == "Yes" && basic.format != "F5 BIG-IQ" ) {
        section syslog {
            optional ( basic.stats == "Yes" ) {
                choice useexistingsplunk display "medium" default "Yes" {"Yes"  , "No"}
            }
            optional ( intro.help == "show" ) {
                message useexistingsplunk_help "For each data source section, you can customize the destination or the event data, or you can use the same destination as you specified in the Analytics System configuration. Select Yes to use the same configuration, or No to customize."
            }
            optional ( syslog.useexistingsplunk == "No"  || basic.stats == "No" ) {
                string splunkdestinationip display "xlarge" required validator "IpOrFqdn"
                string splunkdestinationport required validator "PortNumber" display "small"
                choice splunkdestinationprotocol display "xlarge" default "UDP" {"UDP"  ,"HTTP Event Collector - HTTP"  , "HTTP Event Collector - HTTPS"}
                optional ( syslog.splunkdestinationprotocol == "HTTP Event Collector - HTTP" || syslog.splunkdestinationprotocol == "HTTP Event Collector - HTTPS") {
                    string splunkdestinationhostheader display "xlarge"
                    optional ( intro.hello == "NEVER_SHOW_THIS" ) {
                        choice proxy display "large" default "No" {"Yes"  , "No"  , "From Main Configuration"}
                    }
                    optional ( syslog.proxy == "Yes" ) {
                        message proxynote "Caution sending high speed log messages via a proxy could cause issues with the proxy"
                        string proxyip display "xlarge" required validator "IpOrFqdn"
                        string proxyport required validator "PortNumber" display "small"
                        string proxyuser display "xlarge"
                        password proxypassword display "xlarge"
                    }
                    optional ( intro.help == "show" ) {
                        message proxy_help "You can optionally provide a HTTP host header to be used inside of the communication. This is useful for BIG-IP versions prior to 11.6 where FQDNs are not supported. Providing a host header ensures that proxies and other security devices intercepting this traffic, including the HTTP Event Collector, understand the communication."
                    }
                    optional ( basic.stats == "Yes" && basic.format != "Sumo Logic") {
                        choice useexistingapikey display "medium" default "Yes" {"Yes"  , "No"}
                    }
                    optional ( intro.help == "show" ) {
                        message useexistingapikey_help "Choose whether you want to use the same API key you specified in the Analytics System Configuration section, or if you want to specify a new API key here."
                    }
                    optional ( syslog.useexistingapikey == "No"  || basic.stats == "No" ) {
                        string splunkapikey display "xxlarge" required
                    }
                }
            }
            optional ( intro.advanced == "show" ) {
                optional ( logging.splunkdestinationprotocol == "HTTP Event Collector - HTTP" || logging.splunkdestinationprotocol == "HTTP Event Collector - HTTPS") {
                    choice snatpool display "xlarge" default "Auto-Map" tcl {
                        
                        return "Auto-Map\n[tmsh::run_proc f5.iapp.1.5.3.cli:iapp_get_items ltm snatpool]"
                    }
                    optional ( intro.help == "show" ) {
                        message snatpool_help "Choose whether you want to use SNAT auto map or if you have configured a SNAT pool to perform source network address translation. When data is transmitted from the iApp, the source IP of the traffic is set to an IP address the BIG-IP owns. By default this will be the floating Self IP address with the most direct route to the external server, or if none, a non-floating Self IP (for details see F5 Solution Article K7336). If you create a SNAT Pool manually outside the iApp you can specify exactly which source IP address(es) to use for connections to the external server."
                    }
                }
            }
            optional ( (basic.stats == "Yes" && syslog.useexistingsplunk == "Yes") || ( syslog.splunkdestinationprotocol == "HTTP Event Collector - HTTP" || syslog.splunkdestinationprotocol == "HTTP Event Collector - HTTPS") ) {
                message warningtmm "Note selecting HTTP Event Collector will cause syslogs to only be sent when TMM is online"
            }
        }
    }

    optional ( basic.alerts == "Yes" && basic.format != "F5 BIG-IQ" ) {
        section alerts {
            optional ( basic.stats == "Yes" ) {
                choice useexistingsplunk display "medium" default "Yes" {"Yes"  , "No"}
            }
            optional ( intro.help == "show" ) {
                message useexistingsplunk_help "For each data source section, you can customize the destination or the event data, or you can use the same destination as you specified in the Analytics System configuration. Select Yes to use the same configuration, or No to customize."
            }
            optional ( alerts.useexistingsplunk == "No"  || basic.stats == "No" ) {
                string splunkdestinationip display "xlarge" required validator "IpOrFqdn"
                string splunkdestinationport required validator "PortNumber" display "small"
                choice splunkdestinationprotocol display "xlarge" default "UDP" {"UDP"  ,"HTTP Event Collector - HTTP"  , "HTTP Event Collector - HTTPS"}
                optional ( alerts.splunkdestinationprotocol == "UDP") {
                    string splunkdestinationcommunity required display "large"
                }
                optional ( alerts.splunkdestinationprotocol == "HTTP Event Collector - HTTP" || alerts.splunkdestinationprotocol == "HTTP Event Collector - HTTPS") {
                    string splunkdestinationhostheader display "xlarge"
                    optional ( intro.hello == "NEVER_SHOW_THIS" ) {
                        choice proxy display "large" default "No" {"Yes"  , "No"  , "From Main Configuration"}
                    }
                    optional ( alerts.proxy == "Yes" ) {
                        message proxynote "Caution sending high speed log messages via a proxy could cause issues with the proxy"
                        string proxyip display "xlarge" required validator "IpOrFqdn"
                        string proxyport required validator "PortNumber" display "small"
                        string proxyuser display "xlarge"
                        password proxypassword display "xlarge"
                    }
                    optional ( intro.help == "show" ) {
                        message proxy_help "You can optionally provide a HTTP host header to be used inside of the communication. This is useful for BIG-IP versions prior to 11.6 where FQDNs are not supported. Providing a host header ensures that proxies and other security devices intercepting this traffic, including the HTTP Event Collector, understand the communication."
                    }
                    optional ( basic.stats == "Yes" && basic.format != "Sumo Logic") {
                        choice useexistingapikey display "medium" default "Yes" {"Yes"  , "No"}
                    }
                    optional ( intro.help == "show" ) {
                        message useexistingapikey_help "Choose whether you want to use the same API key you specified in the Analytics System Configuration section, or if you want to specify a new API key here."
                    }
                    optional ( alerts.useexistingapikey == "No"  || basic.stats == "No" ) {
                        string splunkapikey display "xxlarge" required
                    }
                }
            }
            optional ( intro.advanced == "show" ) {
                optional ( logging.splunkdestinationprotocol == "HTTP Event Collector - HTTP" || logging.splunkdestinationprotocol == "HTTP Event Collector - HTTPS") {
                    choice snatpool display "xlarge" default "Auto-Map" tcl {
                        
                        return "Auto-Map\n[tmsh::run_proc f5.iapp.1.5.3.cli:iapp_get_items ltm snatpool]"
                    }
                    optional ( intro.help == "show" ) {
                        message snatpool_help "Choose whether you want to use SNAT auto map or if you have configured a SNAT pool to perform source network address translation. When data is transmitted from the iApp, the source IP of the traffic is set to an IP address the BIG-IP owns. By default this will be the floating Self IP address with the most direct route to the external server, or if none, a non-floating Self IP (for details see F5 Solution Article K7336). If you create a SNAT Pool manually outside the iApp you can specify exactly which source IP address(es) to use for connections to the external server."
                    }
                }
            }
            optional ( (basic.stats == "Yes" && alerts.useexistingsplunk == "Yes") || ( alerts.splunkdestinationprotocol == "HTTP Event Collector - HTTP" || alerts.splunkdestinationprotocol == "HTTP Event Collector - HTTPS") ) {
                message warningtmm "Note selecting HTTP Event Collector will cause SNMP traps to only be sent when TMM is online"
            }
        }
    }

    optional ( basic.ihealth == "Yes" && basic.format != "F5 BIG-IQ" ) {
        section ihealth {
            string ihealthuser required display "xlarge"
            password ihealthpassword required display "xlarge"
            choice proxy display "large" default "No" {"Yes"  , "No"  , "From Main Configuration"}
            optional ( ihealth.proxy == "Yes" ) {
                string proxyip display "xlarge" required validator "IpOrFqdn"
                string proxyport required validator "PortNumber" display "small"
                string proxyuser display "xlarge"
                password proxypassword display "xlarge"
            }
            optional ( intro.help == "show" ) {
                message proxy_help "You can optionally provide a HTTP host header to be used inside of the communication. This is useful for BIG-IP versions prior to 11.6 where FQDNs are not supported. Providing a host header ensures that proxies and other security devices intercepting this traffic, including the HTTP Event Collector, understand the communication."
            }
            choice schedule display "medium" default "Weekly" {"Daily"  , "Weekly"  , "Monthly"}
            optional ( ihealth.schedule == "Weekly") {
                choice dayofweek display "medium" default "Sunday" {"Monday"  , "Tuesday"  , "Wednesday"  , "Thursday"  , "Friday"  , "Saturday"  , "Sunday"}
            }
            optional ( ihealth.schedule == "Monthly") {
                string dayofmonth display "medium"
            }
            string time required default "1:00" display "medium"
            string endtime required default "4:00" display "medium"
            optional ( intro.help == "show" ) {
                message time_help "Specify a two or more hour window in 24hr format that iHealth data can be sent."
            }
        }

    }

    optional ( basic.silverline == "Yes" && basic.format != "F5 BIG-IQ" ) {
        section silverline {
            string silverlineuser display "xlarge"
            password silverlinepassword display "xlarge"
            string interval display "small" required default "300" validator "NonNegativeNumber"
            choice proxy display "large" default "No" {"Yes"  , "No"  , "From Main Configuration"}
            optional ( silverline.proxy == "Yes" ) {
                string proxyip display "xlarge" required validator "IpOrFqdn"
                string proxyport required validator "PortNumber" display "small"
                string proxyuser display "xlarge"
                password proxypassword display "xlarge"
            }
            optional ( intro.help == "show" ) {
                message proxy_help "You can optionally provide a HTTP host header to be used inside of the communication. This is useful for BIG-IP versions prior to 11.6 where FQDNs are not supported. Providing a host header ensures that proxies and other security devices intercepting this traffic, including the HTTP Event Collector, understand the communication."
            }
        }
    }

    optional ( statistics.pushconfig == "Yes" && basic.stats == "Yes" && basic.format != "F5 BIG-IQ") {
        section applicationmapping {
            choice irulesearch display "medium" default "Yes" {"Yes"  , "No"}
            optional ( applicationmapping.irulesearch == "Yes") {
                message irulesearchmessage1 "iRules will now be searched for Pools, HTTP::respond, TCP::respond, and UDP::respond. These actions must be on a line by themselves. To add context include a comment as follows:"
                message irulesearchmessage2 "    pool mypoolname ;#context: Image Requests"
                message irulesearchmessage3 "    HTTP::respond 301 location HTTPS:/.... ;#context: Redirects for Marketing istat: marketing301s"
                message irulesearchmessage4 "    TCP::respond denied... ;#context: denied packet type 1 istat: denied_packets_type1"
                message irulesearchmessage5 "    DNS::answer insert.... ;#context: answer type a"
            }
            choice mode display "xlarge" default "Define" {"Define"  , "Use Existing"  , "Use Existing with Additional"}
            optional ( applicationmapping.mode == "Use Existing" || applicationmapping.mode == "Use Existing with Additional" ) {
                 string mapping display "xxlarge"
            }
            optional ( applicationmapping.mode == "Define" || applicationmapping.mode == "Use Existing with Additional") {
                table mappings {
                    string priority validator "NonNegativeNumber" display "small"
                    choice type display "large" default "App Name" {"Tenant Name"  , "App Name"  , "App Component Name"  , "Application Dependencies"}
                    choice datasource display "large" default "Virtual Name" {"Virtual Name"  , "Wideip Name"  , "Virtual IP"  , "Virtual Port"  , "Virtual Protocol"  , "Virtual Description"  , "Partition"  , "iApp Name"}
                    string regex display "xlarge"
                    choice mappingaction display "large" default "Map" {"Map"  , "Append"  , "Ignore"  , "Direct Mapping"  , "Direct Mapping Append"}
                    string appendprefix display "large"
                    string directmapping display "large"

                }
                message mappinginfo "Mappings can be defined using regular expressions (regex) to match data items. For help with regular expressions, see https://regex101.com/"
                string exportmapping display "xxlarge"
                message exportmappinginfo "You can copy the above string and use it to configure other instances of this iApp template. To ensure the latest version of the export string only copy this string after saving your changes and waiting 60 seconds."
            }
        }
    }
}

text {
    intro "Welcome to the F5 BIG-IP Analytics iApp Template f5.analytics.v3.7.1rc2"
    
        intro.early_release "EARLY RELEASE"
    
    intro.hello "Introduction"
    intro.hello1 ""
    intro.hello2 ""
    intro.check_for_updates "Check for updates"
    intro.help "Do you want to see inline help?"
    intro.help_help ""
    intro.advanced "Do you want to display advanced options?"
    intro.advanced_advanced ""

    basic "Information Sources"
    basic.format "Data Format"
    basic.format_help ""
    basic.appiqformat "Send data in native F5 Analytics Format?"
    basic.avrinterval "AVR Data Feed Interval (in seconds)"
    basic.uniqueid "Unique ID"
    basic.debug "Log Stats Responses"
    basic.debug_help ""
    basic.uniqueid_help ""
    basic.systemtenant "Analytics System Tenant"
    basic.systemtenant_help ""
    basic.rbac "Role Based Access Controls"
    basic.rbac_help ""
    basic.stats "System Statistics"
    basic.stats_help ""
    basic.logging "Module High Speed Logging Streams"
    basic.logging_help ""
    basic.syslog "Local System Logging (syslog)"
    basic.syslog_help ""
    basic.alerts "System SNMP Alerts"
    basic.alerts_help ""
    basic.ihealth "iHealth Snapshot Information"
    basic.ihealth_help ""
    basic.silverline "Silverline Service Statistics"
    basic.silverline_help ""
    basic.facility "Facility Name"
    basic.facility_help ""
    basic.devicegroupoverride "Alternate Device Group"
    basic.devicegroupoverride_help ""
    basic.hostnameoverride "Alternate Hostname"
    basic.hostnameoverride_help ""
    basic.tenantdefault "Default Tenant"
    basic.tenantdefault_help ""
    basic.callbacktype "Analytics Callback Integration"
    basic.callbackurl "Callback URL"
    basic.callbacktype_help ""

    rbac "Role Based Access Control (RBAC)"
    rbac.indexprefix "Use an Index Prefix?"
    rbac.indexprefix_help ""
    rbac.indexprefixstring "Index Prefix"
    rbac.indexprefixstring_help ""
    rbac.systemindex "System Statistics Index"
    rbac.systemindex_help ""
    rbac.systemindexstring "Name for Statistics Index"
    rbac.systemindexstring_help ""
    rbac.defaultindex "Default Statistics Index"
    rbac.defaultindex_help ""
    rbac.defaultindexstring "Name for Default System Index"
    rbac.defaultindexstring_help ""
    rbac.logindex "Event Index"
    rbac.logindex_help ""
    rbac.logindexstring "Name for Event Index"
    rbac.logindexstring_help ""
    rbac.sharedindex "Shared Statistics Index"
    rbac.sharedindex_help ""
    rbac.sharedindexstring "Name for Shared Statistics Index"
    rbac.sharedindexstring_help ""

    statistics "Analytics System Configuration"
    statistics.splunkdestinationip "IP Address or Hostname"
    statistics.splunkdestinationip_help ""
    statistics.splunkdestinationhostheader "Hostname when destination is an IP address"
    statistics.splunkdestinationhostheader_help ""
    statistics.splunkdestinationprotocol "Protocol"
    statistics.splunkdestinationprotocol_help ""
    statistics.splunkdestinationport "Port"
    statistics.splunkdestinationport_help ""
    statistics.splunk_help ""
    statistics.proxy "Use an HTTP Proxy?"
    statistics.proxy_help ""
    statistics.proxyip "Proxy IP Address"
    statistics.proxyport "Proxy Port"
    statistics.proxyuser "Proxy Username"
    statistics.proxypassword "Proxy Password"
    statistics.splunkapikey "API Key"
    statistics.pushinterval "Push Interval (in seconds)"
    statistics.pushinterval_help ""
    statistics.pushstate "Push Device State?"
    statistics.pushstate_help ""
    statistics.pushtmstats "Push Device Statistics?"
    statistics.pushtmstats_help ""
    statistics.pushistats "Push iStats?"
    statistics.pushistats_help ""
    statistics.pushsslistats "Push SSLi Stats?"
    statistics.pushsslistats_help ""
    statistics.pushavr "Push AVR-sampled Data?"
    statistics.pushavr_help ""
    statistics.pushsessiondb "Push APM SessionDB Statistics?"
    statistics.pushsessiondb_help ""
    statistics.customsessiondb "Include Custom SessionDB Variables in APM Statistics?"
    statistics.customsessiondb_help ""
    statistics.customsessiondb1 "Custom SessionDB 1"
    statistics.customsessiondb2 "Custom SessionDB 2"
    statistics.customsessiondb3 "Custom SessionDB 3"
    statistics.customsessiondb4 "Custom SessionDB 4"
    statistics.customsessiondb5 "Custom SessionDB 5"
    statistics.customcollection "Manually Manage Statistics Collection?"
    statistics.customcollection_help ""
    statistics.customcollectionconfig "Custom Stat Collection"
    statistics.randomstart "Randomize the start time within the push interval?"
    statistics.randomstart_help ""

    statistics.pushconfig "Push Configuration Map?"
    statistics.pushconfig_help ""
    statistics.certexpiration "Push Certificate Expiration Information?"
    statistics.tuning_help ""

    logging "Module Log Stream Capture"
    logging.useexistingsplunk "Use the same configuration as in the Analytics System Configuration section?"
    logging.useexistingsplunk_help ""
    logging.splunkdestinationip "IP Address or Hostname"
    logging.splunkdestinationhostheader "Hostname when the destination is an IP address"
    logging.splunkdestinationport "Port"
    logging.splunkdestinationprotocol "Protocol"
    logging.proxy "Use an HTTP Proxy?"
    logging.proxynote "WARNING"
    logging.proxyip "Proxy IP Address"
    logging.proxyport "Proxy Port"
    logging.proxyuser "Proxy Username"
    logging.proxypassword "Proxy Password"
    logging.proxy_help ""
    logging.useexistingapikey "Use the same API key as the main configuration?"
    logging.useexistingapikey_help ""
    logging.splunkapikey "API Key"
    logging.snatpool "Source Address Translation"
    logging.snatpool_help ""
    logging.sendadm "Send Behavioral Anti-DDoS Stats?"
    logging.sendadm_help ""


    logging.sendriskdata "Send Risk Logs to Analytics System?"
    logging.virtual "Virtual Servers to Attach Risk Logging Profile"
    logging.sendrisklogins "Send Login Events to Analytics System?"
    logging.risklogindata "Configured Logins"
    logging.risklogindata.virtual "Virtual Server"
    logging.risklogindata.risklogin "Login Path"
    logging.risklogindata.loginmethod "Login Method"
    logging.risklogindata.usernamefield "Username Field"
    logging.risklogindata.validationmethod "Validation Method"
    logging.risklogindata.validation "Validation Check String"
    logging.risklogindata.validationvalue "Validation Check Cookie Value"


    syslog "Local Logging Capture"
    syslog.useexistingsplunk "Use the same configuration as in the Analytics System Configuration section?"
    syslog.useexistingsplunk_help ""
    syslog.splunkdestinationip "IP Address or Hostname"
    syslog.splunkdestinationhostheader "Hostname when the destination is an IP address"
    syslog.splunkdestinationport "Port"
    syslog.splunkdestinationprotocol "Protocol"
    syslog.proxy "Use an HTTP Proxy?"
    syslog.proxynote "WARNING"
    syslog.proxyip "Proxy IP Address"
    syslog.proxyport "Proxy Port"
    syslog.proxyuser "Proxy Username"
    syslog.proxypassword "Proxy Password"
    syslog.proxy_help ""
    syslog.useexistingapikey "Use the same API key as the main configuration?"
    syslog.useexistingapikey_help ""
    syslog.splunkapikey "API Key"
    syslog.warningtmm "WARNING"
    syslog.snatpool "Source Address Translation"
    syslog.snatpool_help ""

    alerts "System SNMP Alert Capture"
    alerts.useexistingsplunk "Use the same configuration as in the Analytics System Configuration section?"
    alerts.useexistingsplunk_help ""
    alerts.splunkdestinationip "IP Address or Hostname"
    alerts.splunkdestinationhostheader "Hostname when the destination is an IP address"
    alerts.splunkdestinationport "Port"
    alerts.splunkdestinationprotocol "Protocol"
    alerts.proxy "Use an HTTP Proxy?"
    alerts.proxynote "WARNING"
    alerts.proxyip "Proxy IP Address"
    alerts.proxyport "Proxy Port"
    alerts.proxyuser "Proxy Username"
    alerts.proxypassword "Proxy Password"
    alerts.proxy_help ""
    alerts.useexistingapikey "Use the same API key as the main configuration?"
    alerts.useexistingapikey_help ""
    alerts.splunkapikey "API Key"
    alerts.splunkdestinationcommunity "SNMP Community Name"
    alerts.warningtmm "WARNING"
    alerts.snatpool "Source Address Translation"
    alerts.snatpool_help ""

    ihealth "iHealth Snapshot Information Capture"
    ihealth.ihealthuser "iHealth Username"
    ihealth.ihealthpassword "iHealth Password"
    ihealth.proxy "Use an HTTP Proxy?"
    ihealth.proxyip "Proxy IP Address"
    ihealth.proxyport "Proxy Port"
    ihealth.proxyuser "Proxy Username"
    ihealth.proxypassword "Proxy Password"
    ihealth.proxy_help ""
    ihealth.schedule "Schedule"
    ihealth.dayofweek "Day of the Week"
    ihealth.dayofmonth "Day of the Month"
    ihealth.time "Start Time"
    ihealth.endtime "End Time"
    ihealth.time_help ""

    silverline "Silverline Statistics Capture"
    silverline.silverlineuser "Silverline Username"
    silverline.silverlinepassword "Silverline Password"
    silverline.interval "Collection Interval (in seconds)"
    silverline.proxy "Use an HTTP Proxy?"
    silverline.proxyip "Proxy IP Address"
    silverline.proxyport "Proxy Port"
    silverline.proxyuser "Proxy Username"
    silverline.proxypassword "Proxy Password"
    silverline.proxy_help ""

    applicationmapping "Application Mapping"
    applicationmapping.irulesearch "Search iRules?"
    applicationmapping.irulesearchmessage1 ""
    applicationmapping.irulesearchmessage2 ""
    applicationmapping.irulesearchmessage3 ""
    applicationmapping.irulesearchmessage4 ""
    applicationmapping.irulesearchmessage5 ""
    applicationmapping.mode "Configuration Mode"
    applicationmapping.mappinginfo ""
    applicationmapping.mappings "Mapping Table"
    applicationmapping.mappings.priority "Order"
    applicationmapping.mappings.type "Type"
    applicationmapping.mappings.datasource "From"
    applicationmapping.mappings.regex "Regex"
    applicationmapping.mappings.mappingaction "Action"
    applicationmapping.mappings.appendprefix "AppendPrefix"
    applicationmapping.mappings.directmapping "DirectMapping"
    applicationmapping.exportmappinginfo ""
    applicationmapping.exportmapping "Mapping Element for Export"
    applicationmapping.mapping "Mapping Import String"
}
            }
            role-acl none
            run-as none
        }
    }
    requires-bigip-version-max none
    requires-bigip-version-min 11.4.0
    description "F5 Analytics iApp"
}
